# revision e45a15d8f494f70c9285e1532c6b6460328f6b89 11/04/2017 17:45
--- enigma2.org/configure.ac
+++ enigma2/configure.ac
 AC_PATH_PROG(MSGFMT, msgfmt, AC_MSG_ERROR(Could not find msgfmt))
 
 AM_PATH_PYTHON
+PYTHON_NOVERSIONCHECK=no
 AX_PYTHON_DEVEL
 AX_PKG_SWIG
 AX_SWIG_ENABLE_CXX
@@ -34,11 +35,150 @@
 	AS_HELP_STRING([--with-gstversion],[use gstreamer version (major.minor)]),
 	[GST_MAJORMINOR=$withval],[GST_MAJORMINOR=0.10])
 
-PKG_CHECK_MODULES(GSTREAMER, gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR)
-PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+AC_ARG_ENABLE(libeplayer3,
+	[  --enable-libeplayer3          enable TDT libeplayer3 as player engine support],
+	[AC_DEFINE(ENABLE_LIBEPLAYER3,1,[enable TDT libeplayer3 as player engine support])])
+
+AM_CONDITIONAL(ENABLE_LIBEPLAYER3,test "$enable_libeplayer3" = "yes")
+if test "$enable_libeplayer3" = "yes"; then
+	AC_DEFINE(ENABLE_LIBEPLAYER3,1,[include TDT libeplayer3 as player engine support])
+fi
+
+AC_ARG_ENABLE(mediafwgstreamer,
+	[  --enable-mediafwgstreamer      enable gstreamer as player engine support],
+	[AC_DEFINE(ENABLE_MEDIAFWGSTREAMER,1,[enable gstreamer as player engine support])])
+
+AM_CONDITIONAL(ENABLE_MEDIAFWGSTREAMER,test "$enable_mediafwgstreamer" = "yes")
+if test "$enable_mediafwgstreamer" = "yes"; then
+	AC_DEFINE(ENABLE_MEDIAFWGSTREAMER,1,[include gstreamer as player engine support])
+fi
+
+if test "$enable_mediafwgstreamer" = "yes"; then
+	PKG_CHECK_MODULES(GSTREAMER, gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR)
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+else
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+fi
 PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
 AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
 PKG_CHECK_MODULES(AVAHI, avahi-client)
+
+AC_ARG_ENABLE([tf7700],
+	[AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+	[case "${enableval}" in
+		yes) enable_tf7700=true ;;
+		no) enable_tf7700=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+	[AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+	[case "${enableval}" in
+		yes) enable_cuberevo=true ;;
+		no) enable_cuberevo=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
+AC_ARG_ENABLE([spark],
+	[AS_HELP_STRING(--enable-spark,    enable Spark stuff)],
+	[case "${enableval}" in
+		yes) enable_spark=true ;;
+		no) enable_spark=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-spark]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_SPARK], [test x$enable_spark = xtrue])
+
+AC_ARG_ENABLE([spark7162],
+	[AS_HELP_STRING(--enable-spark7162,    enable Spark 7162 stuff)],
+	[case "${enableval}" in
+		yes) enable_spark7162=true ;;
+		no) enable_spark7162=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-spark7162]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_SPARK7162], [test x$enable_spark7162 = xtrue])
+
+AC_ARG_ENABLE([octagon1008],
+	[AS_HELP_STRING(--enable-octagon1008,    enable Fortis HS9510 stuff)],
+	[case "${enableval}" in
+		yes) enable_octagon1008=true ;;
+		no) enable_octagon1008=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-octagon1008]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_OCTAGON1008], [test x$enable_octagon1008 = xtrue])
+
+AC_ARG_ENABLE([atevio7500],
+	[AS_HELP_STRING(--enable-atevio7500,   enable Fortis HS8200 stuff)],
+	[case "${enableval}" in
+		yes) enable_atevio7500=true ;;
+		no) enable_atevio7500=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-atevio7500]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_ATEVIO7500], [test x$enable_atevio7500 = xtrue])
+
+AC_ARG_ENABLE([fortis_hdbox],
+	[AS_HELP_STRING(--enable-fortis_hdbox,    enable Fortis FS9000/9200 stuff)],
+	[case "${enableval}" in
+		yes) enable_fortis_hdbox=true ;;
+		no) enable_fortis_hdbox=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-fortis_hdbox]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_FORTIS_HDBOX], [test x$enable_fortis_hdbox = xtrue])
+
+AC_ARG_ENABLE([hs7110],
+	[AS_HELP_STRING(--enable-hs7110,    enable Fortis HS7110 stuff)],
+	[case "${enableval}" in
+		yes) enable_hs7110=true ;;
+		no) enable_hs7110=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-hs7110]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_HS7110], [test x$enable_hs7110 = xtrue])
+
+AC_ARG_ENABLE([hs7119],
+	[AS_HELP_STRING(--enable-hs7119,    enable Fortis HS7119 stuff)],
+	[case "${enableval}" in
+		yes) enable_hs7119=true ;;
+		no) enable_hs7119=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-hs7119]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_HS7119], [test x$enable_hs7119 = xtrue])
+
+AC_ARG_ENABLE([hs7420],
+	[AS_HELP_STRING(--enable-hs7420,    enable Fortis HS7420 stuff)],
+	[case "${enableval}" in
+		yes) enable_hs7420=true ;;
+		no) enable_hs7420=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-hs7420]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_HS7420], [test x$enable_hs7420 = xtrue])
+
+AC_ARG_ENABLE([hs7429],
+	[AS_HELP_STRING(--enable-hs7429,    enable Fortis HS7429 stuff)],
+	[case "${enableval}" in
+		yes) enable_hs7429=true ;;
+		no) enable_hs7429=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-hs7429]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_HS7429], [test x$enable_hs7429 = xtrue])
+
+AC_ARG_ENABLE([hs7810a],
+	[AS_HELP_STRING(--enable-hs7810a,    enable Fortis HS7810A stuff)],
+	[case "${enableval}" in
+		yes) enable_hs7810a=true ;;
+		no) enable_hs7810a=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-hs7810a]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_HS7810A], [test x$enable_hs7810a = xtrue])
+
+AC_ARG_ENABLE([hs7819],
+	[AS_HELP_STRING(--enable-hs7819,    enable Fortis HS7819 stuff)],
+	[case "${enableval}" in
+		yes) enable_hs7819=true ;;
+		no) enable_hs7819=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-hs7819]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_HS7819], [test x$enable_hs7819 = xtrue])
 
 AC_CHECK_LIB([udfread], [udfread_init])
 AC_CHECK_LIB([dl], [dlopen], [LIBDL_LIBS="-ldl"], [AC_MSG_ERROR([Could not find libdl])])
@@ -205,6 +345,22 @@
 	PKG_CHECK_MODULES(DVBCSA, libdvbcsa)
 fi
 
+AC_ARG_WITH(graphlcd,
+	AC_HELP_STRING([--with-graphlcd], [use GraphLCD color display, yes or no]),
+	[[withgraphlcd=$withval]],
+	[[withgraphlcd=no]]
+)
+if test x"$withgraphlcd" != xno ; then
+	AC_DEFINE(HAVE_GRAPHLCD, 1,[Define when using a GraphLCD color display device])
+fi
+AM_CONDITIONAL(HAVE_GRAPHLCD, test x"$withgraphlcd" != xno)
+
+PKG_CHECK_MODULES([AVFORMAT], [libavformat >= 53.21.1])
+PKG_CHECK_MODULES([AVCODEC], [libavcodec >= 54.28.0])
+# do not know which version is exactly needed here...
+PKG_CHECK_MODULES([AVUTIL], [libavutil])
+PKG_CHECK_MODULES([SWSCALE], [libswscale])
+PKG_CHECK_MODULES([SWRESAMPLE], [libswresample])
 
 ENIGMA2_CFLAGS="-fno-rtti -fno-exceptions"
 AC_SUBST(ENIGMA2_CFLAGS)
@@ -266,8 +422,6 @@
 lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
 lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
 lib/python/Plugins/PLi/Makefile
-lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
-lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/meta/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/meta/Makefile
 lib/python/Plugins/SystemPlugins/DiseqcTester/Makefile
@@ -297,6 +451,50 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/meta/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/locale/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/meta/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/locale/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/meta/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/locale/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/meta/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/locale/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/meta/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/locale/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/meta/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/locale/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/sparkVFD/Makefile
+lib/python/Plugins/Extensions/sparkVFD/meta/Makefile
+lib/python/Plugins/Extensions/sparkVFD/locale/Makefile
+lib/python/Plugins/Extensions/sparkVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/sparkVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/meta/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/locale/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 po/Makefile
 main/Makefile
--- enigma2.org/data/skin_display_default.xml
+++ enigma2/data/skin_display_default.xml
@@ -22,27 +22,29 @@
 
 <!-- template -->
 	<screen name="SummaryClockPanel">
-		<widget source="global.CurrentTime" render="Label" position="right" size="60,*" font="FdLcD;24" halign="right" valign="top" noWrap="1">
+		<widget source="global.CurrentTime" render="Label" position="right" size="160,*" font="FdLcD;44" halign="right" valign="top" noWrap="1">
 			<convert type="ClockToText"></convert>
 		</widget>
-		<widget source="session.RecordState" render="FixedLabel" text="Rec" position="4,12" size="24,12" font="FdLcD;12" zPosition="1" noWrap="1">
-			<convert type="ConditionalShowHide">Blink</convert>
+		<widget source="session.RecordState" render="FixedLabel" text="Rec" position="140,20" size="60,36" foregroundColor="#f23d21" font="FdLcD;35" zPosition="1" noWrap="1">
 		</widget>
 	</screen>
 
 <!-- main-->
 	<screen name="InfoBarSummary" position="fill">
-		<widget source="session.CurrentService" render="Label" position="top" size="*,21" font="FdLcD;20" halign="left" noWrap="1">
+		<widget source="session.CurrentService" render="Picon" position="0,165" zPosition="1" size="100,60" alphatest="on">
+				<convert type="ServiceName">Reference</convert>
+		</widget>
+		<widget source="session.CurrentService" render="Label" position="top" size="*,81" font="FdLcD;40" halign="center" foregroundColor="#ffff7f" >
 			<convert type="ServiceName">Name</convert>
 		</widget>
-		<widget source="session.Event_Now" render="Label" position="top" size="*,15" font="FdLcD;14" halign="left" noWrap="1">
+		<widget source="session.Event_Now" render="Label" position="top" size="*,61" font="FdLcD;30" halign="center" >
 			<convert type="EventName">Name</convert>
 		</widget>
-		<widget source="session.Event_Now" render="Progress" position="top" size="*,4" borderWidth="1" >
+		<widget source="session.Event_Now" render="Progress" position="top" size="*,14" borderWidth="3" >
 			<convert type="EventTime">Progress</convert>
 		</widget>
-		<panel position="bottom" size="*,24" name="SummaryClockPanel">
-			<widget source="session.Event_Now" render="Label" position="4,0" size="40,12" font="FdLcD;12" halign="left" noWrap="1">
+		<panel position="bottom" size="*,44" name="SummaryClockPanel">
+			<widget source="session.Event_Now" render="Label" position="215,0" size="110,40" font="FdLcD;44" halign="left" noWrap="1">
 				<convert type="EventTime">Remaining</convert>
 				<convert type="RemainingToText">NoSeconds</convert>
 			</widget>
@@ -52,43 +54,43 @@
 
 <!-- channelselection-->
 	<screen name="ChannelSelection_summary" position="fill">
-		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,21" font="FdLcD;20" halign="left" noWrap="1" >
+		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,81" font="FdLcD;40" halign="center" foregroundColor="#ffff7f" >
 			<convert type="ServiceName">Name</convert>
 		</widget>
-		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,15" font="FdLcD;14" halign="left" noWrap="1">
+		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,61" font="FdLcD;30" halign="center" >
 			<convert type="EventName">Name</convert>
 		</widget>
-		<widget source="parent.ServiceEvent" render="Progress" position="top" size="*,4" borderWidth="1">
+		<widget source="parent.ServiceEvent" render="Progress" position="top" size="*,14" borderWidth="3">
 			<convert type="EventTime">Progress</convert>
 		</widget>
-		<panel position="bottom" size="*,24" name="SummaryClockPanel" />
+		<panel position="bottom" size="*,44" name="SummaryClockPanel" />
 	</screen>
 
 <!-- menus-->
 	<screen name="MenuSummary" position="fill">
-		<widget source="parent.title" render="Label" position="top" size="*,16" font="FdLcD;14" halign="center" valign="top" noWrap="1" />
-		<widget source="parent.menu" render="Label" position="top" size="*,48" font="FdLcD;16" halign="left" valign="top">
+		<widget source="parent.title" render="Label" position="top" size="*,120" font="FdLcD;40" halign="center" valign="top" foregroundColor="#ffff7f" />
+		<widget source="parent.menu" render="Label" position="top" size="*,61" font="FdLcD;30" halign="center" valign="top">
 			<convert type="StringListSelection" />
 		</widget>
 	</screen>
 
 <!-- movieplayer-->
 	<screen name="InfoBarMoviePlayerSummary" position="fill">
-		<widget source="session.CurrentService" render="Label" position="top" size="*,36" font="FdLcD;16" halign="left" valign="top" >
+		<widget source="session.CurrentService" render="Label" position="top" size="*,140" font="FdLcD;40" halign="center" valign="center" foregroundColor="#ffff7f" >
 			<convert type="ServiceName">Name</convert>
 		</widget>
-		<widget source="session.CurrentService" render="Progress" position="top" size="*,4" borderWidth="1">
+		<widget source="session.CurrentService" render="Progress" position="top" size="*,14" borderWidth="3">
 			<convert type="ServicePosition">Position</convert>
 		</widget>
-		<panel position="bottom" size="*,24" name="SummaryClockPanel">
-			<widget source="session.CurrentService" render="Label" position="4,0" size="42,12" font="FdLcD;12" halign="left" noWrap="1">
+		<panel position="bottom" size="*,44" name="SummaryClockPanel">
+			<widget source="session.CurrentService" render="Label" position="240,0" size="110,40" font="FdLcD;44" halign="left" noWrap="1">
 				<convert type="ServicePosition">Position</convert>
 			</widget>
 		</panel>
 	</screen>
 
 	<screen name="MovieContextMenuSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,14" font="FdLcD;12" halign="left" valign="top" noWrap="1" />
+		<widget source="parent.Title" render="Label" position="top" size="*,14" font="FdLcD;12" halign="left" valign="top" noWrap="1"/>
 		<widget source="selected" render="Label" position="top" size="*,32" font="FdLcD;16" />
 		<panel position="bottom" size="*,18">
 			<widget source="global.CurrentTime" render="Label" position="right" size="60,*" halign="right" font="FdLcD;16" >
@@ -98,10 +100,10 @@
 	</screen>
 
 	<screen name="MovieSelectionSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,14" font="FdLcD;12" halign="left" valign="top" noWrap="1" />
-		<widget source="name" render="Label" position="top" size="*,32" font="FdLcD;16" halign="left" valign="top" />
-		<panel position="bottom" size="*,18">
-			<widget source="parent.Service" render="Label" position="right" size="46,*" font="FdLcD;14" halign="left" noWrap="1">
+		<widget source="parent.Title" render="Label" position="top" size="*,70" font="FdLcD;27" halign="center" valign="top"/>
+		<widget source="name" render="Label" position="top" size="*,106" font="FdLcD;35" halign="center" valign="top" foregroundColor="#ffff7f" />
+		<panel position="bottom" size="*,44">
+			<widget source="parent.Service" render="Label" position="right" size="180,*" font="FdLcD;30" halign="right" noWrap="1">
 				<convert type="MovieInfo">FileSize</convert>
 			</widget>
 			<widget source="parent.Service" render="Label" position="fill" font="FdLcD;14" halign="left" noWrap="1">
@@ -128,53 +130,52 @@
 
 <!-- setup-->
 	<screen name="SetupSummary" position="fill">
-		<widget source="SetupTitle" render="Label" position="top" size="*,12" font="FdLcD;12" halign="left" />
-		<widget source="SetupEntry" render="Label" position="top" size="*,40" font="FdLcD;12" halign="left" />
-		<widget source="SetupValue" render="Label" position="top" size="*,12" font="FdLcD;12" halign="left" />
+		<widget source="SetupTitle" render="Label" position="top" size="*,61" font="FdLcD;30" halign="left" />
+		<widget source="SetupEntry" render="Label" position="top" size="*,51" font="FdLcD;25" halign="left" />
+		<widget source="SetupValue" render="Label" position="top" size="*,51" font="FdLcD;25" halign="left" />
 	</screen>
 
 <!-- misc-->
 	<screen name="SimpleSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,40" font="FdLcD;16" halign="center" valign="center" />
+		<widget source="parent.Title" render="Label" position="top" size="*,100" font="FdLcD;40" halign="center" valign="center" />
 		<panel position="bottom" size="*,24" name="SummaryClockPanel" />
 	</screen>
 
 	<screen name="WizardSummary" position="fill">
-		<widget source="text" render="Label" position="top" size="*,16" font="FdLcD;16"/>
-		<widget source="parent.list" render="Label" position="fill" font="FdLcD;12">
+		<widget source="text" render="Label" position="top" size="*,71" font="FdLcD;35" halign="center" />
+		<widget source="parent.list" render="Label" position="fill" font="FdLcD;25" halign="center" >
 			<convert type="StringListSelection" />
 		</widget>
 	</screen>
 
 	<screen name="VideoWizardSummary" position="fill">
 		<widget name="text" position="top" size="*,40" font="FdLcD;12" transparent="1" />
-		<widget source="parent.list" render="Label" position="fill" font="FdLcD;14">
+		<widget source="parent.list" render="Label" position="fill" font="FdLcD;45" halign="center" >
 			<convert type="StringListSelection" />
 		</widget>
 	</screen>
 
 <!-- standby -->
 	<screen name="StandbySummary" position="fill">
-		<widget source="global.CurrentTime" render="Label" position="center,0" size="120,64" font="FdLcD;48" halign="center" valign="center" noWrap="1">
+		<widget source="global.CurrentTime" render="Label" position="center,center" size="320,121" font="FdLcD;120" halign="center" valign="center" noWrap="1">
 			<convert type="ClockToText"></convert>
 		</widget>
-		<widget source="session.RecordState" render="FixedLabel" text="Recording" position="4,50" size="120,12" font="FdLcD;12" zPosition="2" valign="bottom" halign="left" noWrap="1">
-			<convert type="ConditionalShowHide"></convert>
+		<widget source="session.RecordState" render="FixedLabel" text="Recording" position="center,180" size="190,42" font="FdLcD;40" zPosition="2" valign="bottom" halign="center" noWrap="1" foregroundColor="#0000ff" >
 		</widget>
 	</screen>
 <!-- Plugin browser -->
 	<screen name="PluginBrowserSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,16" font="FdLcD;12"  noWrap="1" />
-		<widget source="entry" render="Label" position="top" size="*,20" font="FdLcD;18" noWrap="1" />
-		<widget source="desc" render="Label" position="fill" font="FdLcD;12" valign="top" />
+		<widget source="parent.Title" render="Label" position="top" size="*,60" font="FdLcD;40" halign="center" foregroundColor="#ffff7f" noWrap="1" />
+		<widget source="entry" render="Label" position="top" size="*,61" font="FdLcD;30" halign="left" />
+		<widget source="desc" render="Label" position="fill" font="FdLcD;22" valign="top" />
 	</screen>
 
 <!-- JobView Summary -->
 	<screen name="JobView_summary" position="fill">
-		<widget source="parent.summary_job_name" render="Label" position="6,4" size="120,42" font="FdLcD;16" />
-		<widget source="parent.summary_job_task" render="Label" position="6,22" size="120,26" font="FdLcD;12" />
-		<widget source="parent.summary_job_progress" render="Progress" position="6,50" size="60,12" borderWidth="1" zPosition="1" />
-		<widget source="parent.summary_job_progress" render="Label" position="66,50" size="50,12" font="FdLcD;12" zPosition="2" halign="center" transparent="1"  >
+		<widget source="parent.summary_job_name" render="Label" position="top" size="*,51" font="FdLcD;25" halign="center" />
+		<widget source="parent.summary_job_task" render="Label" position="top" size="*,41" font="FdLcD;20" halign="center" />
+		<widget source="parent.summary_job_progress" render="Progress" position="top" size="80,16" borderWidth="1" zPosition="1" halign="center" />
+		<widget source="parent.summary_job_progress" render="Label" position="top" size="100,24" font="FdLcD;24" zPosition="2" halign="center" transparent="1"  >
 			<convert type="ProgressToText" />
 		</widget>
 	</screen>
@@ -184,12 +185,12 @@
 	</screen>
 
 	<screen name="MessageBox_summary" position="fill">
-		<widget source="parent.Text" render="Label" position="top" size="*,52" font="FdLcD;11" halign="center" valign="center" />
-		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,14" font="FdLcD;14" halign="center" valign="center" />
+		<widget source="parent.Text" render="Label" position="top" size="*,95" font="FdLcD;31" halign="center" valign="center" />
+		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,44" font="FdLcD;44" halign="center" valign="center" />
 	</screen>
 
 	<screen name="MessageBoxSimple_summary" position="fill">
-		<widget source="parent.Text" render="Label" position="top" size="*,52" font="FdLcD;11" halign="center" valign="center" />
-		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,14" font="FdLcD;14" halign="center" valign="center" />
+		<widget source="parent.Text" render="Label" position="top" size="*,95" font="FdLcD;31" halign="center" valign="center" />
+		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,44" font="FdLcD;44" halign="center" valign="center" />
 	</screen>
 </skin>
--- enigma2.org/lib/base/httpstream.cpp
+++ enigma2/lib/base/httpstream.cpp
@@ -1,4 +1,8 @@
 #include <cstdio>
+
+#if not defined ENABLE_MEDIAFWGSTREAMER
+#include <openssl/evp.h>
+#endif
 
 #include <lib/base/httpstream.h>
 #include <lib/base/eerror.h>
@@ -76,8 +77,28 @@
 	int authenticationindex = hostname.find("@");
 	if (authenticationindex > 0)
 	{
+#if defined ENABLE_MEDIAFWGSTREAMER
 		authorizationData =  base64encode(hostname.substr(0, authenticationindex));
+#else
+		BIO *mbio, *b64bio, *bio;
+		char *p = (char*)NULL;
+		int length = 0;
+		authorizationData = hostname.substr(0, authenticationindex);
 		hostname = hostname.substr(authenticationindex + 1);
+		mbio = BIO_new(BIO_s_mem());
+		b64bio = BIO_new(BIO_f_base64());
+		bio = BIO_push(b64bio, mbio);
+		BIO_write(bio, authorizationData.c_str(), authorizationData.length());
+		BIO_flush(bio);
+		length = BIO_ctrl(mbio, BIO_CTRL_INFO, 0, (char*)&p);
+		authorizationData = "";
+		if (p && length > 0)
+		{
+			/* base64 output contains a linefeed, which we ignore */
+			authorizationData.append(p, length - 1);
+		}
+		BIO_free_all(bio);
+#endif
 	}
 	int customportindex = hostname.find(":");
 	if (customportindex > 0)
--- enigma2.org/lib/base/ioprio.cpp
+++ enigma2/lib/base/ioprio.cpp
@@ -28,6 +28,9 @@
 #elif defined(__mips__)
 #define __NR_ioprio_set		4284
 #define __NR_ioprio_get		4285
+#elif defined(__sh__) // the correct values for our kernel
+#define __NR_ioprio_set		288
+#define __NR_ioprio_get		289
 #else
 #error "Unsupported arch"
 #endif
--- enigma2.org/lib/base/Makefile.inc
+++ enigma2/lib/base/Makefile.inc
@@ -41,7 +41,7 @@
 	base/encoding.h \
 	base/eptrlist.h \
 	base/estring.h \
-	base/freesatv2.cpp \
+	base/freesatv2.h \
 	base/i18n.h \
 	base/itssource.h \
 	base/init.h \
--- enigma2.org/lib/base/smartptr.h
+++ enigma2/lib/base/smartptr.h
@@ -4,6 +4,8 @@
 #include "object.h"
 #include <lib/python/swig.h>
 
+inline void ptrAssert(void *p) { if (!p) *(unsigned long*)0=0; }
+
 template<class T>
 class ePtr
 {
@@ -56,10 +58,10 @@
 	}
 #ifndef SWIG
 	T* grabRef() { if (!ptr) return 0; ptr->AddRef(); return ptr; }
-	T* &ptrref() { return ptr; }
+	T* &ptrref() { ASSERT(!ptr); return ptr; }
 	operator bool() const { return !!this->ptr; }
 #endif
-	T* operator->() const { return ptr; }
+	T* operator->() const { ptrAssert(ptr); return ptr; }
 	operator T*() const { return this->ptr; }
 };
 
@@ -131,9 +133,9 @@
 	}
 #ifndef SWIG
 	T* grabRef() { if (!ptr) return 0; ptr->AddRef(); ptr->AddUse(); return ptr; }
-	T* &ptrref() { return ptr; }
+	T* &ptrref() { ASSERT(!ptr); return ptr; }
 #endif
-	T* operator->() const { return ptr; }
+	T* operator->() const { ptrAssert(ptr); return ptr; }
 	operator T*() const { return this->ptr; }
 };
 
@@ -176,12 +178,12 @@
 		ePtr<T>::operator=(c);
 		return *this;
 	}
-	ePtrHelper<T> operator->() { return ePtrHelper<T>(ptr); }
+	ePtrHelper<T> operator->() { ptrAssert(ptr); return ePtrHelper<T>(ptr); }
 			/* for const objects, we don't need the helper, as they can't */
 			/* be changed outside the program flow. at least this is */
 			/* what the compiler assumes, so in case you're using const */
 			/* eMutablePtrs note that they have to be const. */
-	const T* operator->() const { return ptr; }
+	const T* operator->() const { ptrAssert(ptr); return ptr; }
 };
 #endif
 
--- enigma2.org/lib/base/wrappers.cpp
+++ enigma2/lib/base/wrappers.cpp
@@ -4,8 +4,9 @@
 #include <sys/select.h>
 #include <arpa/inet.h>
 #include <netdb.h>
-#include <glib.h>
-
+#if defined ENABLE_MEDIAFWGSTREAMER
+#include <glib.h>
+#endif
 #include <vector>
 #include <string>
 
@@ -261,6 +262,7 @@
 	return handledcount;
 }
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 std::string base64encode(const std::string str)
 {
 	if(str.empty())
@@ -303,3 +305,4 @@
 
 	return ret;
 }
+#endif
--- enigma2.org/lib/base/wrappers.h
+++ enigma2/lib/base/wrappers.h
@@ -7,7 +7,8 @@
 ssize_t writeAll(int fd, const void *buf, size_t count);
 int Select(int maxfd, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
 int Connect(const char *hostname, int port, int timeoutsec);
+#if defined ENABLE_MEDIAFWGSTREAMER
 std::string base64encode(const std::string str);
 std::string base64decode(const std::string hash);
-
 #endif
+#endif
--- enigma2.org/lib/driver/Makefile.inc
+++ enigma2/lib/driver/Makefile.inc
@@ -9,7 +9,8 @@
 	driver/rc.cpp \
 	driver/rcinput.cpp \
 	driver/rfmod.cpp \
-	driver/hdmi_cec.cpp
+	driver/hdmi_cec.cpp \
+	driver/vfd.cpp
 
 driverincludedir = $(pkgincludedir)/lib/driver
 driverinclude_HEADERS = \
@@ -24,7 +25,8 @@
 	driver/rcinput.h \
 	driver/rcinput_swig.h \
 	driver/rfmod.h \
-	driver/hdmi_cec.h
+	driver/hdmi_cec.h \
+	driver/vfd.h
 
 if HAVE_LIBSDL
 driver_libenigma_driver_a_SOURCES += \
--- enigma2.org/lib/driver/rc.cpp
+++ enigma2/lib/driver/rc.cpp
@@ -165,6 +165,9 @@
 #ifdef VUPLUS_RC_WORKAROUND
 	return(false);
 #else
+	if (getDeviceName().find("RC") != std::string::npos)
+		return false;
+
 	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
 	return hasCap(keyCaps, KEY_A);
 #endif
--- enigma2.org/lib/driver/vfd.cpp
+++ enigma2/lib/driver/vfd.cpp
@@ -0,0 +1,808 @@
+/*
+ * vfd.cpp
+ *
+ * (c) 20?? ?
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ ****************************************************************************
+ *
+ * VFD/LED driver for enigma2.
+ *
+ ****************************************************************************
+ *
+ * Changes
+ *
+ * Date     By              Description
+ * --------------------------------------------------------------------------
+ * 20130905 Audioniek       Code for Sparks added in.
+ * 20130905 Audioniek       vfd_write_string_scrollText now uses actual
+ *                          display length in stead of always 16.
+ * 20131021 Audioniek       Octagon 1008 (Fortis HS9510) added.
+ * 20131130 Audioniek       HDBOX (Fortis FS9000/9200) added
+ * 20131210 Audioniek       Sign on string now scrolls once if longer than
+ *                          displaylength.
+ * 20140221 Audioniek       Fortis HS7119 and HS7819 added.
+ * 20140527 Audioniek       Spark7162 spins circle on init.
+ * 20150316 Audioniek       Spark7162 circle spin on init removed.
+ * 20160101 Audioniek       Fortis HS7420 and HS7429 added.
+ * 20170313 Audioniek       Kathrein UFS910/912 added.
+ *
+ ****************************************************************************/
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include <pthread.h>
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#ifdef PLATFORM_TF7700
+#include "../../../apps/tools/tffpctl/frontpanel.h"
+#endif
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDDISPLAYCHARS       0xc0425a00
+#define VFDBRIGHTNESS         0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF  0xc0425a05
+#define VFDICONDISPLAYONOFF   0xc0425a0a
+#define VFDSETFAN             0xc0425af8
+#define VFDSETLED             0xc0425afe
+
+bool startloop_running = false;
+static bool icon_onoff[45];
+//static bool icon_onoff[LAST_ICON];
+static int led_onoff[7];
+//static int led_onoff[LAST_LED];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked    = false;
+bool requested  = false;
+bool VFD_CENTER = false;
+int VFD_SCROLL  = 1;  // 1=scroll once
+bool scoll_loop = false;
+
+char chars[64];
+char g_str[64];
+
+struct vfd_ioctl_data
+{
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+#if defined PLATFORM_TF7700
+	#define MAX_CHARS 8
+	#define VFDLENGTH 8
+#elif defined (PLATFORM_HS7810A) \
+   || defined (PLATFORM_HS7819) \
+   || defined (PLATFORM_HS7119) \
+   || defined (PLATFORM_SPARK)
+	#define VFDLENGTH 4
+#elif defined (PLATFORM_OCTAGON1008) \
+   || defined(PLATFORM_HS7420) \
+   || defined(PLATFORM_HS7429) \
+   || defined (PLATFORM_SPARK7162)
+	#define VFDLENGTH 8
+#elif defined (PLATFORM_FORTIS_HDBOX) \
+   || defined (PLATFORM_ATEVIO7500)
+	#define VFDLENGTH 12
+#else
+	#define VFDLENGTH 16
+#endif
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	memset ( chars, ' ', 63 );
+#if defined(PLATFORM_SPARK)
+	vfd_type = 4;
+#elif defined(PLATFORM_ATEVIO7500)
+	vfd_type = 5;
+#elif defined(PLATFORM_FORTIS_HDBOX)
+	vfd_type = 6;
+#elif defined(PLATFORM_OCTAGON1008)
+	vfd_type = 7;
+#elif defined(PLATFORM_SPARK7162)
+	vfd_type = 8;
+#elif defined(PLATFORM_HS7810A) || defined(PLATFORM_HS7819) || defined(PLATFORM_HS7119)
+	vfd_type = 9;
+#elif defined(PLATFORM_HS7110)
+	vfd_type = 10;
+#elif defined(PLATFORM_HS7420) || defined(PLATFORM_HS7429)
+	vfd_type = 11;
+#elif defined(PLATFORM_UFS912) || defined(PLATFORM_UFS913)
+	vfd_type = 12;
+#else
+	vfd_type = -1;
+#endif
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+#ifdef PLATFORM_TF7700
+
+char * getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if (fd < 0)
+	{
+		return 0;
+	}
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if (n < 0)
+	{
+		n = 0;
+	}
+	else if((n > 1) && (progress[n-1] == 0xa))
+	{
+		n--;
+	}
+	progress[n] = 0;
+	return progress;
+}
+
+void * start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+//	char spc[10];
+
+	if ((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("Failed opening devices (%d, %d, %d)\n", fplarge, fpsmall, fpc);
+		return NULL;
+	}
+	blocked = true;
+
+	// set scroll mode
+	//frontpanel_ioctl_scrollmode scrollMode = {2, 10, 15};
+	//ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+
+	// display string
+	char str[] = "        TOPFIELD TF77X0 ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = {0, 0, 0xf};
+
+	// start the display loop
+	char * progress = getProgress();
+	int index = 2;
+	while (!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if (index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for (i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if ((index % 4) == 0)
+		{
+			// display progress
+			progress = getProgress();
+//			if (strlen(progress) == 1)
+//			{
+//				spc = "  ";
+//			}
+//			if (strlen(progress) == 2)
+//			{
+//				spc = " ";
+//			}
+//			strcat(spc, progress);
+			write(fpsmall, progress, strlen(progress) + 1);
+			if (strncmp("100", progress, 3) == 0)
+			{
+				break;
+			}
+		}
+	}
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = {0xffffffff, 0xffffffff, 0x0};
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+#else  //next code for boxes other than Topfield TF7700HDPVR
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	#if defined PLATFORM_SPARK7162
+		char str[] = "SPARK7162 ENIGMA2";
+	#elif defined PLATFORM_SPARK
+		char str[] = "SPARK ENIGMA2";
+	#elif defined PLATFORM_FORTIS_HDBOX
+		char str[] = "FS9000/9200 Enigma2";
+	#elif defined PLATFORM_OCTAGON1008
+		char str[] = "HS9510 Enigma2";
+	#elif defined PLATFORM_ATEVIO7500
+		char str[] = "HS8200 Enigma2";
+	#elif defined PLATFORM_HS7119
+		char str[] = "7119 Enigma2";
+	#elif defined PLATFORM_HS7420
+		char str[] = "HS7420 Enigma2";
+	#elif defined PLATFORM_HS7810A
+		char str[] = "7810 Enigma2";
+	#elif defined PLATFORM_HS7429
+		char str[] = "HS7429 Enigma2";
+	#elif defined PLATFORM_HS7819
+		char str[] = "7819 Enigma2";
+	#elif defined PLATFORM_UFS910
+		char str[] = "UFS910 Enigma2";
+	#elif defined PLATFORM_UFS912
+		char str[] = "UFS912 Enigma2";
+	#elif defined PLATFORM_UFS913
+		char str[] = "UFS913 Enigma2";
+	#else
+		char str[] = "SH4 Git Enigma2";
+	#endif
+	int vfddev = open ("/dev/vfd", O_WRONLY);
+	write(vfddev, str, strlen(str));
+	close(vfddev);
+
+	/*these boxes can control display brightness*/
+	#if !defined(PLATFORM_FORTIS_HDBOX) \
+	 && !defined(PLATFORM_OCTAGON1008) \
+	 && !defined(PLATFORM_ATEVIO7500) \
+	 && !defined(PLATFORM_CUBEREVO) \
+	 && !defined(PLATFORM_CUBEREVO_MINI) \
+	 && !defined(PLATFORM_CUBEREVO_MINI2) \
+	 && !defined(PLATFORM_CUBEREVO_MINI_FTA) \
+	 && !defined(PLATFORM_CUBEREVO_250HD) \
+	 && !defined(PLATFORM_CUBEREVO_2000HD) \
+	 && !defined(PLATFORM_CUBEREVO_9500HD) \
+	 && !defined(PLATFORM_SPARK7162) \
+	 && !defined PLATFORM_UFS912 \
+	 && !defined PLATFORM_UFS913 \
+	 && !defined(PLATFORM_HS7119) \
+	 && !defined(PLATFORM_HS7420) \
+	 && !defined(PLATFORM_HS7429) \
+	 && !defined(PLATFORM_HS7810A) \
+	 && !defined(PLATFORM_HS7819)
+	/* Others cycle their icons */
+	for (int vloop = 0; vloop < 128; vloop++)
+	{
+		if (vloop%2 == 1)
+		{
+			vfd.vfd_set_icon((((vloop%32)/2)%16), ICON_OFF, true);
+			usleep(2000);
+			vfd.vfd_set_icon(((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+	}
+	#else //modulate brightness 3 times
+	for (int vloop = 0; vloop < 3 * 14; vloop++)
+	{
+		if (vloop%14 == 0)
+		{
+			vfd.vfd_set_brightness(6);
+		}
+		else if (vloop%14 == 1)
+		{
+			vfd.vfd_set_brightness(5);
+		}
+		else if (vloop%14 == 2)
+		{
+			vfd.vfd_set_brightness(4);
+		}
+		else if (vloop%14 == 3)
+		{
+			vfd.vfd_set_brightness(3);
+		}
+		else if (vloop%14 == 4)
+		{
+			vfd.vfd_set_brightness(2);
+		}
+		else if (vloop%14 == 5)
+		{
+			vfd.vfd_set_brightness(1);
+		}
+		else if (vloop%14 == 6)
+		{
+			vfd.vfd_set_brightness(0);
+		}
+		else if (vloop%14 == 7)
+		{
+			vfd.vfd_set_brightness(1);
+		}
+		else if (vloop%14 == 8)
+		{
+			vfd.vfd_set_brightness(2);
+		}
+		else if (vloop%14 == 9)
+		{
+			vfd.vfd_set_brightness(3);
+		}
+		else if (vloop%14 == 10)
+		{
+			vfd.vfd_set_brightness(4);
+		}
+		else if (vloop%14 == 11)
+		{
+			vfd.vfd_set_brightness(5);
+		}
+		else if (vloop%14 == 12)
+		{
+			vfd.vfd_set_brightness(6);
+		}
+		else if (vloop%14 == 13)
+		{
+			vfd.vfd_set_brightness(7);
+		}
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7); // set final brightness
+	#endif
+	vfd.vfd_clear_icons();
+	#if !defined(PLATFORM_FORTIS_HDBOX) \
+	 && !defined(PLATFORM_OCTAGON1008) \
+	 && !defined(PLATFORM_ATEVIO7500) \
+	 && !defined(PLATFORM_CUBEREVO) \
+	 && !defined(PLATFORM_CUBEREVO_MINI) \
+	 && !defined(PLATFORM_CUBEREVO_MINI2) \
+	 && !defined(PLATFORM_CUBEREVO_MINI_FTA) \
+	 && !defined(PLATFORM_CUBEREVO_250HD) \
+	 && !defined(PLATFORM_CUBEREVO_2000HD) \
+	 && !defined(PLATFORM_CUBEREVO_9500HD) \
+	 && !defined(PLATFORM_SPARK7162)
+	//set all blocked icons
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd.vfd_set_icon(id, icon_onoff[id]);
+	}
+#endif
+	blocked = false;
+	return NULL;
+}
+#endif
+
+#if defined(PLATFORM_FORTIS_HDBOX) \
+ || defined(PLATFORM_OCTAGON1008) \
+ || defined(PLATFORM_ATEVIO7500) \
+ || defined(PLATFORM_CUBEREVO) \
+ || defined(PLATFORM_CUBEREVO_MINI) \
+ || defined(PLATFORM_CUBEREVO_MINI2) \
+ || defined(PLATFORM_CUBEREVO_MINI_FTA) \
+ || defined(PLATFORM_CUBEREVO_250HD) \
+ || defined(PLATFORM_CUBEREVO_2000HD) \
+ || defined(PLATFORM_CUBEREVO_9500HD) \
+ || defined(PLATFORM_SPARK) \
+ || defined(PLATFORM_SPARK7162) \
+ || defined(PLATFORM_HS7420) \
+ || defined(PLATFORM_HS7429) \
+ || defined(PLATFORM_HS7119) \
+ || defined(PLATFORM_HS7810A) \
+ || defined(PLATFORM_HS7819)
+void evfd::vfd_write_string_scrollText(char* text)
+{
+	return;
+}
+
+// We cannot use a member function (vfd_write_string_scrollText) in pthread,
+// so we use a second (same content) non member function (vfd_write_string_scrollText1)
+static void *vfd_write_string_scrollText1(void *arg)
+{
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	bool scoll_loop = true;
+	char out[VFDLENGTH+1];
+	int i, len;
+	evfd vfd;
+	len = strlen((char *) g_str);
+	memset(out, ' ', VFDLENGTH+1);
+	while (scoll_loop && (len > VFDLENGTH))
+	{
+		if (blocked)
+		{
+			usleep(750000); //0.75s pause between scroll loops?
+		}
+		else
+		{
+			scoll_loop = false;
+		}
+		for (i = 0; i <= (len-VFDLENGTH); i++) //scroll part 1: write full string scrolling and wait 0.75s between scrolls
+		{
+			if (blocked)
+			{
+				memset(out, ' ', VFDLENGTH); //fill buffer with spaces
+				memcpy(out, g_str+i, VFDLENGTH); ///then put string in
+				vfd.vfd_write_string(out, true);  //print string on VFD
+				usleep(750000); //0.75 sec character delay
+			}
+			else
+			{
+				scoll_loop = false;
+				i = len-VFDLENGTH;
+			}
+		}
+		for (i = 1; i <= VFDLENGTH; i++) //scroll part 2: write full string shifted 1 character scrolling and wait 0.75s between scrolls
+		{
+			if (blocked)
+			{
+				memset(out, ' ', VFDLENGTH); //fill buffer with spaces
+				memcpy(out, g_str+len+i-VFDLENGTH, VFDLENGTH-i); // copy string shifted 1 character
+				vfd.vfd_write_string(out, true);
+				usleep(750000); //0.75 sec character delay
+			}
+			else
+			{
+				scoll_loop = false;
+				i = VFDLENGTH;
+			}
+		}
+		memcpy(out, g_str, VFDLENGTH);
+		vfd.vfd_write_string(out, true); //final display: write 1st VFDLENGTH characters
+		if (VFD_SCROLL != 2 || !blocked)
+		{
+			scoll_loop = false;
+		}
+		else
+		{
+			sleep(1); //1 sec delay between loops
+		}
+	}
+	blocked = false;
+	return NULL;
+}
+
+void evfd::vfd_write_string(char * str)
+{
+	int i = strlen(str);
+	if (i > 63)
+	{
+		i = 63;
+	}
+	if (blocked)
+	{
+		pthread_cancel(thread_start_loop);
+		pthread_join(thread_start_loop, NULL);
+		blocked = false;
+	}
+	memset(g_str, ' ', 64); //clear scroll buffer
+	strcpy(g_str, str); //and set display string in it
+	vfd_write_string(str, false); //initial display: 1st VFDLENGTH characters
+	if (i > VFDLENGTH && VFD_SCROLL) //if string longer than display and scroll mode
+	{
+		blocked = true;
+		pthread_create(&thread_start_loop, NULL, vfd_write_string_scrollText1, (void *)str);
+		pthread_detach(thread_start_loop);
+	}
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int ws = 0;
+	int i = strlen(str);
+	if (VFD_CENTER == true)
+	{
+		if (i < VFDLENGTH)
+			ws=(VFDLENGTH-i)/2;
+		else
+			ws = 0;
+	}
+
+	if (i > VFDLENGTH)
+	{
+		i = VFDLENGTH;
+	}
+
+	struct vfd_ioctl_data data;
+	memset(data.data, ' ', VFDLENGTH);
+	if (VFD_CENTER == true)
+	{
+		memcpy(data.data+ws, str, VFDLENGTH-ws);
+	}
+	else
+	{
+		memcpy(data.data, str, i);
+	}
+	data.start = 0;
+	if (VFD_CENTER == true)
+	{
+		data.length = i+ws<=VFDLENGTH?i+ws:VFDLENGTH;
+	}
+	else
+	{
+		data.length = i;
+	}
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	write(file_vfd,data.data,data.length);
+	close (file_vfd);
+	return;
+}
+
+#else
+
+void evfd::vfd_write_string(char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int i = strlen(str);
+	if (i > 63)
+	{
+		i = 63;
+	}
+	memset (chars, ' ', 63);
+	memcpy (chars, str, i);
+#ifdef PLATFORM_TF7700
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked)
+	{
+		usleep(200000);
+	}
+#else
+	if (!blocked || force)
+#endif
+	{
+		struct vfd_ioctl_data data;
+		memset (data.data, ' ', 63);
+		memcpy (data.data, str, i);
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl (file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_write_string_scrollText(char* text)
+{
+	if (!blocked)
+	{
+		int i, len = strlen(text);
+		char* out = (char *) malloc(63);
+		for (i = 0; i <= (len-63); i++)
+		{ // scroll text until end
+			memset(out, ' ', 63);
+			memcpy(out, text+i, 63);
+			vfd_write_string(out);
+			usleep(750000);
+		}
+		for (i = 1; i < 63; i++)
+		{ // scroll text with whitespaces from right
+			memset(out, ' ', 63);
+			memcpy(out, text+len+i-63, 63-i);
+			vfd_write_string(out);
+			usleep(750000);
+		}
+		memcpy(out, text, VFDLENGTH); //final: display first VFDLENGTH chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+	return;
+}
+#endif
+
+void evfd::vfd_clear_string()
+{
+	char out[VFDLENGTH + 1];
+	memset(out, 0, VFDLENGTH + 1);
+	memset(out, ' ', VFDLENGTH);
+	vfd_write_string(out, true);
+	return;
+}
+
+void evfd::vfd_set_icon(int id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+	return;
+}
+
+void evfd::vfd_set_icon(int id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+	if (!blocked || force)
+	{
+		struct vfd_ioctl_data data;
+		if (!startloop_running)
+		{
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+			data.data[0] = id;
+			data.data[4] = onoff;
+			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_set_led(tvfd_led id, int onoff)
+{
+	led_onoff[id] = onoff;
+	struct vfd_ioctl_data data;
+	if (!startloop_running)
+	{
+		memset(&data, 0, sizeof(struct vfd_ioctl_data));
+		data.start = 0x00;
+		data.data[0] = id;
+		data.data[4] = onoff;
+		data.length = 5;
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl(file_vfd, VFDSETLED, &data);
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_clear_icons()
+{
+	int id;
+
+	#if defined PLATFORM_SPARK7162
+		for (id = 1; id < 46; id++)
+	#elif defined FORTIS_HDBOX
+		for (id = 1; id < 40; id++)
+	#elif defined OCTAGON1008
+		for (id = 1; id < 29; id++)
+	#elif defined PLATFORM_ATEVIO7500
+		for (id = 1; id < 23; id++);
+	#elif defined PLATFORM_UFS912 || defined PLATFORM_UFS913
+		for (id = 1; id < 16; id++)
+	#else
+		for (id = 0x10; id < 0x20; id++)
+	#endif
+	{
+		vfd_set_icon(id, false);
+	}
+	return;
+}
+
+void evfd::vfd_set_brightness(unsigned int setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open(VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDBRIGHTNESS, &data);
+	close(file_vfd);
+
+	return;
+}
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
+
+void evfd::vfd_set_fan(bool onoff)
+{
+#if defined(PLATFORM_CUBEREVO) \
+ || defined(PLATFORM_CUBEREVO_MINI) \
+ || defined(PLATFORM_CUBEREVO_MINI2) \
+ || defined(PLATFORM_CUBEREVO_MINI_FTA) \
+ || defined(PLATFORM_CUBEREVO_250HD) \
+ || defined(PLATFORM_CUBEREVO_2000HD) \
+ || defined(PLATFORM_CUBEREVO_9500HD)
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDSETFAN, &data);
+
+	close (file_vfd);
+#endif
+	return;
+}
+
+void evfd::vfd_set_SCROLL(int id)
+{
+	if (id > 2)  //if more than 2, set 2 (scroll continously)
+	{
+		id = 2;
+	}
+	if (id < 0) //if less than zero, set zero (no scroll)
+	{
+		id = 0;
+	}
+	VFD_SCROLL = id;
+}
+
+void evfd::vfd_set_CENTER(bool id)
+{
+	VFD_CENTER = id;
+}
--- enigma2.org/lib/driver/vfd.h
+++ enigma2/lib/driver/vfd.h
@@ -0,0 +1,54 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+/* Note: C++ handles the #if, #elif, #else and #endif well, but swig does not, always picking the first set.
+   Do not use them here, making this file box dependent... */
+#if !defined(PLATFORM_HDBOX)
+typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+typedef enum { RED_LED = 0, GREEN_LED } tvfd_led;
+#else
+typedef enum { USB = 0x10, STANDBY, SAT, REC, TIMESHIFT, TIMER, HD, LOCK, DD, MUTE, TUNER1, TUNER2, MP3, REPEAT,
+			    PLAY, PAUSE, TER, FILE, 480i, 480p, 576i, 576p, 720p, 1080i, 1080p } tvfd_icon;
+typedef enum { RED_LED = 0, BLUE_LED, CROSS_UP, CROSS_LEFT, CROSS_RIGHT, CROSS_DOWN } tvfd_led;
+#endif
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+	int vfd_type;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	int getVfdType() { return vfd_type; }
+	void vfd_set_SCROLL(int id);
+	void vfd_set_CENTER(bool id);
+	void vfd_set_icon(int id, bool onoff);
+	void vfd_set_icon(int id, bool onoff, bool force);
+	void vfd_set_led(tvfd_led id, int onoff);
+	void vfd_clear_icons();
+
+	void vfd_write_string(char * string);
+	void vfd_write_string(char * str, bool force);
+	void vfd_write_string_scrollText(char* text);
+	void vfd_clear_string();
+
+	void vfd_set_brightness(unsigned int setting);
+	void vfd_set_light(bool onoff);
+	void vfd_set_fan(bool onoff);
+};
+
+#endif
--- enigma2.org/lib/dvb/decoder.cpp
+++ enigma2/lib/dvb/decoder.cpp
@@ -76,14 +76,19 @@
 			pes.pes_type = DMX_PES_AUDIO3;
 			break;
 		}
+#if defined(__sh__) // increases zapping speed
+		pes.flags    = DMX_IMMEDIATE_START;
+#else
 		pes.flags    = 0;
-		eDebugNoNewLineStart("[eDVBAudio%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
+#endif
+//		eDebugNoNewLineStart("[eDVBAudio%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
 			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
+#if not defined(__sh__) // already started because of DMX_IMMEDIATE_START
 		eDebugNoNewLineStart("[eDVBAudio%d] DEMUX_START ", m_dev);
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
@@ -91,6 +96,7 @@
 			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
+#endif
 	}
 
 	if (m_fd >= 0)
@@ -134,7 +140,9 @@
 			eDebugNoNewLine("failed: %m\n");
 		else
 			eDebugNoNewLine("ok\n");
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 		eDebugNoNewLineStart("[eDVBAudio%d] AUDIO_PLAY ", m_dev);
 		if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 			eDebugNoNewLine("failed: %m\n");
@@ -370,7 +378,11 @@
 			pes.pes_type = DMX_PES_VIDEO3;
 			break;
 		}
+#if defined(__sh__) // increases zapping speed
+		pes.flags    = DMX_IMMEDIATE_START;
+#else
 		pes.flags    = 0;
+#endif
 		eDebugNoNewLineStart("[eDVBVideo%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
@@ -378,6 +390,7 @@
 			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
+#if not defined(__sh__) // already started because of DMX_IMMEDIATE_START
 		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_START ", m_dev);
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
@@ -385,11 +398,14 @@
 			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
+#endif
 	}
 
 	if (m_fd >= 0)
 	{
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_PLAY ", m_dev);
 		if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 			eDebugNoNewLine("failed: %m\n");
@@ -677,7 +693,11 @@
 		pes.pes_type = DMX_PES_PCR3;
 		break;
 	}
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLineStart("[eDVBPCR%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -685,6 +705,7 @@
 		return -errno;
 	}
 	eDebugNoNewLine("ok\n");
+#if not defined(__sh__) // already started because of DMX_IMMEDIATE_START
 	eDebugNoNewLineStart("[eDVBPCR%d] DEMUX_START ", m_dev);
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -692,6 +713,7 @@
 		return -errno;
 	}
 	eDebugNoNewLine("ok\n");
+#endif
 	return 0;
 }
 
@@ -747,7 +769,11 @@
 		pes.pes_type = DMX_PES_TELETEXT3;
 		break;
 	}
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLineStart("[eDVBText%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -756,6 +782,7 @@
 		return -errno;
 	}
 	eDebugNoNewLine("ok\n");
+#if not defined(__sh__) // already started because of DMX_IMMEDIATE_START
 	eDebugNoNewLineStart("[eDVBText%d] DEMUX_START ", m_dev);
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -763,6 +790,7 @@
 		return -errno;
 	}
 	eDebugNoNewLine("ok\n");
+#endif
 	return 0;
 }
 
@@ -899,12 +927,28 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) // see comment below
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__)
+// the VIDEO_CONTINUE would reset the FASTFORWARD  command so we
+// execute the FASTFORWARD after the VIDEO_CONTINUE
+			if (s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1205,6 +1249,10 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__) // our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)
+				finishShowSinglePic();
+#endif
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1225,8 +1273,10 @@
 
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
 					eDebug("[eTSMPEGDecoder] VIDEO_SELECT_SOURCE MEMORY failed: %m");
+#if not defined(__sh__)
 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 					eDebug("[eTSMPEGDecoder] VIDEO_SET_STREAMTYPE failed: %m");
+#endif
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
 					eDebug("[eTSMPEGDecoder] VIDEO_PLAY failed: %m");
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
@@ -1243,7 +1293,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				writeAll(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__)
 				m_showSinglePicTimer->start(150, true);
+#endif
 			}
 			close(f);
 		}
--- enigma2.org/lib/dvb/dvb.cpp
+++ enigma2/lib/dvb/dvb.cpp
@@ -311,19 +311,6 @@
 		frontend = -1;
 		goto error;
 	}
-
-	struct dtv_properties props;
-	struct dtv_property prop[1];
-
-	prop[0].cmd = DTV_ENUM_DELSYS;
-	memset(prop[0].u.buffer.data, 0, sizeof(prop[0].u.buffer.data));
-	prop[0].u.buffer.len = 0;
-	props.num = 1;
-	props.props = prop;
-
-	if (ioctl(frontend, FE_GET_PROPERTY, &props) < 0)
-		eDebug("[eDVBUsbAdapter] FE_GET_PROPERTY DTV_ENUM_DELSYS failed %m");
-
 	::close(frontend);
 	frontend = -1;
 
@@ -411,9 +398,6 @@
 #define VTUNER_SET_ADAPTER 33
 	ioctl(vtunerFd, VTUNER_SET_NAME, name);
 	ioctl(vtunerFd, VTUNER_SET_TYPE, type);
-	ioctl(vtunerFd, VTUNER_SET_FE_INFO, &fe_info);
-	if (prop[0].u.buffer.len > 0)
-		ioctl(vtunerFd, VTUNER_SET_DELSYS, prop[0].u.buffer.data);
 	ioctl(vtunerFd, VTUNER_SET_HAS_OUTPUTS, "no");
 	ioctl(vtunerFd, VTUNER_SET_ADAPTER, nr);
 
@@ -949,12 +933,13 @@
 	if (i == m_demux.end())
 		return -1;
 
-	iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin();
-	int fesource = fe ? fe->m_frontend->getDVBID() : -1;
+//	iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin();
+//	int fesource = fe ? fe->m_frontend->getDVBID() : -1;
 	ePtr<eDVBRegisteredDemux> unused;
 	uint8_t d, a;
 
-#ifdef HAVE_AMLOGIC
+#if not defined(__sh__)
+//#ifdef HAVE_AMLOGIC
 	// find first unused demux which is on same adapter as frontend
 	while (i != m_demux.end())
 	{
@@ -982,52 +967,49 @@
 		}
 		i++;
 	}
-#else
-	/*
-	 * For pvr playback, start with the last demux.
-	 * On some hardware, there are less ca devices than demuxes, so try to leave
-	 * the first demuxes for live tv, and start with the last for pvr playback
-	 */
-	bool use_decode_demux = (fe || (cap & iDVBChannel::capDecode));
-
-	if (!use_decode_demux)
-	{
-		i = m_demux.end();
-		--i;
-	}
-
-	while (i != m_demux.end())
-	{
-		if (i->m_adapter == adapter)
+#else // we use our own algo for demux detection
+	int n = 0;
+	for (; i != m_demux.end(); ++i, ++n)
+	{
+		if(fe)
 		{
 			if (!i->m_inuse)
 			{
-				// mark the first unused demux and use that when no better match is found
 				if (!unused)
+				{
+					// take the first unused
+					//eDebug("\nallocate demux b = %d\n",n);
 					unused = i;
-			}
-			else
-			{
-				// demux is in use, see if it can be shared
-				if (fesource >= 0 && i->m_demux->getSource() == fesource)
-				{
-					i->m_demux->getCAAdapterID(a);
-					i->m_demux->getCADemuxID(d);
-					eDebug("[eDVBResourceManager] allocating shared demux adapter=%d, demux=%d, source=%d", a, d, i->m_demux->getSource());
-					demux = new eDVBAllocatedDemux(i);
-					return 0;
 				}
 			}
-		}
-		if (use_decode_demux)
-		{
-			++i;
-		}
-		else
-		{
-			if (i == m_demux.begin())
-				break;
-			--i;
+			else if (i->m_adapter == fe->m_adapter && i->m_demux->getSource() == fe->m_frontend->getDVBID())
+			{
+				// take the demux allocated to the same
+				// frontend,  just create a new reference
+				demux = new eDVBAllocatedDemux(i);
+				//eDebug("\nallocate demux b = %d\n",n);
+				return 0;
+			}
+		}
+		else if(n == ((int)m_demux.size() - 1))
+		{
+			// Always use the last demux for PVR
+			// it is assumed that the last demux is not
+			// attached to a frontend. That is, there
+			// should be one instance of dvr & demux
+			// devices more than of frontend devices.
+			// Otherwise, playback and timeshift might
+			// interfere recording.
+			if (i->m_inuse)
+			{
+				// just create a new reference
+				demux = new eDVBAllocatedDemux(i);
+				//eDebug("\nallocate demux c = %d\n",n);
+				return 0;
+			}
+			unused = i;
+			//eDebug("\nallocate demux d = %d\n", n);
+			break;
 		}
 	}
 #endif
@@ -1036,10 +1018,10 @@
 	{
 		unused->m_demux->getCAAdapterID(a);
 		unused->m_demux->getCADemuxID(d);
-		eDebug("[eDVBResourceManager] allocating demux adapter=%d, demux=%d, source=%d fesource=%d", a, d, unused->m_demux->getSource(), fesource);
-		demux = new eDVBAllocatedDemux(unused);
+		eDebug("[eDVBResourceManager] allocating demux adapter=%d, demux=%d, source=%d fesource=%d", a, d, unused->m_demux->getSource(), fe ? fe->m_frontend->getDVBID() : -1);
+			demux = new eDVBAllocatedDemux(unused);
 		if (fe)
-			demux->get().setSourceFrontend(fesource);
+			demux->get().setSourceFrontend(fe->m_frontend->getDVBID());
 		else
 			demux->get().setSourcePVR(0);
 		return 0;
@@ -1079,14 +1061,14 @@
 	if (!simulate && m_cached_channel)
 	{
 		eDVBChannel *cache_chan = (eDVBChannel*)&(*m_cached_channel);
-#ifndef HAVE_AMLOGIC
+//#ifndef HAVE_AMLOGIC
 		if(channelid==cache_chan->getChannelID())
 		{
 			eDebug("[eDVBResourceManager] use cached_channel");
 			channel = m_cached_channel;
 			return 0;
 		}
-#endif
+//#endif
 		m_cached_channel_state_changed_conn.disconnect();
 		m_cached_channel=0;
 		m_releaseCachedChannelTimer->stop();
@@ -2153,6 +2135,12 @@
 
 	if (m_pvr_fd_dst < 0)
 	{
+#if defined(__sh__) // our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -2168,6 +2156,7 @@
 			eDebug("[eDVBChannel] no demux allocated yet.. so its not possible to open the dvr device!!");
 			return -ENODEV;
 		}
+#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
--- enigma2.org/lib/dvb/dvb.h
+++ enigma2/lib/dvb/dvb.h
@@ -270,6 +270,9 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__) //see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
--- enigma2/lib/dvb/frontend.cpp
+++ enigma2.org/lib/dvb/frontend.cpp
@@ -16,6 +16,10 @@
 
 #ifndef I2C_SLAVE_FORCE
 #define I2C_SLAVE_FORCE	0x0706
+#endif
+
+#ifndef SYS_DVBC_ANNEX_A
+#define SYS_DVBC_ANNEX_A SYS_DVBC_ANNEX_AC
 #endif
 
 #define eDebugNoSimulate(x...) \
@@ -2924,10 +2928,10 @@
 		case SYS_ISDBT:		ss << " ISDBT"; break;
 		case SYS_UNDEFINED:	ss << " UNDEFINED"; break;
 		case SYS_DVBC_ANNEX_A:	ss << " DVBC_ANNEX_A"; break;
-		case SYS_DVBC_ANNEX_C:	ss << " DVBC_ANNEX_C"; break;
+//		case SYS_DVBC_ANNEX_C:	ss << " DVBC_ANNEX_C"; break;
 		case SYS_DVBT2:		ss << " DVBT2"; break;
-		case SYS_TURBO:		ss << " TURBO"; break;
-		case SYS_DTMB:		ss << " DTMB"; break;
+//		case SYS_TURBO:		ss << " TURBO"; break;
+//		case SYS_DTMB:		ss << " DTMB"; break;
 		}
 	}
 
--- enigma2.org/lib/dvb/epgcache.cpp
+++ enigma2/lib/dvb/epgcache.cpp
@@ -2155,6 +2155,45 @@
 {
 	int map;
 	iDVBSectionReader *reader = NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */
+	const __u8 *aligned_data;
+	bool isNotAligned = false;
+
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+
+	if (isNotAligned)
+	{
+		/* see HILO macro and eit.h */
+		int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+		/*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+		if ( EIT_SIZE >= len )
+			return;
+
+		aligned_data = (const __u8 *) malloc(len);
+
+		if ((unsigned int)aligned_data % 4 != 0)
+		{
+			eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+		}
+
+		/*eDebug("%p %p\n", aligned_data, data); */
+		memcpy((void *) aligned_data, (const __u8 *) data, len);
+		data = aligned_data;
+	}
+#endif
 	switch (source)
 	{
 		case NOWNEXT:
@@ -2279,6 +2318,10 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+		free((void *)aligned_data);
+#endif
 }
 
 #if ENABLE_FREESAT
--- enigma2.org/lib/base/filepush.cpp
+++ enigma2/lib/dvb/filepush.cpp
@@ -4,6 +4,15 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 
+#if defined(__sh__) // this allows filesystem tasks to be prioritised
+#include <sys/vfs.h>
+#define USBDEVICE_SUPER_MAGIC 0x9fa2
+#define EXT2_SUPER_MAGIC      0xEF53
+#define EXT3_SUPER_MAGIC      0xEF53
+#define SMB_SUPER_MAGIC       0x517B
+#define NFS_SUPER_MAGIC       0x6969
+#define MSDOS_SUPER_MAGIC     0x4d44 /* MD */
+#endif
 //#define SHOW_WRITE_TIME
 
 eFilePushThread::eFilePushThread(int blocksize, size_t buffersize):
@@ -55,11 +64,30 @@
 	size_t bytes_read = 0;
 	off_t current_span_offset = 0;
 	size_t current_span_remaining = 0;
+#if defined(__sh__)
+// opens video device for the reverse playback workaround
+// Changes in this file are cause e2 does not tell the player to play reverse
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+// Fix to ensure that event evtEOF is called at end of playbackl part 1/3
+	bool already_empty = false;
+#endif
 
 	while (!m_stop)
 	{
 		if (m_sg && !current_span_remaining)
 		{
+#if defined(__sh__) // tells the player to play in reverse
+#define VIDEO_DISCONTINUITY                   _IO('o', 84)
+#define DVB_DISCONTINUITY_SKIP                0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if ((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+//				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+//				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+			}
+#endif
 			m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining, m_blocksize);
 			ASSERT(!(current_span_remaining % m_blocksize));
 			m_current_position = current_span_offset;
@@ -126,7 +154,19 @@
 				{
 					case 0:
 						eDebug("[eFilePushThread] wait for driver eof timeout");
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 2/3
+						if (already_empty)
+						{
+							break;
+						}
+						else
+						{
+							already_empty = true;
+							continue;
+						}
+#else
 						continue;
+#endif
 					case 1:
 						eDebug("[eFilePushThread] wait for driver eof ok");
 						break;
@@ -189,12 +229,18 @@
 			}
 
 			eofcount = 0;
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 3/3
+			already_empty = false;
+#endif
 			m_current_position += buf_end;
 			bytes_read += buf_end;
 			if (m_sg)
 				current_span_remaining -= buf_end;
 		}
 	}
+#if defined(__sh__) // closes video device for the reverse playback workaround
+	close(fd_video);
+#endif
 	sendEvent(evtStopped);
 
 	{ /* mutex lock scope */
--- enigma2.org/lib/base/filepush.h
+++ enigma2/lib/dvb/filepush.h
@@ -13,6 +13,10 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size, int blocksize)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	virtual int getSkipMode() = 0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
--- enigma2.org/lib/dvb/pmt.cpp
+++ enigma2/lib/dvb/pmt.cpp
@@ -843,6 +843,11 @@
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
+		if (m_service_type == streamclient)
+		{
+			eDebug("force setServiceID(1)");
+			m_reference.setServiceID(1);
+		}
 		if (!ref.getServiceID().get() /* incorrect sid in meta file or recordings.epl*/ )
 		{
 			eDVBTSTools tstools;
--- enigma2.org/lib/dvb/streamserver.cpp
+++ enigma2/lib/dvb/streamserver.cpp
@@ -1,6 +1,9 @@
 #include <sys/select.h>
 #include <unistd.h>
 #include <string.h>
+#if not defined ENABLE_MEDIAFWGSTREAMER
+#include <openssl/evp.h>
+#endif
 #include <sys/types.h>
 #include <pwd.h>
 #include <shadow.h>
@@ -91,7 +94,28 @@
 				std::string hash = request.substr(pos + 21);
 				pos = hash.find('\r');
 				hash = hash.substr(0, pos);
+#if defined ENABLE_MEDIAFWGSTREAMER
 				authentication = base64decode(hash);
+#else
+				hash += "\n";
+				{
+					char *in, *out;
+					in = strdup(hash.c_str());
+					out = (char*)calloc(1, hash.size());
+					if (in && out)
+					{
+						BIO *b64, *bmem;
+						b64 = BIO_new(BIO_f_base64());
+						bmem = BIO_new_mem_buf(in, hash.size());
+						bmem = BIO_push(b64, bmem);
+						BIO_read(bmem, out, hash.size());
+						BIO_free_all(bmem);
+						authentication.append(out, hash.size());
+					}
+					free(in);
+					free(out);
+				}
+#endif
 				pos = authentication.find(':');
 				if (pos != std::string::npos)
 				{
--- enigma2.org/lib/dvb/streamserver.h
+++ enigma2/lib/dvb/streamserver.h
@@ -4,6 +4,8 @@
 #include <lib/network/serversocket.h>
 #include <lib/service/servicedvbstream.h>
 #include <lib/nav/core.h>
+
+#define TCP_USER_TIMEOUT        18  
 
 #ifndef SWIG
 class eStreamServer;
--- enigma2.org/lib/dvb/volume.cpp
+++ enigma2/lib/dvb/volume.cpp
@@ -45,7 +45,9 @@
 	openMixer();
 #endif
 	volumeUnMute();
+#if not defined(__sh__) // do not reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
--- enigma2.org/lib/dvb_ci/dvbci_appmgr.cpp
+++ enigma2/lib/dvb_ci/dvbci_appmgr.cpp
@@ -94,6 +94,9 @@
 	eDebug("[CI AM] in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+#endif
 	return 0;
 }
 
--- enigma2.org/lib/dvb_ci/dvbci.cpp
+++ enigma2/lib/dvb_ci/dvbci.cpp
@@ -25,6 +25,11 @@
 
 #include <dvbsi++/ca_program_map_section.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+//#define x_debug
+#endif
+
 //#define CIDEBUG 1
 
 #ifdef CIDEBUG
@@ -146,6 +151,232 @@
 
 #define CIPLUS_SERVER_SOCKET "/tmp/.listen.ciplus.socket"
 
+#ifdef __sh__
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+}
+
+/* from dvb-apps */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug
+	printf("%s: %p, %d\n", __func__, data, len);
+#endif
+
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+
+	/* should we send a data last ? */
+	if (data != NULL)
+	{
+		if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		{
+			memcpy(d, data, len);
+		}
+		else
+		{
+			//send data_last and data
+			memcpy(d + 5, data, len);
+			d[0] = getSlotID();
+			d[1] = connection_id;
+			d[2] = T_DATA_LAST;
+			if (len > 127)
+				d[3] = 4;	/* pointer to next length */
+			else
+				d[3] = len + 1;	/* len */
+			d[4] = connection_id; 	/* transport connection identifier*/
+			len += 5;
+		}
+	}
+	else
+	{
+		//send a data last only
+		d[0] = getSlotID();
+		d[1] = connection_id;
+		d[2] = T_DATA_LAST;
+		d[3] = len + 1;		/* len */
+		d[4] = connection_id;	/* transport connection identifier*/
+		len = 5;
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for (int i=0; i < len; i++)
+		printf("%02x ",d[i]);
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len);
+
+	free(d);
+	if (res < 0 || res != len)
+	{
+		printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+		return eDataError;
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+	//printf("%s:%s >\n", FILENAME, __FUNCTION__);
+	unsigned char* data = (unsigned char*) malloc(sizeof(char) * 5);
+	tx_time.tv_sec = 0;
+	data[0] = getSlotID();
+	data[1] = getSlotID() + 1; 	/* conid */
+	data[2] = T_CREATE_T_C;
+	data[3] = 1;
+	data[4] = getSlotID() + 1 	/*conid*/;
+	write(fd, data, 5);
+	//printf("%s:%s <\n", FILENAME, __FUNCTION__);
+	return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+	switch (tpdu_tag)
+	{
+		case T_C_T_C_REPLY:
+			printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+			tx_time.tv_sec = 0;
+
+			state = stateInserted;
+
+			//answer with data last (and if we have with data)
+			sendData(NULL, 0);
+
+			break;
+		case T_DELETE_T_C:
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+			printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+			break;
+		case T_D_T_C_REPLY:
+			printf("Got \"Delete Transport Connection Replay\" from module!\n");
+			break;
+		case T_REQUEST_T_C:
+			printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+			break;
+		case T_DATA_MORE:
+		{
+			int new_data_length = receivedLen + asn_data_length;
+			printf("Got \"Data More\" from Module\n");
+			__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+			receivedData = new_data_buffer;
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+			receivedLen = new_data_length;
+			tx_time.tv_sec = 0;
+			break;
+		}
+		case T_DATA_LAST:
+#ifdef x_debug
+			printf("Got \"Data Last\" from Module\n");
+#endif
+			tx_time.tv_sec = 0;
+			/* single package */
+			if (receivedData == NULL)
+			{
+				printf("->single package\n");
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < asn_data_length; i++)
+					printf("%02x ", data[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, data, asn_data_length);
+				eDVBCISession::pollAll();
+			}
+			else
+			{
+				/* chained package */
+				int new_data_length = receivedLen + asn_data_length;
+				printf("->chained data\n");
+				__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+				receivedData = new_data_buffer;
+				memcpy(receivedData + receivedLen, data, asn_data_length);
+				receivedLen = new_data_length;
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < receivedLen; i++)
+					printf("%02x ", receivedData[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, receivedData, receivedLen);
+				eDVBCISession::pollAll();
+//fixme: must also be moved in e2 behind the data processing ;)
+				free(receivedData);
+				receivedData = NULL;
+				receivedLen = 0;
+			}
+			break;
+		case T_SB:
+		{
+#ifdef x_debug
+			printf("Got \"SB\" from Module\n");
+#endif
+			if (data[0] & 0x80)
+			{
+				printf("->data ready (%d)\n", getSlotID());
+				// send the RCV and ask for the data
+				unsigned char send_data[5];
+				send_data[0] = getSlotID();
+				send_data[1] = connection_id;
+				send_data[2] = T_RCV;
+				send_data[3] = 1;
+				send_data[4] = connection_id;
+				write(fd, send_data, 5);
+				gettimeofday(&tx_time, 0);
+			}
+			else
+			{
+				tx_time.tv_sec = 0;
+			}
+			break;
+		}
+		default:
+			printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
  : eServerSocket(CIPLUS_SERVER_SOCKET, eApp)
 {
@@ -161,7 +392,11 @@
 	{
 		path.str("");
 		path.clear();
+#ifdef __sh__
+		path << "/dev/dvb/adapter0/ci" << num_ci;
+#else
		path << "/dev/ci" << num_ci;
+#endif
 
 		if(::access(path.str().c_str(), R_OK) < 0)
 			break;
@@ -988,8 +1223,13 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#ifdef __sh__
+		sendData(d, len);
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#else
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 	}
 
 	return res;
@@ -998,6 +1219,7 @@
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("[CI] Slot %d what %d\n", getSlotID(), what);
+#ifndef __sh__
 	if(what == eSocketNotifier::Priority) {
 		if(state != stateRemoved) {
 			state = stateRemoved;
@@ -1053,6 +1234,166 @@
 		else
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 	}
+#else
+	unsigned char data[1024];
+	int len = 1024;
+	unsigned char* d;
+	eData status;
+	ca_slot_info_t info;
+
+	if (what & eSocketNotifier::Read)
+	{
+		eDebugCI("eSocketNotifier::Read\n");
+		status = eDataReady;
+		len = ::read(fd, data, len);
+	}
+	else if (what & eSocketNotifier::Write)
+	{
+		eDebugCI("eSocketNotifier::Write\n");
+		status = eDataWrite;
+	}
+	else if (what & eSocketNotifier::Priority)
+	{
+		eDebugCI("eSocketNotifier::Priority\n");
+		status = eDataStatusChanged;
+	}
+
+	switch (getState())
+	{
+		case stateInvalid:
+		{
+			if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("1. cam status changed ->cam now present\n");
+					state = stateInserted;
+					mmi_active = false;
+					tx_time.tv_sec = 0;
+					application_manager = 0;
+					ca_manager = 0;
+					sendCreateTC();
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+				}
+			}
+			else
+			{
+				usleep(100000);
+			}
+		}
+		break;
+		case stateInserted:
+		{
+			if (status == eDataReady)
+			{
+				eDebugCI("received data - len %d\n", len);
+				//int s_id = data[0];
+				//int c_id = data[1];
+				//printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+				d = data;
+				/* taken from the dvb-apps */
+				int data_length = len - 2;
+				d += 2; /* remove leading slot and connection id */
+				while (data_length > 0)
+				{
+					unsigned char tpdu_tag = d[0];
+					unsigned short asn_data_length;
+					int length_field_len;
+					if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0)
+					{
+						printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+						break;
+					}
+
+					if ((asn_data_length < 1) || (asn_data_length > (data_length - (1 + length_field_len))))
+					{
+						printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+						break;
+					}
+					connection_id = d[1 + length_field_len];
+					//printf("Setting connection_id from received data to %d\n", slot->connection_id);
+					d += 1 + length_field_len + 1;
+					data_length -= (1 + length_field_len + 1);
+					asn_data_length--;
+					process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+					// skip over the consumed data
+					d += asn_data_length;
+					data_length -= asn_data_length;
+				} // while (data_length)
+			} /* data ready */
+			else if (status == eDataWrite)
+			{
+				if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+				{
+					const queueData &qe = sendqueue.top();
+					int res = write(fd, qe.data, qe.len);
+					if (res >= 0 && (unsigned int)res == qe.len)
+					{
+						delete [] qe.data;
+						sendqueue.pop();
+						gettimeofday(&tx_time, 0);
+					}
+					else
+					{
+						printf("r = %d, %m\n", res);
+					}
+				}
+				/* the spec say's that we _must_ poll the connection
+				 * if the transport connection is in active state
+				 */
+				if ((tx_time.tv_sec == 0) && (!checkQueueSize()) && (time_after(last_poll_time, 1000)))
+				{
+					sendData(NULL, 0);
+					clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+				}
+			}
+			else if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("2. cam status changed ->cam now present\n");
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+				}
+				else if (!(info.flags & CA_CI_MODULE_READY))
+				{
+					printf("cam status changed ->cam now _not_ present\n");
+					eDVBCISession::deleteSessions(this);
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCIInterfaces::getInstance()->ciRemoved(this);
+					eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+					while (sendqueue.size())
+					{
+						delete [] sendqueue.top().data;
+						sendqueue.pop();
+					}
+				}
+			}
+		}
+		break;
+		default:
+			printf("unknown state %d\n", state);
+		break;
+	}
+	notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1071,7 +1468,11 @@
 
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1082,10 +1483,24 @@
 	eDebugCI("[CI] Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	receivedLen = 0;
+	receivedData = NULL;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+		tx_time.tv_sec = 0;
+		tx_time.tv_usec = 0;
+		last_poll_time.tv_sec = 0;
+		last_poll_time.tv_nsec = 0;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+#ifdef __sh__
+		reset();
+#endif
 	} else
 	{
 		perror(filename);
@@ -1121,6 +1536,13 @@
 {
 	eDebug("[CI] Slot %d: reset requested", getSlotID());
 
+#ifdef __sh__
+	state = stateInvalid;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+	eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1128,6 +1550,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif
 
 	while(sendqueue.size())
 	{
@@ -1135,7 +1558,12 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
--- enigma2.org/lib/dvb_ci/dvbci.h
+++ enigma2/lib/dvb_ci/dvbci.h
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -39,6 +42,42 @@
 typedef std::set<providerPair> providerSet;
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
+
+#ifdef __sh__
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+					// layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+					// layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
 
 class eDVBCISlot: public iObject, public Object
 {
@@ -63,6 +102,13 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char connection_id;
+	bool mmi_active;
+	int receivedLen;
+	unsigned char* receivedData;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -92,6 +138,17 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(const std::string &source);
 	int setClockRate(int);
+#ifdef __sh__
+	bool checkQueueSize();
+	void thread();
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+	void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+	bool sendCreateTC();
+	eData sendData(unsigned char* data, int len);
+	struct timeval tx_time;
+	struct timespec last_poll_time;
+#endif
 	static std::string getTunerLetter(int tuner_no) { return std::string(1, char(65 + tuner_no)); }
 };
 
--- enigma2.org/lib/dvb_ci/dvbci_mmi.cpp
+++ enigma2/lib/dvb_ci/dvbci_mmi.cpp
@@ -26,6 +26,9 @@
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	slot->mmiClosed();
+#endif
 	slot->setMMIManager(NULL);
 	if (is_mmi_active)
 		eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
--- enigma2.org/lib/dvb_ci/dvbci_resmgr.cpp
+++ enigma2/lib/dvb_ci/dvbci_resmgr.cpp
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("[CI RM] eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLineStart("[CI RM] SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLineStart("[CI RM] SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebugNoNewLine("\n");
--- enigma2.org/lib/dvb_ci/dvbci_session.cpp
+++ enigma2/lib/dvb_ci/dvbci_session.cpp
@@ -297,6 +297,12 @@
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("[CI SESS] PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seem to have some problems
+			//on some modules which "lose" the connection. So reset it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 
--- enigma2.org/lib/gdi/accel.cpp
+++ enigma2/lib/gdi/accel.cpp
@@ -15,8 +15,25 @@
 // #define ACCEL_DEBUG
 
 gAccel *gAccel::instance;
+#if not defined(__sh__)
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -53,6 +70,9 @@
 {
 	instance = this;
 
+#ifdef STMFB_ACCEL
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_init();
 #endif
@@ -63,6 +83,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -146,6 +169,69 @@
 
 int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	int src_format = 0;
+	gUnmanagedSurface *surfaceTmp = new gUnmanagedSurface(area.width(), area.height(), dst->bpp);
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+		if (accelAlloc(surfaceTmp))
+			return -1;
+
+		__u8 *srcptr = (__u8*)src->data;
+		__u8 *dstptr = (__u8*)surfaceTmp->data;
+		__u32 pal[256];
+
+		for (int i = 0; i < 256; ++i)
+		{
+			if (src->clut.data && (i < src->clut.colors))
+				pal[i] = (src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i] = 0x010101*i;
+			if ((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i] ^= 0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y = 0; y < area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if (surfaceTmp->data_phys)
+			accelFree(surfaceTmp);
+		return -1;
+	}
+
+	if (surfaceTmp->data_phys)
+	{
+		stmfb_accel_blit(
+			surfaceTmp->data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(surfaceTmp);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
@@ -274,9 +360,9 @@
 
 void gAccel::accelFree(gUnmanagedSurface* surface)
 {
-	int phys_addr = surface->data_phys;
-	if (phys_addr != 0)
+	if(surface != 0 && surface->data_phys != 0)
 	{
+		int phys_addr = surface->data_phys;
 #ifdef ACCEL_DEBUG
 		eDebug("[gAccel] [%s] %p->%x %dx%d:%d", __func__, surface, surface->data_phys, surface->x, surface->y, surface->bpp);
 #endif
--- enigma2.org/lib/gdi/fb.cpp
+++ enigma2/lib/gdi/fb.cpp
@@ -8,6 +8,9 @@
 #include <linux/kd.h>
 
 #include <lib/gdi/fb.h>
+#ifdef __sh__
+#include <linux/stmfb.h>
+#endif
 
 #ifndef FBIO_WAITFORVSYNC
 #define FBIO_WAITFORVSYNC _IOW('F', 0x20, uint32_t)
@@ -47,11 +50,13 @@
 	}
 
 
+#if not defined(__sh__)
 	if (ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo)<0)
 	{
 		eDebug("[fb] FBIOGET_VSCREENINFO: %m");
 		goto nolfb;
 	}
+#endif
 
 	fb_fix_screeninfo fix;
 	if (ioctl(fbFd, FBIOGET_FSCREENINFO, &fix)<0)
@@ -62,8 +67,17 @@
 
 	available=fix.smem_len;
 	m_phys_mem = fix.smem_start;
+#if defined(__sh__)
+	eDebug("[fb] %dk total video mem", available/1024);
+	// The first 1920x1080x4 bytes are reserved
+	// After that we can take 1280x720x4 bytes for our virtual framebuffer
+	available -= 1920*1080*4;
+	eDebug("%dk usable video mem", available/1024);
+	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 1920*1080*4);
+#else
 	eDebug("[fb] %s: %dk video mem", fb, available/1024);
 	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 0);
+#endif
 	if (!lfb)
 	{
 		eDebug("[fb] mmap: %m");
@@ -86,6 +100,7 @@
 
 int fbClass::showConsole(int state)
 {
+#if not defined(__sh__)
 	int fd=open("/dev/tty0", O_RDWR);
 	if(fd>=0)
 	{
@@ -95,11 +110,19 @@
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 {
+#if defined(__sh__)
+	xRes=nxRes;
+	yRes=nyRes;
+	bpp=32;
+	m_number_of_pages = 1;
+	topDiff=bottomDiff=leftDiff=rightDiff = 0;
+#else
 	if (fbFd < 0) return -1;
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
@@ -149,8 +172,14 @@
 
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 
+#endif
 	ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo);
 
+#if defined(__sh__)
+	xResSc=screeninfo.xres;
+	yResSc=screeninfo.yres;
+	stride=xRes*4;
+#else
 	if ((screeninfo.xres != (unsigned int)nxRes) || (screeninfo.yres != (unsigned int)nyRes) ||
 		(screeninfo.bits_per_pixel != (unsigned int)nbpp))
 	{
@@ -168,15 +197,22 @@
 	}
 	stride=fix.line_length;
 	memset(lfb, 0, stride*yRes);
+#endif
 	blit();
 	return 0;
 }
 
 void fbClass::getMode(int &xres, int &yres, int &bpp)
 {
+#if defined(__sh__)
+	xres = xRes;
+	yres = yRes;
+	bpp = 32;
+#else
 	xres = screeninfo.xres;
 	yres = screeninfo.yres;
 	bpp = screeninfo.bits_per_pixel;
+#endif
 }
 
 int fbClass::setOffset(int off)
@@ -196,11 +232,94 @@
 
 void fbClass::blit()
 {
+#if defined(__sh__)
+	int modefd = open("/proc/stb/video/3d_mode", O_RDWR);
+	char buf[16] = "off";
+	if (modefd > 0)
+	{
+		read(modefd, buf, 15);
+		buf[15]='\0';
+		close(modefd);
+	}
+
+	STMFBIO_BLT_DATA     bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = 1920*1080*4;
+	bltData.srcPitch   = xRes * 4;
+	bltData.dstOffset  = 0;
+	bltData.dstPitch   = xResSc*4;
+	bltData.src_top    = 0;
+	bltData.src_left   = 0;
+	bltData.src_right  = xRes;
+	bltData.src_bottom = yRes;
+	bltData.srcFormat  = SURF_BGRA8888;
+	bltData.dstFormat  = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER;
+	bltData.dstMemBase = STMFBGP_FRAMEBUFFER;
+
+	if (strncmp(buf,"sbs",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff/2;
+		bltData.dst_right  = xResSc/2 + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = xResSc/2 + leftDiff/2;
+		bltData.dst_right  = xResSc + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else if (strncmp(buf,"tab",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc/2 + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = yResSc/2 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	
+	}
+
+	if (ioctl(fbFd, STMFBIO_SYNC_BLITTER) < 0)
+	{
+		perror("STMFBIO_SYNC_BLITTER");
+	}
+#else
 	if (fbFd < 0) return;
 	if (m_manual_blit == 1) {
 		if (ioctl(fbFd, FBIO_BLIT) < 0)
 			eDebug("[fb] FBIO_BLIT: %m");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -236,6 +355,25 @@
 	}
 	else
 		locked = 1;
+#if defined(__sh__)
+	outcfg.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_GET_OUTPUT_CONFIG\n");
+
+	outinfo.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_GET_OUTPUTINFO\n");
+
+	//if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+	//	printf("ERROR\n");
+
+	planemode.layerid = 0;
+	if (ioctl( fbFd, STMFBIO_GET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_GET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_GET_VAR_SCREENINFO_EX\n");
+#endif
 	return fbFd;
 }
 
@@ -246,27 +384,89 @@
 	if (locked == 2)  // re-enable manualBlit
 		enableManualBlit();
 	locked=0;
+
+#if defined(__sh__)
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_SET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_SET_OUTPUTINFO\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_SET_OUTPUT_CONFIG\n");
+
+	memset(lfb, 0, stride*yRes);
+#endif
+
 	SetMode(xRes, yRes, bpp);
 	PutCMAP();
 }
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 1;
 	if (fbFd < 0) return;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		eDebug("[fb] enable FBIO_SET_MANUAL_BLIT: %m");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 0;
 	if (fbFd < 0) return;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		eDebug("[fb] disable FBIO_SET_MANUAL_BLIT: %m");
 	else
 		m_manual_blit = 0;
-}
-
+#endif
+}
+
+#if defined(__sh__)
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+//	memset(lfb, 0x00, xRes * yRes * 4);
+	blit();
+#endif
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
+}
+
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
--- enigma2.org/lib/gdi/fb.h
+++ enigma2/lib/gdi/fb.h
@@ -3,6 +3,9 @@
 
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
+#if defined(__sh__)
+	#include <linux/stmfb.h>
+#endif
 
 #ifndef FB_DEV
 # define FB_DEV "/dev/fb0"
@@ -12,6 +15,15 @@
 {
 	int fbFd;
 	int xRes, yRes, stride, bpp;
+#if defined(__sh__)
+	struct stmfbio_output_configuration outcfg;
+	struct stmfbio_outputinfo outinfo;
+	struct stmfbio_planeinfo planemode;
+	struct stmfbio_var_screeninfo_ex infoex;
+
+	int xResSc, yResSc;
+	int topDiff, leftDiff, rightDiff, bottomDiff;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo;
 	fb_cmap cmap;
@@ -53,6 +65,18 @@
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+#ifdef ENABLE_LIBEPLAYER3
+//	"hack" for libeplayer3 fb access
+	int getFD() { return fbFd; }
+	unsigned char * getLFB_Direct() { return lfb; }
+	int getScreenResX() { return xRes; }
+	int getScreenResY() { return yRes; }
+#endif
+#if defined(__sh__)
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 
 	int lock();
 	void unlock();
--- enigma2.org/lib/gdi/gfbdc.cpp
+++ enigma2/lib/gdi/gfbdc.cpp
@@ -25,8 +25,8 @@
 		|| (xres == 1920 && yres == 1080)))
 	{
 		/* fallback to a decent default */
-		xres = 720;
-		yres = 576;
+		xres = 1280; //j00zek lets make HD our default for OpenPLi
+		yres = 720;
 	}
 
 	surface.clut.data = 0;
@@ -177,14 +177,35 @@
 
 void gFBDC::setResolution(int xres, int yres, int bpp)
 {
+#if defined(__sh__)
+	/* if xres and yres are negative call SetMode with the lates xres and yres
+	 * we need that to read the new screen dimensions after a resolution change
+	 * without changing the framebuffer dimensions
+	 */
+	int m_xres;
+	int m_yres;
+	int m_bpp;
+	fb->getMode(m_xres, m_yres, m_bpp);
+
+	if (xres<0 && yres<0 ) {
+		fb->SetMode(m_xres, m_yres, bpp);
+		return;
+	}
+#else
 	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp))
 		return;
+#endif
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->releaseAccelMemorySpace();
 
 	fb->SetMode(xres, yres, bpp);
 
+#if defined(__sh__)
+	for (int y = 0; y<yres; y++) { // make whole screen transparent
+		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
+	}
+#endif
 	surface.x = xres;
 	surface.y = yres;
 	surface.bpp = bpp;
--- enigma2.org/lib/gdi/glcddc.cpp
+++ enigma2/lib/gdi/glcddc.cpp
@@ -6,6 +6,21 @@
 
 gLCDDC *gLCDDC::instance;
 
+#ifdef HAVE_GRAPHLCD
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 gLCDDC::gLCDDC()
 {
 	lcd = new eFbLCD();
@@ -39,11 +54,18 @@
 	eDebug("[gLCDDC] resolution: %dx%dx%d stride=%d", surface.x, surface.y, surface.bpp, surface.stride);
 
 	m_pixmap = new gPixmap(&surface);
+#ifdef HAVE_GRAPHLCD
+	clock_gettime(CLOCK_MONOTONIC, &last_update);
+#endif
 }
 
 gLCDDC::~gLCDDC()
 {
+#ifndef HAVE_GRAPHLCD
+//konfetti: not sure why, but calling the destructor if external lcd (pearl) is selected
+//e2 crashes. this is also true if the destructor does not contain any code !!!
 	delete lcd;
+#endif
 	if (surface.clut.data)
 		delete[] surface.clut.data;
 	instance = 0;
@@ -70,7 +92,15 @@
 		break;
 #endif
 	case gOpcode::flush:
+#ifdef HAVE_GRAPHLCD
+		if (update)
+		{
+			lcd->update();
+			clock_gettime(CLOCK_MONOTONIC, &last_update);
+		}
+#else
 		lcd->update();
+#endif
 	default:
 		gDC::exec(o);
 		break;
--- enigma2.org/lib/gdi/glcddc.h
+++ enigma2/lib/gdi/glcddc.h
@@ -10,6 +10,9 @@
 	static gLCDDC *instance;
 	int update;
 	void exec(const gOpcode *opcode);
+#ifdef HAVE_GRAPHLCD
+	struct timespec last_update;
+#endif
 	gUnmanagedSurface surface;
 public:
 	gLCDDC();
--- enigma2.org/lib/gdi/gpixmap.cpp
+++ enigma2/lib/gdi/gpixmap.cpp
@@ -152,11 +152,13 @@
 	if (data)
 	{
 		delete [] (unsigned char*)data;
+		data = 0;
 		removed_pixmap(y * stride);
 	}
 	if (clut.data)
 	{
 		delete [] clut.data;
+		clut.data = 0;
 	}
 }
 
@@ -200,6 +202,9 @@
 			if (surface->clut.data && color < surface->clut.colors)
 				col = surface->clut.data[color].argb();
 			else
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 				col = 0x10101 * color;
 
 			col^=0xFF000000;
@@ -234,6 +239,9 @@
 			uint32_t col;
 
 			col = color.argb();
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 #ifdef GPIXMAP_DEBUG
@@ -441,7 +449,8 @@
 		Stopwatch s;
 #endif
 		if (accel) {
-			if (!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag)) {
+			if (!(src.surface->bpp==8 && surface->bpp==32) && 
+					(!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag))) {
 #ifdef GPIXMAP_DEBUG
 				s.stop();
 				eDebug("[gPixmap] [BLITBENCH] accel blit took %u us", s.elapsed_us());
@@ -809,6 +818,7 @@
 	}
 
 	delete [] lookup;
+	lookup = 0;
 }
 
 static inline int sgn(int a)
--- enigma2.org/lib/gdi/lcd.cpp
+++ enigma2/lib/gdi/lcd.cpp
@@ -69,6 +69,7 @@
 }
 #endif
 
+#ifndef HAVE_GRAPHLCD
 eDBoxLCD::eDBoxLCD()
 {
 	int xres = 132, yres = 64, bpp = 8;
@@ -296,3 +297,128 @@
 	}
 #endif
 }
+#else
+void eDBoxLCD::setFlipped(bool onoff)
+{
+	flipped = onoff;
+	update();
+}
+
+/* **************************************************************** */
+/* Pearl LCD */
+
+eDBoxLCD::eDBoxLCD()
+{
+	eDebug("eDBoxLCD::eDBoxLCD >");
+
+	displayNumber = 0;
+	lcd_type = 1;
+
+	instance = this;
+
+	if (GLCD::Config.Load("/etc/graphlcd.conf") == false)
+	{
+		eDebug("Error loading config file!\n");
+		return;
+	}
+	if (GLCD::Config.driverConfigs.size() <= 0)
+	{
+		eDebug("ERROR: No displays specified in config file!\n");
+	}
+
+	GLCD::Config.driverConfigs[displayNumber].upsideDown ^= 0;
+	GLCD::Config.driverConfigs[displayNumber].invert ^= 0;
+
+	lcd = GLCD::CreateDriver(GLCD::Config.driverConfigs[displayNumber].id, &GLCD::Config.driverConfigs[displayNumber]);
+
+	if (!lcd)
+	{
+		eDebug("ERROR: Failed creating display object\n");
+		return;
+	}
+	if (lcd->Init() != 0)
+	{
+#if 0
+	// Returning an error here will break the code at various other places
+		eDebug("ERROR: Failed initializing display\n");
+		delete lcd;
+		lcd = NULL;
+		return;
+#endif
+	}
+	lcd->SetBrightness(GLCD::Config.driverConfigs[displayNumber].brightness);
+
+	lcd->GetFeature((std::string) "depth", depth);
+	width = GLCD::Config.driverConfigs[displayNumber].width;
+	height = GLCD::Config.driverConfigs[displayNumber].height;
+
+	eDebug("config -> (w %d, h %d)", width, height);
+
+	bitmap = new GLCD::cBitmap(width, height);
+	bitmap->Clear();
+
+	lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+	lcd->Refresh(true);
+
+	lcdfd = 1; //needed for detected()
+	setSize(width, height, depth);
+
+	eDebug("eDBoxLCD::eDBoxLCD (w %d, h %d, depth %d)<", width, height, depth);
+}
+
+void eDBoxLCD::setInverted(unsigned char inv)
+{
+	eDebug("eDBoxLCD::setInverted");
+	inverted = inv;
+	update();
+}
+
+int eDBoxLCD::setLCDContrast(int contrast)
+{
+	eDebug("[LCD] setLCDContrast not supported");
+	return(0);
+}
+
+int eDBoxLCD::setLCDBrightness(int brightness)
+{
+	eDebug("eDBoxLCD::setLCDBrightness");
+/* fixme range check */
+	lcd->SetBrightness(brightness);
+	return(0);
+}
+
+void eDBoxLCD::update()
+{
+	if (lcdfd == 1)
+	{
+		bitmap->Clear();
+		for (int x = 0; x < width; x++)
+			for (int y = 0; y < height; y++)
+			{
+				__u16 *buf16  = (__u16*) _buffer;
+#if BYTE_ORDER == LITTLE_ENDIAN
+				__u16 col16 = bswap_16(*((__u16*)(((__u16*)buf16) + y * width + x)));
+#else
+				__u16 col16 = *((__u16*)(((__u16*)buf16) + y * width + x));
+#endif
+				__u8 red, green, blue, alpha; 
+				__u32 color32;
+
+				/* BBBBB GGGGGG RRRRR */
+				blue  = ((col16 & 0xF800) >> 11) * ( 255 / 31);
+				green = ((col16 & 0x7E0) >> 5) * (255 / 63);
+				red   = (col16 & 0x1f) * (255 / 31);
+				alpha = 255;
+
+				color32 = alpha << 24 | red << 16 | green << 8 | blue;
+
+				if (inverted)
+					color32 = 0xFFFFFF - color32;
+
+				bitmap->DrawPixel(x, y, color32);
+			}
+		lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+		lcd->Refresh(false); /* partial update */
+	}
+}
+#endif
--- enigma2.org/lib/gdi/lcd.h
+++ enigma2/lib/gdi/lcd.h
@@ -6,6 +6,17 @@
 #include <lib/gdi/erect.h>
 #include "gpixmap.h"
 
+#ifdef HAVE_GRAPHLCD
+#include <glcdgraphics/bitmap.h>
+#include <glcdgraphics/glcd.h>
+#include <glcdgraphics/image.h>
+#include <glcddrivers/config.h>
+#include <glcddrivers/driver.h>
+#include <glcddrivers/drivers.h>
+#include <glcdgraphics/extformats.h>
+#include <byteswap.h>
+#endif
+
 #define LCD_CONTRAST_MIN 0
 #define LCD_CONTRAST_MAX 63
 #define LCD_BRIGHTNESS_MIN 0
@@ -58,6 +69,13 @@
 {
 	unsigned char inverted;
 	bool flipped;
+#ifdef HAVE_GRAPHLCD
+	GLCD::cDriver * lcd;
+	GLCD::cBitmap * bitmap;
+	int displayNumber;
+	int depth;
+	int width, height;
+#endif
 #ifdef SWIG
 	eDBoxLCD();
 	~eDBoxLCD();
--- enigma2.org/lib/gdi/Makefile.inc
+++ enigma2/lib/gdi/Makefile.inc
@@ -20,7 +20,8 @@
 	gdi/lcd.cpp \
 	gdi/picexif.cpp \
 	gdi/picload.cpp \
-	gdi/region.cpp
+	gdi/region.cpp \
+	gdi/stmfb.cpp
 
 gdiincludedir = $(pkgincludedir)/lib/gdi
 gdiinclude_HEADERS = \
--- enigma2.org/lib/gdi/stmfb.cpp
+++ enigma2/lib/gdi/stmfb.cpp
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+//static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+	bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+	bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
--- enigma2.org/lib/Makefile.am
+++ enigma2/lib/Makefile.am
@@ -6,6 +6,18 @@
 	-I$(top_srcdir)/include \
 	-include Python.h \
 	-include $(top_builddir)/enigma2_config.h
+
+if ENABLE_LIBEPLAYER3
+if ENABLE_MEDIAFWGSTREAMER
+AM_CPPFLAGS += \
+	-I$(top_srcdir)/../../apps/tools/libeplayer3/include
+else
+AM_CPPFLAGS += \
+	-D__STDC_CONSTANT_MACROS \
+	-D__STDC_FORMAT_MACROS \
+	-I$(top_srcdir)/../../apps/tools/eplayer3/include
+endif
+endif
 
 # initialize these, to be filled with targets in the included files
 noinst_LIBRARIES=
--- enigma2.org/lib/python/Components/Converter/RemainingToText.py
+++ enigma2/lib/python/Components/Converter/RemainingToText.py
@@ -8,6 +8,9 @@
 	IN_SECONDS = 3
 	PROGRESS = 4
 	WITH_SECONDSPROGRESS = 5
+#+++>
+	FOLLOW = 6
+#+++<
 
 	def __init__(self, type):
 		Converter.__init__(self, type)
@@ -21,6 +24,10 @@
 			self.type = self.PROGRESS
 		elif type == "WithSecondsProgress":
 			self.type = self.WITH_SECONDSPROGRESS
+#+++>
+		elif type == "FOLLOW":
+			self.type = self.FOLLOW
+#+++<
 		else:
 			self.type = self.DEFAULT
 
@@ -52,6 +59,13 @@
 					return "%s%d:%02d" % (prefix, hours, minutes)
 				elif self.type == self.IN_SECONDS:
 					return prefix+str(tsecs)
+#+++>
+				elif self.type == self.FOLLOW:
+					if remaining is not None:
+						return "in %d min" % (remaining / 60)
+					else:
+						return "%d min" % (duration / 60)
+#+++<
 				elif self.type == self.DEFAULT:
 					if remaining <= duration:
 						prefix = "+"
--- enigma2.org/lib/python/Components/Harddisk.py
+++ enigma2/lib/python/Components/Harddisk.py
@@ -47,6 +47,7 @@
 class Harddisk:
 	def __init__(self, device, removable=False):
 		self.device = device
+		self.card = False
 
 		if os.access("/dev/.udev", 0):
 			self.type = DEVTYPE_UDEV
@@ -54,7 +55,6 @@
 			self.type = DEVTYPE_DEVFS
 		else:
 			print "[Harddisk] Unable to determine structure of /dev"
-			self.card = False
 
 		self.max_idle_time = 0
 		self.idle_running = False
@@ -83,25 +83,30 @@
 			self.card = "sdhci" in self.phys_path
 
 		elif self.type == DEVTYPE_DEVFS:
-			tmp = readFile(self.sysfsPath('dev')).split(':')
-			s_major = int(tmp[0])
-			s_minor = int(tmp[1])
-			for disc in os.listdir("/dev/discs"):
-				dev_path = os.path.realpath('/dev/discs/' + disc)
-				disk_path = dev_path + '/disc'
-				try:
-					rdev = os.stat(disk_path).st_rdev
-				except OSError:
-					continue
-				if s_major == os.major(rdev) and s_minor == os.minor(rdev):
-					self.dev_path = dev_path
-					self.disk_path = disk_path
-					break
-			self.card = self.device[:2] == "hd" and "host0" not in self.dev_path
+#			tmp = readFile(self.sysfsPath('dev')).split(':')
+#			s_major = int(tmp[0])
+#			s_minor = int(tmp[1])
+#			for disc in os.listdir("/dev/discs"):
+#				dev_path = os.path.realpath('/dev/discs/' + disc)
+#				disk_path = dev_path + '/disc'
+#				try:
+#					rdev = os.stat(disk_path).st_rdev
+#				except OSError:
+#					continue
+#				if s_major == os.major(rdev) and s_minor == os.minor(rdev):
+#					self.dev_path = dev_path
+#					self.disk_path = disk_path
+#					break
+#			self.card = self.device[:2] == "hd" and "host0" not in self.dev_path
+			self.dev_path = '/dev/' + self.device
+			self.disk_path = self.dev_path
+		else:
+			print "[Harddisk] self.type =", self.type
 
 		print "[Harddisk] new device", self.device, '->', self.dev_path, '->', self.disk_path
 		if not removable and not self.card:
 			self.startIdle()
+		Console().ePopen(("mount", "mount", "-a"))
 
 	def __lt__(self, ob):
 		return self.device < ob.device
@@ -242,7 +247,9 @@
 
 	def createPartition(self):
 		cmd = 'printf "8,\n;0,0\n;0,0\n;0,0\ny\n" | sfdisk -f -uS ' + self.disk_path
+		print "[Harddisk] Creating partition with ", cmd
 		res = os.system(cmd)
+		print "[Harddisk] Creating partition completed with result ", res
 		return (res >> 8)
 
 	def mkfs(self):
@@ -285,6 +292,7 @@
 		return 1
 
 	def killPartitionTable(self):
+		print "[Harddisk] Delete partition table on ", self.dev_path
 		zero = 512 * '\0'
 		h = open(self.dev_path, 'wb')
 		# delete first 9 sectors, which will likely kill the first partition too
@@ -301,25 +309,36 @@
 		h.close()
 
 	def createInitializeJob(self):
-		job = Task.Job(_("Initializing storage device..."))
+		job = Task.Job(_("Initialize hard disk"))
 		size = self.diskSize()
-		print "[HD] size: %s MB" % size
-
-		task = UnmountTask(job, self)
-
-		task = Task.PythonTask(job, _("Removing partition table"))
-		task.work = self.killPartitionTable
-		task.weighting = 1
-
-		task = Task.LoggingTask(job, _("Rereading partition table"))
-		task.weighting = 1
-		task.setTool('hdparm')
-		task.args.append('-z')
-		task.args.append(self.disk_path)
-
-		task = Task.ConditionTask(job, _("Waiting for partition"), timeoutCount=20)
-		task.check = lambda: not os.path.exists(self.partitionPath("1"))
-		task.weighting = 1
+		sectors = ((size * 1000 / 512) * 1000)
+		print "[Harddisk] Create initialize job, consisting of:"
+		print "[Harddisk init] Initializing device /dev/%s, size is: %s MB" % (self.device, size)
+#		print "                (Equals %s sectors)" % sectors
+
+		if self.disk_path:
+			print "[Harddisk init] Unmount", self.disk_path
+			task = UnmountTask(job, self)
+
+			print "[Harddisk init] Deleting partition table on ", self.disk_path
+			task = Task.PythonTask(job, _("Removing partition table"))
+			task.work = self.killPartitionTable
+			task.weighting = 1
+
+			print "[Harddisk init] Rereading partition table on", self.disk_path
+			task = Task.LoggingTask(job, _("Rereading partition table"))
+			task.weighting = 1
+			task.setTool('hdparm')
+			task.args.append('-z')
+			task.args.append(self.disk_path)
+
+			print "[Harddisk init] Wait for finish of deleting partition table on ", self.disk_path
+			task = Task.ConditionTask(job, _("Waiting for delete of partition table"), timeoutCount=20)
+			task.check = lambda: not os.path.exists(self.partitionPath("1"))
+			task.weighting = 1
+		else:
+			self.disk_path = "/dev/" + self.device
+			print "[Harddisk init] No partitions found on ", self.disk_path
 
 		if os.path.exists('/usr/sbin/parted'):
 			use_parted = True
@@ -330,7 +349,9 @@
 			else:
 				use_parted = False
 
-		task = Task.LoggingTask(job, _("Creating partition"))
+# create the RECORD partition. On disks larger than 20 GB,
+# create a second partition SWAPPART of 1 GB
+		task = Task.LoggingTask(job, _("Creating partition(s)"))
 		task.weighting = 5
 		if use_parted:
 			task.setTool('parted')
@@ -342,9 +363,17 @@
 				alignment = 'opt'
 			if size > 2097151:
 				parttype = 'gpt'
+				task.args += ['-a', alignment, '-s', self.disk_path, 'mklabel', parttype, 'mkpart', 'primary', '0%', endsize, 'name', '1', 'RECORD', 'mkpart', 'primary', endsize, '100%', 'name', '2', 'SWAPPART']
+				print "[Harddisk init] Creating 2 partitions RECORD and SWAPPART with command ", task.args
 			else:
 				parttype = 'msdos'
-			task.args += ['-a', alignment, '-s', self.disk_path, 'mklabel', parttype, 'mkpart', 'primary', '0%', '100%']
+				if size > 20000: # create a second SWAPPART partition
+					endsize = str(size - 1024) + "MB"
+					task.args += ['-a', alignment,'-s', self.disk_path, 'mklabel', parttype, 'mkpart', 'primary', '0%', endsize, 'mkpart', 'primary', endsize, '100%']
+					print "[Harddisk init] Creating 2 partitions RECORD and SWAPPART with command ", task.args
+				else:
+					task.args += ['-a', alignment, '-s', self.disk_path, 'mklabel', parttype, 'mkpart', 'primary', '0%', '100%']
+					print "[Harddisk init] Creating RECORD partition with command ", task.args
 		else:
 			task.setTool('sfdisk')
 			task.args.append('-f')
@@ -352,51 +381,102 @@
 			task.args.append(self.disk_path)
 			if size > 128000:
 				# Start at sector 8 to better support 4k aligned disks
-				print "[HD] Detected >128GB disk, using 4k alignment"
-				task.initial_input = "8,,L\n;0,0\n;0,0\n;0,0\ny\n"
+				print "[Harddisk init] Note: Detected disk is >128GB, using 4k alignment"
+				start_sect = 8
 			else:
 				# Smaller disks (CF cards, sticks etc) don't need that
-				task.initial_input = ",,L\n;\n;\n;\ny\n"
-
-		task = Task.ConditionTask(job, _("Waiting for partition"))
-		task.check = lambda: os.path.exists(self.partitionPath("1"))
+				start_sect = 0
+			if size > 20000: # create a second SWAPPART partition
+				# 1GB is 1073741824 / 512 = 2097152 sectors (multiple of 4k)
+				#TODO: check for cylinder boundaries
+				end_sect1 = ((size * 1000 / 512) * 1000) - 2097152
+				start_sect2 = end_sect1 + 8 # stay on 4k boundary
+				task.initial_input = str(start_sect)+ "," + str(end_sect1) + "\n" + str(start_sect2) + "\n0,0\n0,0\ny\n"
+				print "[Harddisk init] Creating 2 partition RECORD and SWAPPART with command ", task.args
+			else:
+				task.initial_input = "0\n\n\n\ny\n"
+				print "[Harddisk init] Creating RECORD partition with command ", task.args
+			print "[Harddisk init] using input ", task.initial_input
+
+# execute a dummy fdisk -l to force read the harddisk's new content
+		task = Task.LoggingTask(job, _("Dummy command fdisk -l"))
 		task.weighting = 1
-
-		task = MkfsTask(job, _("Creating filesystem"))
-		big_o_options = ["dir_index"]
+		task.setTool('fdisk')
+		task.args.append('-l')
+		print "[Harddisk init] Dummy command fdisk -l"
+
+# used to hang here
+# fix1: added timeout so the job always finishes instead of never ending
+# fix2: dummy fdisk -l (previous step)
+		task = Task.ConditionTask(job, _("Waiting for creation of RECORD partition"), timeoutCount=5)
+		print "[Harddisk init] self.partitionPath(1) =", self.partitionPath("1")
+		task.check = lambda: not os.path.exists(self.partitionPath("1"))
+		task.weighting = 1
+		print "[Harddisk init] Wait for ", self.partitionPath("1"), " to exist"
+
+		task = MkfsTask(job, _("Creating filesystem on RECORD partition"))
 		if isFileSystemSupported("ext4"):
 			task.setTool("mkfs.ext4")
-			if size > 20000:
-				try:
-					version = map(int, open("/proc/version","r").read().split(' ', 4)[2].split('.',2)[:2])
-					if (version[0] > 3) or (version[0] > 2 and version[1] >= 2):
-						# Linux version 3.2 supports bigalloc and -C option, use 256k blocks
-						task.args += ["-C", "262144"]
-						big_o_options.append("bigalloc")
-				except Exception, ex:
-					print "Failed to detect Linux version:", ex
 		else:
 			task.setTool("mkfs.ext3")
-		if size > 250000:
+		if size > 250000:  # 250GB
 			# No more than 256k i-nodes (prevent problems with fsck memory requirements)
-			task.args += ["-T", "largefile", "-N", "262144"]
-			big_o_options.append("sparse_super")
+			task.args += ["-T", "largefile", "-O", "sparse_super", "-N", "262144"]
 		elif size > 16384:
 			# between 16GB and 250GB: 1 i-node per megabyte
-			task.args += ["-T", "largefile"]
-			big_o_options.append("sparse_super")
+			task.args += ["-T", "largefile", "-O", "sparse_super"]
 		elif size > 2048:
 			# Over 2GB: 32 i-nodes per megabyte
 			task.args += ["-T", "largefile", "-N", str(size * 32)]
-		task.args += ["-m0", "-O", ",".join(big_o_options), self.partitionPath("1")]
-
-		task = MountTask(job, self)
+		task.args += ["-L", "RECORD", "-m0", "-O", "dir_index", self.disk_path+"1"]
+		print "[Harddisk init] Make fs on RECORD partition using ", task.args
+
+		if size > 20000:
+			task = MkfsTask(job, _("Creating filesystem on SWAPPART partition"))
+			if isFileSystemSupported("ext4"):
+				task.setTool("mkfs.ext4")
+			else:
+				task.setTool("mkfs.ext3")
+			if size > 250000:  #250GB
+				# No more than 256k i-nodes (prevent problems with fsck memory requirements)
+				task.args += ["-T", "largefile", "-O", "sparse_super", "-N", "262144"]
+			elif size > 16384:
+				# between 16GB and 250GB: 1 i-node per megabyte
+				task.args += ["-T", "largefile", "-O", "sparse_super"]
+			elif size > 2048:
+				# Over 2GB: 32 i-nodes per megabyte
+				task.args += ["-T", "largefile", "-N", str(size * 32)]
+			task.args += ["-L", "SWAPPART", "-m0", "-O", "dir_index", self.disk_path+"2"]
+			print "[Harddisk init] Make fs on partition 2 using ", task.args
+
+# in the previous process /media/hdd is destroyed, so recreate it
+		task = Task.LoggingTask(job, _("Re-create /media/hdd"))
+		task.weighting = 1
+		task.setTool('mkdir')
+		task.args.append('-p')
+		task.args.append('/media/hdd')
+		print "[Harddisk init] Re-create /media/hdd directory"
+
+		task = Task.LoggingTask(job, _("Re-mount %s") % (self.disk_path + "1"))
 		task.weighting = 3
+		task.setTool('mount')
+		task.args.append(self.disk_path+"1")
+		task.args.append('/hdd')
+		print "[Harddisk init] Re-mounting %s" % (self.disk_path+"1")
 
 		task = Task.ConditionTask(job, _("Waiting for mount"), timeoutCount=20)
 		task.check = self.mountDevice
 		task.weighting = 1
-
+		print "[Harddisk init] Waiting for mount to succeed"
+
+		task = Task.LoggingTask(job, _("Create /media/hdd/movie"))
+		task.weighting = 1
+		task.setTool('mkdir')
+		task.args.append('-p')
+		task.args.append('/media/hdd/movie')
+		print "[Harddisk init] Create /media/hdd/movie directory"
+
+		print "[Harddisk init] End of job: ", job
 		return job
 
 	def initialize(self):
@@ -428,7 +508,7 @@
 
 	def createExt4ConversionJob(self):
 		if not isFileSystemSupported('ext4'):
-			raise Exception, _("You system does not support ext4")
+			raise Exception, _("Your system does not support ext4")
 		job = Task.Job(_("Converting ext3 to ext4..."))
 		if not os.path.exists('/sbin/tune2fs'):
 			addInstallTask(job, 'e2fsprogs-tune2fs')
@@ -707,16 +787,19 @@
 				self.devices_scanned_on_init.append((blockdev, removable, is_cdrom, medium_found))
 
 	def getAutofsMountpoint(self, device):
-		r = self.getMountpoint(device)
-		if r is None:
-			return "/media/" + device
-		return r
+		return "/autofs/%s" % (device)
 
 	def getMountpoint(self, device):
 		dev = "/dev/%s" % device
 		for item in getProcMounts():
 			if item[0] == dev:
 				return item[1]
+#+++>
+		#Check if has autofs mountpoint
+		mount = self.getAutofsMountpoint(device)
+		if mount:
+			return mount
+#+++<
 		return None
 
 	def addHotplugPartition(self, device, physdev = None):
@@ -732,6 +815,10 @@
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		if not blacklisted and medium_found:
 			description = self.getUserfriendlyDeviceName(device, physdev)
+#+++>
+			if description.startswith("External Storage"):
+				return False, False, False, False, [], False
+#+++<
 			p = Partition(mountpoint = self.getMountpoint(device), description = description, force_mounted = True, device = device)
 			self.partitions.append(p)
 			if p.mountpoint: # Plugins won't expect unmounted devices
@@ -824,7 +911,7 @@
 		try:
 			description = readFile("/sys" + phys + "/model")
 		except IOError, s:
-			print "couldn't read model: ", s
+			print "Could not read model: ", s
 		from Tools.HardwareInfo import HardwareInfo
 		for physdevprefix, pdescription in DEVICEDB.get(HardwareInfo().device_name,{}).items():
 			if phys.startswith(physdevprefix):
@@ -869,7 +956,7 @@
 			dev = self.hdd.disk_path.split('/')[-1]
 			open('/dev/nomount.%s' % dev, "wb").close()
 		except Exception, e:
-			print "ERROR: Failed to create /dev/nomount file:", e
+			print "[Harddisk] ERROR: Failed to create /dev/nomount file:", e
 		self.setTool('umount')
 		self.args.append('-f')
 		for dev in self.hdd.enumMountDevices():
@@ -877,7 +964,7 @@
 			self.postconditions.append(Task.ReturncodePostcondition())
 			self.mountpoints.append(dev)
 		if not self.mountpoints:
-			print "UnmountTask: No mountpoints found?"
+			print "[Harddisk] UnmountTask: No mountpoints found?"
 			self.cmd = 'true'
 			self.args = [self.cmd]
 	def afterRun(self):
@@ -885,7 +972,7 @@
 			try:
 				os.rmdir(path)
 			except Exception, ex:
-				print "Failed to remove path '%s':" % path, ex
+				print "[Harddisk] Failed to remove path '%s':" % path, ex
 
 class MountTask(Task.LoggingTask):
 	def __init__(self, job, hdd):
@@ -896,7 +983,7 @@
 			dev = self.hdd.disk_path.split('/')[-1]
 			os.unlink('/dev/nomount.%s' % dev)
 		except Exception, e:
-			print "ERROR: Failed to remove /dev/nomount file:", e
+			print "[Harddisk] ERROR: Failed to remove /dev/nomount file:", e
 		# try mounting through fstab first
 		if self.hdd.mount_device is None:
 			dev = self.hdd.partitionPath("1")
@@ -925,7 +1012,7 @@
 	def prepare(self):
 		self.fsck_state = None
 	def processOutput(self, data):
-		print "[Mkfs]", data
+		print "[Harddisk] Mkfs", data
 		if 'Writing inode tables:' in data:
 			self.fsck_state = 'inode'
 		elif 'Creating journal' in data:
--- enigma2.org/lib/python/Components/Network.py
+++ enigma2/lib/python/Components/Network.py
@@ -61,7 +61,7 @@
 		return [ int(n) for n in ip.split('.') ]
 
 	def getAddrInet(self, iface, callback):
-		cmd = ("/sbin/ip", "/sbin/ip", "-o", "addr", "show", "dev", iface)
+		cmd = ("/sbin/ip", "/sbin/ip", "addr", "show", "dev", iface)
 		self.console.ePopen(cmd, self.IPaddrFinished, [iface, callback])
 
 	def IPaddrFinished(self, result, retval, extra_args):
@@ -71,37 +71,45 @@
 		ipRegexp = '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
 		netRegexp = '[0-9]{1,2}'
 		macRegexp = '[0-9a-fA-F]{2}\:[0-9a-fA-F]{2}\:[0-9a-fA-F]{2}\:[0-9a-fA-F]{2}\:[0-9a-fA-F]{2}\:[0-9a-fA-F]{2}'
-		ipLinePattern = re.compile('inet ' + ipRegexp + '/')
+		ipLinePattern = re.compile(ipRegexp + '/')
 		ipPattern = re.compile(ipRegexp)
 		netmaskLinePattern = re.compile('/' + netRegexp)
 		netmaskPattern = re.compile(netRegexp)
-		bcastLinePattern = re.compile(' brd ' + ipRegexp)
+		bcastLinePattern = re.compile('brd ' + ipRegexp)
 		upPattern = re.compile('UP')
 		macPattern = re.compile(macRegexp)
-		macLinePattern = re.compile('link/ether ' + macRegexp)
+		macLinePattern = re.compile(macRegexp)
 
 		for line in result.splitlines():
 			split = line.strip().split(' ',2)
 			if (split[1][:-1] == iface) or (split[1][:-1] == (iface + '@sys0')):
 				up = self.regExpMatch(upPattern, split[2])
-				mac = self.regExpMatch(macPattern, self.regExpMatch(macLinePattern, split[2]))
+#				print "[Network] up = ", up
 				if up is not None:
 					data['up'] = True
 					if iface is not 'lo':
 						self.configuredInterfaces.append(iface)
+			if (split[0] == 'link/ether'):
+				mac = self.regExpMatch(macPattern, self.regExpMatch(macLinePattern, split[1]))
 				if mac is not None:
+#					print "[Network] mac = ", mac
 					data['mac'] = mac
-			if split[1] == iface:
-				if re.search(globalIPpattern, split[2]):
-					ip = self.regExpMatch(ipPattern, self.regExpMatch(ipLinePattern, split[2]))
-					netmask = self.calc_netmask(self.regExpMatch(netmaskPattern, self.regExpMatch(netmaskLinePattern, split[2])))
-					bcast = self.regExpMatch(ipPattern, self.regExpMatch(bcastLinePattern, split[2]))
-					if ip is not None:
-						data['ip'] = self.convertIP(ip)
-					if netmask is not None:
-						data['netmask'] = self.convertIP(netmask)
-					if bcast is not None:
-						data['bcast'] = self.convertIP(bcast)
+			if (split[0] == 'inet'):
+				ip = self.regExpMatch(ipPattern, self.regExpMatch(ipLinePattern, split[1]))
+#				if ip is not None:
+#					print "[Network] ip = ", ip
+				netmask = self.calc_netmask(self.regExpMatch(netmaskPattern, self.regExpMatch(netmaskLinePattern, split[1])))
+#				if netmask is not None:
+#					print "[Network] netmask = ", netmask
+				bcast = self.regExpMatch(ipPattern, self.regExpMatch(bcastLinePattern, split[2]))
+#				if bcast is not None:
+#					print "[Network] bcast = ", bcast
+				if ip is not None:
+					data['ip'] = self.convertIP(ip)
+				if netmask is not None:
+					data['netmask'] = self.convertIP(netmask)
+				if bcast is not None:
+					data['bcast'] = self.convertIP(bcast)
 
 		if 'ip' not in data:
 			data['dhcp'] = True
--- enigma2.org/lib/python/Components/NimManager.py
+++ enigma2/lib/python/Components/NimManager.py
@@ -22,6 +22,10 @@
 config.unicable = ConfigSubsection()
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
--- enigma2-nightly.org/lib/python/Components/SystemInfo.py
+++ enigma2-nightly/lib/python/Components/SystemInfo.py
@@ -46,7 +46,7 @@
 SystemInfo["3DZNorm"] = fileCheck("/proc/stb/fb/znorm") or fileCheck("/proc/stb/fb/primary/zoffset")
 SystemInfo["Blindscan_t2_available"] = fileCheck("/proc/stb/info/vumodel")
 SystemInfo["RcTypeChangable"] = not(HardwareInfo().get_device_model().startswith('et8500') or HardwareInfo().get_device_model().startswith('et7')) and pathExists('/proc/stb/ir/rc/type')
-SystemInfo["HasFullHDSkinSupport"] = HardwareInfo().get_device_model() not in ("et4000", "et5000", "sh1", "hd500c", "hd1100", "xp1000", "lc")
+SystemInfo["HasFullHDSkinSupport"] = False
 SystemInfo["HasForceLNBOn"] = fileCheck("/proc/stb/frontend/fbc/force_lnbon")
 SystemInfo["HasForceToneburst"] = fileCheck("/proc/stb/frontend/fbc/force_toneburst")
 SystemInfo["HasBypassEdidChecking"] = fileCheck("/proc/stb/hdmi/bypass_edid_checking")
--- enigma2.org/lib/python/Components/Renderer/Makefile.am
+++ enigma2/lib/python/Components/Renderer/Makefile.am
@@ -3,4 +3,4 @@
 install_PYTHON = \
 	__init__.py Label.py Progress.py Listbox.py Renderer.py Pixmap.py \
 	FixedLabel.py PositionGauge.py Canvas.py CiModuleControl.py Picon.py Pig.py \
-	FrontpanelLed.py ChannelNumber.py VideoSize.py NextEpgInfo.py
+	FrontpanelLed.py ChannelNumber.py VideoSize.py NextEpgInfo.py SingleEpgList.py
--- enigma2.org/lib/python/Components/Renderer/Progress.py
+++ enigma2/lib/python/Components/Renderer/Progress.py
@@ -13,23 +13,38 @@
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
 
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def getRange(self):
 		return (self.__start, self.__end)
--- enigma2.org/lib/python/Components/Renderer/SingleEpgList.py
+++ enigma2/lib/python/Components/Renderer/SingleEpgList.py
@@ -0,0 +1,39 @@
+from Components.VariableText import VariableText
+from enigma import eLabel, eEPGCache
+from Renderer import Renderer
+from time import localtime
+
+class SingleEpgList(Renderer, VariableText):
+	def __init__(self):
+		Renderer.__init__(self)
+		VariableText.__init__(self)
+		self.epgcache = eEPGCache.getInstance()
+
+	GUI_WIDGET = eLabel
+
+	def changed(self, what):
+		event = self.source.event
+
+		if event is None:
+			self.text = ""
+			return
+		service = self.source.service
+		text = ""
+		evt = None
+
+		if self.epgcache is not None:
+			evt = self.epgcache.lookupEvent(['IBDCT', (service.toString(), 0, -1, -1)])
+
+		if evt:
+			maxx = 0
+			for x in evt:
+				if maxx > 0:
+					if x[4]:
+						t = localtime(x[1])
+						text = text + "%02d:%02d %s\n" % (t[3], t[4], x[4])
+					else:
+						text = text + "n/a\n"
+				maxx += 1
+				if maxx > 4:
+					break
+		self.text = text
--- enigma2.org/lib/python/Components/UsageConfig.py
+++ enigma2/lib/python/Components/UsageConfig.py
@@ -269,7 +269,7 @@
 	SystemInfo["ATSC_priority_tuner_available"] = len(atsc_nims) > 3 and any(len(i) > 2 for i in (dvbs_nims, dvbc_nims, dvbt_nims))
 
 	config.misc.disable_background_scan = ConfigYesNo(default = False)
-	config.usage.show_event_progress_in_servicelist = ConfigSelection(default = 'barright', choices = [
+	config.usage.show_event_progress_in_servicelist = ConfigSelection(default = 'barleft', choices = [
 		('barleft', _("Progress bar left")),
 		('barright', _("Progress bar right")),
 		('percleft', _("Percentage left")),
--- enigma2.org/lib/python/Components/VolumeControl.py
+++ enigma2/lib/python/Components/VolumeControl.py
@@ -71,15 +71,27 @@
 
 	def volMute(self, showMuteSymbol=True, force=False):
 		vol = self.volctrl.getVolume()
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
 			if self.volctrl.isMuted():
 				if showMuteSymbol:
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<
 
 	def volMuteLong(self):
 		self.muteDialog.hide()
--- enigma2.org/lib/python/enigma_python.i
+++ enigma2/lib/python/enigma_python.i
@@ -110,6 +110,7 @@
 #include <lib/python/python.h>
 #include <lib/python/python_helpers.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -253,6 +254,7 @@
 %include <lib/python/pythonconfig.h>
 %include <lib/gdi/picload.h>
 %include <lib/dvb/streamserver.h>
+%include <lib/driver/vfd.h>
 /**************  eptr  **************/
 
 /**************  signals  **************/
--- enigma2.org/lib/python/Makefile.inc
+++ enigma2/lib/python/Makefile.inc
@@ -32,7 +32,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python/enigma_python.Pcpp@am__quote@
 
 .i.cpp:
-	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -O -nortti -nothreads -o $@ $<
+	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -D__sh__ -O -nortti -nothreads -o $@ $<
 	$(AM_V_at)mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Pcpp
 	$(AM_V_at)$(PYTHON) $(srcdir)/python/enigma_py_patcher.py python/enigma.py
 
--- enigma2.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
+++ enigma2/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
@@ -0,0 +1,2 @@
+
+
--- enigma2.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
+++ enigma2/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
--- enigma2.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
+++ enigma2/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
@@ -0,0 +1,317 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import *
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+
+import os
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+#config.plugins.CuberevoVFD.setDaylight = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.timeMode = ConfigSelection(default = "24h", choices = [("12h"),("24h")])
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+		self.list.append(getConfigListEntry(_("Time mode"), config.plugins.CuberevoVFD.timeMode))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+#		if config.plugins.CuberevoVFD.setDaylight.getValue():
+#			cubeVfd.enableDaylight()
+#		else:
+#			cubeVfd.disableDaylight()
+
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			cubeVfd.enableTimeMode()
+		else:
+			cubeVfd.disableTimeMode()
+
+		# enable/disable fan activity
+		if config.plugins.CuberevoVFD.setFan.getValue():
+			cubeVfd.enableFan()
+		else:
+			cubeVfd.disableFan()
+
+		# enable/disable led activity
+		if config.plugins.CuberevoVFD.setLed.getValue():
+			cubeVfd.enableLed()
+		else:
+			cubeVfd.disableLed()
+
+	# set the brightness
+		brightness = 3
+		if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+			brightness = 1
+		elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+			brightness = 7
+		evfd.getInstance().vfd_set_brightness(brightness)
+
+		configfile.save()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+		global showmenuorpanel
+		showmenuorpanel = False
+		self.showtimer = eTimer()
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		self.Console = Console()
+		self.tsEnabled = False
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			self.timeModeEnabled = 1
+		else:
+			self.timeModeEnabled = 0
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+
+	def handleTimer(self):
+		global showmenuorpanel
+		try:
+			from Plugins.Extensions.Aafpanel.plugin import inAAFPanel
+			showPanel = inAAFPanel
+		except:
+			#print '[CuberevoVFD] Error showPanel'
+			showPanel = None
+		try:
+			from Screens.Menu import inMenu
+			showMenu = inMenu
+		except:
+			#print '[CuberevoVFD] Error showMenu'
+			showMenu = None
+		if showMenu or showPanel:
+			self.showtimer.start(4000, True)
+		self.showtimer.callback.append(self.setshowmenuorpanel)
+		if not showMenu and not showPanel and showmenuorpanel is True:
+			showmenuorpanel = False
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename =subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+				evfd.getInstance().vfd_write_string(servicename[0:17])
+
+	def setshowmenuorpanel(self):
+		global showmenuorpanel
+		showmenuorpanel = True
+		self.showtimer.stop()
+
+	def enableClock(self):
+		self.clockEnabled = True
+		try:
+			os.popen("/bin/fp_control -dt 1")
+		except OSError:
+			print "no memory"
+
+	def disableClock(self):
+		self.clockEnabled = False
+		try:
+			os.popen("/bin/fp_control -dt 0")
+		except OSError:
+			print "no memory"
+
+	def enableTimeMode(self):
+		self.timeModeEnabled = 1
+		try:
+			os.popen("/bin/fp_control -tm 1")
+		except OSError:
+			print "no memory"
+
+	def disableTimeMode(self):
+		self.timeModeEnabled = 0
+		try:
+			os.popen("/bin/fp_control -tm 0")
+		except OSError:
+			print "no memory"
+
+	def enableLed(self):
+		self.ledEnabled = True
+		try:
+			os.popen("/bin/fp_control -l 0 1")
+		except OSError:
+			print "no memory"
+
+	def disableLed(self):
+		self.ledEnabled = False
+		try:
+			os.popen("/bin/fp_control -l 0 0")
+		except OSError:
+			print "no memory"
+
+	def enableFan(self):
+		self.fanEnabled = True
+		try:
+			os.popen("/bin/fp_control -sf 1")
+		except OSError:
+			print "no memory"
+
+	def disableFan(self):
+		self.fanEnabled = False
+		try:
+			os.popen("/bin/fp_control -sf 0")
+		except OSError:
+			print "no memory"
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		if tmp:
+			print "[Timeshift enabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			print "[Timeshift disabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+		self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
--- enigma2.org/lib/python/Plugins/Extensions/Makefile.am
+++ enigma2/lib/python/Plugins/Extensions/Makefile.am
@@ -1,6 +1,14 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
+
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
--- enigma2.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
+++ enigma2/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
@@ -0,0 +1,2 @@
+
+
--- enigma2.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
+++ enigma2/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
--- enigma2.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
+++ enigma2/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
@@ -0,0 +1,458 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+	getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+from Components.UsageConfig import defaultMoviePath
+from os import statvfs
+import array
+
+my_global_session = None
+debug = False
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 10, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioBootReason = 0x40003a0b
+ioOffFlush = struct.pack('LLB', 0x2, 0x0, 0x6)
+ioRec1Flush = struct.pack('LLB', 0x1000, 0x0, 0x6)
+ioRec2Flush = struct.pack('LLB', 0x2000, 0x0, 0x6)
+ioRecBothFlush = struct.pack('LLB', 0x3000, 0x0, 0x6)
+ioClockFlush = struct.pack('LLB', 0x20, 0x0, 0x6)
+ioClockOff = struct.pack('LLB', 0x20, 0x0, 0x0)
+ioHddClear =    struct.pack('LLB', 0x0, 0xff8000,0x0)
+ioHddUsage = (  struct.pack('LLB', 0x0, 0x006000,0xf),  # HDD empty
+                struct.pack('LLB', 0x0, 0x00e000,0xf),
+                struct.pack('LLB', 0x0, 0x01e000,0xf),
+                struct.pack('LLB', 0x0, 0x03e000,0xf),
+                struct.pack('LLB', 0x0, 0x07e000,0xf),
+                struct.pack('LLB', 0x0, 0x0fe000,0xf),
+                struct.pack('LLB', 0x0, 0x1fe000,0xf),
+                struct.pack('LLB', 0x0, 0x3fe000,0xf),
+                struct.pack('LLB', 0x0, 0x7fe000,0xf))  # HDD full
+ioHddFull = struct.pack('LLB', 0x0, 0x800000,0x6)       # "HDD full" flashing
+hddCheckPeriod = 60 # check every 60 seconds
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+		self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+		self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+		self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+		self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+		self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+		self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+		self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+			}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+		tfVfd.setValues()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class TopfieldVFD:
+	def __init__(self, session):
+		#print "TopfieldVFD initializing"
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+		{
+			iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+			iPlayableService.evStart: self.__evStart,
+		})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.Console = Console()
+		self.tsEnabled = False
+		self.recNum = 0
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.txCount = 0
+		self.clock = 0
+		self.valuesSet = 0
+		self.hddUsed = 10 # initialize with an invalid value
+		self.hddCheckCounter = hddCheckPeriod
+		self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+		self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+		self.setValues()
+
+	def setValues(self):
+		#print "\nTopfiledVFD.setValues()\n"
+		if config.plugins.TopfieldVFD.showClock.value:
+			self.enableClock()
+		else:
+			self.disableClock()
+
+		# enable/disable displaying Ethernet activity
+		if config.plugins.TopfieldVFD.showEthernet.getValue():
+			self.enableEthernet()
+		else:
+			self.disableEthernet()
+
+		try:
+			fd = open("/dev/fpc")
+
+			# set the brightness
+			brightness = 3
+			if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+				brightness = 1
+			elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+				brightness = 5
+			fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+
+			# set the the scroll mode
+			if config.plugins.TopfieldVFD.scroll.value == "once":
+				scrollMode = 1
+			elif config.plugins.TopfieldVFD.scroll.value == "always":
+				scrollMode = 2
+			else: # set to never by default
+				scrollMode = 0
+			scrollOpts = struct.pack('BBB', scrollMode,
+						int(config.plugins.TopfieldVFD.scrollPause.value),
+						int(config.plugins.TopfieldVFD.scrollDelay.value))
+			fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+
+			# set the typematic values
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+
+			# set the IR filters
+			if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+			elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+			else: # enable both by default
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+			# set the allcaps parameter
+			if config.plugins.TopfieldVFD.allCaps.value:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+			else:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+			buf = array.array('h', [0])
+			fcntl.ioctl(fd.fileno(),ioBootReason,buf,1)
+			if buf[0] == 2:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioOffFlush)
+
+			fd.close()
+			self.valuesSet = 1
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: setValues ", e
+
+	def enableEthernet(self):
+		self.ethEnabled = True
+
+	def disableEthernet(self):
+		self.ethEnabled = False
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableEthernet ", e
+
+	def enableClock(self):
+		self.clockEnabled = True
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: enableClock ", e
+
+	def disableClock(self):
+		self.clockEnabled = False
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+			fd.close()
+			open("/dev/fpsmall", "w").write("     ")
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableClock ", e
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def displayHddUsed(self):
+		if debug:
+			print "TopfieldVFD: determine HDD usage"
+
+		# determine the HDD usage
+		used = 0;
+		try:
+			f = statvfs(defaultMoviePath())
+			# there are 8 HDD segments in the VFD
+			used = (f.f_blocks - f.f_bavail) * 8 / f.f_blocks
+		except:
+			used = 0;
+
+		if self.hddUsed != used:
+			try:
+				fd = open("/dev/fpc")
+				if self.hddUsed > used:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddClear)
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddUsage[used])
+				if used == 8:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddFull)
+				fd.close();
+			except IOError,e:
+				self.hddUsed = used # dummy operation
+			self.hddUsed = used
+
+	def handleTimer(self):
+		#print "[ TopfieldVFD timer ]"
+		if self.valuesSet == 0:
+			self.setValues()
+
+		if self.clockEnabled:
+			clock = strftime("%k%M",localtime(time()))
+			if clock != self.clock:
+				self.clock = clock
+				try:
+					open("/dev/fpsmall", "w").write(clock + "\0")
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (clock) ", e
+
+		# check HDD periodically
+		if self.hddCheckCounter < hddCheckPeriod:
+			self.hddCheckCounter += 1
+		else:
+			self.hddCheckCounter = 0
+			self.displayHddUsed()
+
+		if self.ethEnabled == False:
+			return
+
+		result = open("/proc/net/dev").readlines()
+		numRegExp = "[0-9]+"
+		numPattern = re_compile(numRegExp)
+		txPattern = re_compile("eth0:[ ]*" + numRegExp)
+		for item in result:
+			tmp = self.regExpMatch(txPattern, item)
+			if tmp != None:
+				tmp = tmp[5:].lstrip()
+				try:
+					fd = open("/dev/fpc")
+					if self.txCount != tmp:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+						self.txCount = tmp
+					else:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+					fd.close()
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (Ethernet) ", e
+					break
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if tmp:
+				print "[Timeshift enabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+			else:
+				print "[Timeshift disabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: __evSeekableStatusChanged ", e
+			self.tsEnabled = tmp
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs == self.recNum:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if config.usage.blinking_display_clock_during_recording.value:
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1Flush)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+			else:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: gotRecordEvent ", e
+		self.recNum = nrecs
+
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "TopfieldVFD aborting"
+
+def main(session, **kwargs):
+	session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+	global tfVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and tfVfd == None:
+		print "Starting TopfieldVFD"
+		tfVfd = TopfieldVFD(mySession)
+	elif gReason == 1 and tfVfd != None:
+		print "Stopping TopfieldVFD"
+		tfVfd.disableClock()
+		tfVfd = None
+
+def autostart(reason, **kwargs):
+	global tfVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlTfVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
--- enigma2.org/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
@@ -144,7 +144,7 @@
 
 def Plugins(**kwargs):
 	from os import path
-	if path.exists("/dev/hdmi_cec") or path.exists("/dev/misc/hdmi_cec0"):
+	if path.exists("/dev/hdmi_cec") or path.exists("/lib/modules/cec.ko"):
 		import Components.HdmiCec
 		from Plugins.Plugin import PluginDescriptor
 		return [PluginDescriptor(where = PluginDescriptor.WHERE_MENU, fnc = startSetup)]
--- enigma2.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
@@ -19,6 +19,8 @@
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
+	if physdevpath == "-":
+		physdevpath = None
 	media_state = v.get("X_E2_MEDIA_STATUS")
 	global audiocd
 
--- enigma2.org/lib/python/Plugins/SystemPlugins/Makefile.am
+++ enigma2/lib/python/Plugins/SystemPlugins/Makefile.am
@@ -2,9 +2,9 @@
 
 SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SkinSelector SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	DefaultServicesScanner DiseqcTester \
 	CableScan FastScan OSDPositionSetup OSD3DSetup HdmiCEC VideoClippingSetup \
-	VideoEnhancement WirelessLan NetworkWizard
+	VideoEnhancement WirelessLan NetworkWizard VFD-Icons
 
 if HAVE_TEMPFANCONTROL
 SUBDIRS += TempFanControl
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
@@ -0,0 +1,2 @@
+
+
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_vfd-icons.xml
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
@@ -0,0 +1,20 @@
+<default>
+	<prerequisites>
+		<hardware type="dm8000" />
+		<tag type="System" />
+	</prerequisites>
+	<info>
+		<author>Team Ducktales</author>
+		<name>VFD-Icons</name>
+		<packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		<packagetype>public</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+		<shortdescription>Displays text on vfd</shortdescription>
+		<description>Displays text on vfd.
+		</description>
+	</info>
+
+	<files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-vfd-icons" />
+	</files>
+
+</default>
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
@@ -0,0 +1,152 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()
+
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,True)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,False)
+
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,False)
+
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,False)
+
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,True)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,False)
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,False)
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
@@ -68,6 +68,9 @@
 				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the screen resolution in PC output mode.")))
 			else:
 				self.list.append(getConfigListEntry(_("Refresh rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the refresh rate of the screen.")))
+#+++>
+		self.list.append(getConfigListEntry(_("3D Mode"), config.av.threedmode))
+#+++<
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
@@ -91,6 +94,14 @@
 
 #		if config.av.videoport.value == "DVI":
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
 			if level >= 1:
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
+++ enigma2/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
@@ -13,67 +13,36 @@
 
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":	{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
-
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
-
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
-
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
-
-	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" },
-								"multi (50/60/24p)": {50: "720p50", 60: "720p", 24: "720p24" } }
+	rates["PAL"] =			{ "50Hz":	{ 50: "pal" } }
+
+	rates["576i"] =			{ "50Hz":	{ 50: "576i50" } }
+
+	rates["576p"] =			{ "50Hz":	{ 50: "576p50" } }
+
+	rates["720p"] =			{ "50Hz":	{ 50: "720p50" },
+								"60Hz":	{ 60: "720p60" } }
 
 	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" },
-								"multi (50/60/24p)": {50: "1080i50", 60: "1080i", 24: "1080p24" } }
-
-	rates["1080p"] =		{ "50Hz":	{ 50: "1080p50" },
-								"60Hz":		{ 60: "1080p" },
-								"multi":	{ 50: "1080p50", 60: "1080p" },
-								"multi (50/60/24p)": {50: "1080p50", 60: "1080p", 24: "1080p24" } }
-
-	rates["2160p30"] =		{ "25Hz":	{ 50: "2160p25" },
-								"30Hz":		{ 60: "2160p30" },
-								"multi": { 50: "2160p25", 60: "2160p30" },
-								"multi (25/30/24p)": { 50: "2160p25", 60: "2160p30", 24: "2160p24" } }
-
-	rates["2160p"] =		{ "50Hz":	{ 50: "2160p50" },
-								"60Hz":		{ 60: "2160p" },
-								"multi":	{ 50: "2160p50", 60: "2160p" }, 
-								"multi (50/60/24p)": {50: "2160p50", 60: "2160p", 24: "2160p24" }}
+								"60Hz":	{ 60: "1080i60" } }
+
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+								"24Hz":	{ 60: "1080p24" },
+								"25Hz":	{ 60: "1080p25" },
+								"29Hz":	{ 60: "1080p29" },
+								"30Hz":	{ 60: "1080p30" },
+								"50Hz":	{ 60: "1080p50" },
+								"60Hz":	{ 60: "1080p60" } }
 
 	rates["PC"] = {
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768"  : { 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : { 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200" : { 60: "1600x1200_60" }, #60 66 76
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080p", "2160p", "2160p30", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI-PC"] = ["PC"]
 
 	def getOutputAspect(self):
 		ret = (16,9)
@@ -111,7 +80,7 @@
 
 		self.readAvailableModes()
 		self.is24hzAvailable()
-		self.widescreen_modes = set(["720p", "1080i", "1080p", "2160p", "2160p30"]).intersection(*[self.modes_available])
+		self.widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"]).intersection(*[self.modes_available])
 
 		if "DVI-PC" in self.modes and not self.getModeList("DVI-PC"):
 			print "[VideoHardware] remove DVI-PC because of not existing modes"
@@ -130,6 +99,16 @@
 		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
+#+++<
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -168,6 +147,8 @@
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
+			if port == "HDMI-PC":
+				return True
 			if mode not in self.modes_available:
 				return False
 		return True
@@ -215,8 +196,12 @@
 				open("/proc/stb/video/videomode_24hz", "w").write(mode_24)
 			except IOError:
 				print "[VideoHardware] cannot open /proc/stb/video/videomode_24hz"
+		#call setResolution() with -1,-1 to read the new screen dimensions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
 
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "[VideoHardware] saveMode", port, mode, rate
@@ -234,7 +219,8 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -341,7 +327,7 @@
 				aspect = "16:9"
 			else:
 				aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-			policy_choices = {"pillarbox": "panscan", "panscan": "letterbox", "nonlinear": "nonlinear", "scale": "bestfit", "auto": "bestfit"}
+			policy_choices = {"pillarbox": "letterbox", "panscan": "panscan", "nonlinear": "nonlinear", "scale": "bestfit", "auto": "bestfit"}
 			policy = policy_choices[config.av.policy_43.value]
 			policy2_choices = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit", "auto": "bestfit"}
 			policy2 = policy2_choices[config.av.policy_169.value]
@@ -366,6 +352,33 @@
 		except IOError:
 			pass
 
+#+++>
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+#+++<
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
--- enigma2.org/lib/python/Components/AVSwitch.py
+++ enigma2/lib/python/Components/AVSwitch.py
@@ -76,11 +76,11 @@
 	config.av.colorformat = ConfigSelection(choices=colorformat_choices, default="rgb")
 	config.av.aspectratio = ConfigSelection(choices={
 			"4_3_letterbox": _("4:3 Letterbox"),
-			"4_3_panscan": _("4:3 PanScan"),
+			"4_3_panscan": _("4:3 Zoom"),
 			"16_9": _("16:9"),
 			"16_9_always": _("16:9 always"),
			"16_10_letterbox": _("16:10 Letterbox"),
-			"16_10_panscan": _("16:10 PanScan"),
+			"16_10_panscan": _("16:10 Zoom"),
 			"16_9_letterbox": _("16:9 Letterbox")},
 			default = "16_9")
 	config.av.aspect = ConfigSelection(choices={
@@ -92,10 +92,10 @@
 	policy2_choices = {
 	# TRANSLATORS: (aspect ratio policy: black bars on top/bottom) in doubt, keep english term.
 	"letterbox": _("Letterbox"),
-	# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
-	"panscan": _("Pan&scan"),
+	# TRANSLATORS: (aspect ratio policy: cropped content on top/bottom) in doubt, keep english term
+	"panscan": _("Zoom"),
 	# TRANSLATORS: (aspect ratio policy: display as fullscreen, even if this breaks the aspect)
-	"scale": _("Just scale")}
+	"scale": _("Stretch")}
 	try:
 		if "auto" in open("/proc/stb/video/policy2_choices").read():
 			# TRANSLATORS: (aspect ratio policy: always try to display as fullscreen, when there is no content (black bars) on left/right, even if this breaks the aspect.
@@ -107,20 +107,20 @@
 	# TRANSLATORS: (aspect ratio policy: black bars on left/right) in doubt, keep english term.
 	"pillarbox": _("Pillarbox"),
 	# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
-	"panscan": _("Pan&scan"),
+	"panscan": _("Zoom"),
 	# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching the left/right)
-	"nonlinear": _("Nonlinear"),
+	"nonlinear": _("Panoramic"),
 	# TRANSLATORS: (aspect ratio policy: display as fullscreen, even if this breaks the aspect)
-	"scale": _("Just scale")}
+	"scale": _("Stretch")}
 	try:
 		if "auto" in open("/proc/stb/video/policy_choices").read():
 			# TRANSLATORS: (aspect ratio policy: always try to display as fullscreen, when there is no content (black bars) on left/right, even if this breaks the aspect.
 			policy_choices.update({"auto": _("Auto")})
 	except:
 		pass
	config.av.policy_43 = ConfigSelection(choices=policy_choices, default = "pillarbox")
-	config.av.tvsystem = ConfigSelection(choices = {"pal": _("PAL"), "ntsc": _("NTSC"), "multinorm": _("multinorm")}, default="pal")
-	config.av.wss = ConfigEnableDisable(default = True)
+	config.av.tvsystem = ConfigSelection(choices = {"pal": _("PAL"), "ntsc": _("NTSC"), "multinorm": _("Multinorm")}, default="multinorm")
+	config.av.wss = ConfigEnableDisable(default = False)
 	config.av.generalAC3delay = ConfigSelectionNumber(-1000, 1000, 5, default = 0)
 	config.av.generalPCMdelay = ConfigSelectionNumber(-1000, 1000, 5, default = 0)
 	config.av.vcrswitch = ConfigEnableDisable(default = False)
--- enigma2.org/lib/python/Screens/ChannelSelection.py
+++ enigma2/lib/python/Screens/ChannelSelection.py
@@ -5,6 +5,11 @@
 import Components.ParentalControl
 from Components.Button import Button
 from Components.ServiceList import ServiceList, refreshServiceList
+#+++>
+from Components.Sources.StaticText import StaticText
+from Components.Label import Label
+from os import path as os_path, system, unlink
+#+++<
 from Components.ActionMap import NumberActionMap, ActionMap, HelpableActionMap
 from Components.MenuList import MenuList
 from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
@@ -152,7 +157,7 @@
 		self.parentalControl = parentalControl
 		self.parentalControlEnabled = config.ParentalControl.servicepin[0].value and config.ParentalControl.servicepinactive.value
 		if not (current_sel_path or current_sel_flags & (eServiceReference.isDirectory|eServiceReference.isMarker)) or current_sel_flags & eServiceReference.isGroup:
-			append_when_current_valid(current, menu, (_("show transponder info"), self.showServiceInformations), level=2)
+			append_when_current_valid(current, menu, (_("Show transponder info"), self.showServiceInformations), level=2)
 		if csel.bouquet_mark_edit == OFF and not csel.entry_marked:
 			if not inBouquetRootList:
 				isPlayable = not (current_sel_flags & (eServiceReference.isMarker|eServiceReference.isDirectory))
@@ -160,17 +165,17 @@
 					for p in plugins.getPlugins(PluginDescriptor.WHERE_CHANNEL_CONTEXT_MENU):
 						append_when_current_valid(current, menu, (p.name, boundFunction(self.runPlugin, p)), key="bullet")
 					if config.servicelist.startupservice.value == current.toString():
-						append_when_current_valid(current, menu, (_("stop using as startup service"), self.unsetStartupService), level=0)
+						append_when_current_valid(current, menu, (_("Stop using as startup service"), self.unsetStartupService), level=0)
 					else:
-						append_when_current_valid(current, menu, (_("set as startup service"), self.setStartupService), level=0)
+						append_when_current_valid(current, menu, (_("Set as startup service"), self.setStartupService), level=0)
 					if self.parentalControlEnabled:
 						if self.parentalControl.getProtectionLevel(current.toCompareString()) == -1:
-							append_when_current_valid(current, menu, (_("add to parental protection"), boundFunction(self.addParentalProtection, current)), level=0)
+							append_when_current_valid(current, menu, (_("Add to parental protection"), boundFunction(self.addParentalProtection, current)), level=0)
 						else:
 							if self.parentalControl.isServiceProtectionBouquet(current.toCompareString()):
-								append_when_current_valid(current, menu, (_("service is in bouquet parental protection"), self.cancelClick), level=0)
+								append_when_current_valid(current, menu, (_("Service is in bouquet parental protection"), self.cancelClick), level=0)
 							else:
-								append_when_current_valid(current, menu, (_("remove from parental protection"), boundFunction(self.removeParentalProtection, current)), level=0)
+								append_when_current_valid(current, menu, (_("Remove from parental protection"), boundFunction(self.removeParentalProtection, current)), level=0)
 						if config.ParentalControl.hideBlacklist.value and not parentalControl.sessionPinCached and config.ParentalControl.storeservicepin.value != "never":
 							append_when_current_valid(current, menu, (_("Unhide parental control services"), self.unhideParentalServices), level=0, key="1")
 					if SystemInfo["3DMode"] and  fileExists("/usr/lib/enigma2/python/Plugins/SystemPlugins/OSD3DSetup/plugin.py"):
@@ -190,93 +195,93 @@
 						else:
 							bouquetCnt = len(bouquets)
 						if not self.inBouquet or bouquetCnt > 1:
-							append_when_current_valid(current, menu, (_("add service to bouquet"), self.addServiceToBouquetSelected), level=0, key="5")
+							append_when_current_valid(current, menu, (_("Add service to bouquet"), self.addServiceToBouquetSelected), level=0, key="5")
 							self.addFunction = self.addServiceToBouquetSelected
 						if not self.inBouquet:
-							append_when_current_valid(current, menu, (_("remove entry"), self.removeEntry), level = 0, key="8")
+							append_when_current_valid(current, menu, (_("Remove entry"), self.removeEntry), level = 0, key="8")
 							self.removeFunction = self.removeSatelliteService
 					else:
 						if not self.inBouquet:
-							append_when_current_valid(current, menu, (_("add service to favourites"), self.addServiceToBouquetSelected), level=0, key="5")
+							append_when_current_valid(current, menu, (_("Add service to favourites"), self.addServiceToBouquetSelected), level=0, key="5")
 							self.addFunction = self.addServiceToBouquetSelected
 					if SystemInfo["PIPAvailable"]:
 						if not self.parentalControlEnabled or self.parentalControl.getProtectionLevel(current.toCompareString()) == -1:
 							if self.csel.dopipzap:
-								append_when_current_valid(current, menu, (_("play in mainwindow"), self.playMain), level=0, key="red")
+								append_when_current_valid(current, menu, (_("Play in mainwindow"), self.playMain), level=0, key="red")
 							else:
-								append_when_current_valid(current, menu, (_("play as picture in picture"), self.showServiceInPiP), level=0, key="blue")
-					append_when_current_valid(current, menu, (_("find currently played service"), self.findCurrentlyPlayed), level=0, key="3")
+								append_when_current_valid(current, menu, (_("Play as picture in picture"), self.showServiceInPiP), level=0, key="blue")
+					append_when_current_valid(current, menu, (_("Find currently played service"), self.findCurrentlyPlayed), level=0, key="3")
 				else:
 					if 'FROM SATELLITES' in current_root.getPath() and current and _("Services") in eServiceCenter.getInstance().info(current).getName(current):
 						unsigned_orbpos = current.getUnsignedData(4) >> 16
 						if unsigned_orbpos == 0xFFFF:
-							append_when_current_valid(current, menu, (_("remove cable services"), self.removeSatelliteServices), level = 0)
+							append_when_current_valid(current, menu, (_("Remove cable services"), self.removeSatelliteServices), level = 0)
 						elif unsigned_orbpos == 0xEEEE:
-							append_when_current_valid(current, menu, (_("remove terrestrial services"), self.removeSatelliteServices), level = 0)
+							append_when_current_valid(current, menu, (_("Remove terrestrial services"), self.removeSatelliteServices), level = 0)
 						else:
-							append_when_current_valid(current, menu, (_("remove selected satellite"), self.removeSatelliteServices), level = 0)
+							append_when_current_valid(current, menu, (_("Remove selected satellite"), self.removeSatelliteServices), level = 0)
 					if haveBouquets:
 						if not self.inBouquet and not "PROVIDERS" in current_sel_path:
-							append_when_current_valid(current, menu, (_("copy to bouquets"), self.copyCurrentToBouquetList), level=0)
+							append_when_current_valid(current, menu, (_("Copy to bouquets"), self.copyCurrentToBouquetList), level=0)
 					if ("flags == %d" %(FLAG_SERVICE_NEW_FOUND)) in current_sel_path:
-						append_when_current_valid(current, menu, (_("remove all new found flags"), self.removeAllNewFoundFlags), level=0)
+						append_when_current_valid(current, menu, (_("Remove all new found flags"), self.removeAllNewFoundFlags), level=0)
 				if self.inBouquet:
-					append_when_current_valid(current, menu, (_("rename entry"), self.renameEntry), level=0, key="2")
+					append_when_current_valid(current, menu, (_("Rename entry"), self.renameEntry), level=0, key="2")
 					if not inAlternativeList:
-						append_when_current_valid(current, menu, (_("remove entry"), self.removeEntry), level=0, key="8")
+						append_when_current_valid(current, menu, (_("Remove entry"), self.removeEntry), level=0, key="8")
 						self.removeFunction = self.removeCurrentService
 				if current_root and ("flags == %d" %(FLAG_SERVICE_NEW_FOUND)) in current_root.getPath():
-					append_when_current_valid(current, menu, (_("remove new found flag"), self.removeNewFoundFlag), level=0)
+					append_when_current_valid(current, menu, (_("Remove new found flag"), self.removeNewFoundFlag), level=0)
 			else:
 					if self.parentalControlEnabled:
 						if self.parentalControl.getProtectionLevel(current.toCompareString()) == -1:
-							append_when_current_valid(current, menu, (_("add bouquet to parental protection"), boundFunction(self.addParentalProtection, current)), level=0)
+							append_when_current_valid(current, menu, (_("Add bouquet to parental protection"), boundFunction(self.addParentalProtection, current)), level=0)
 						else:
-							append_when_current_valid(current, menu, (_("remove bouquet from parental protection"), boundFunction(self.removeParentalProtection, current)), level=0)
+							append_when_current_valid(current, menu, (_("Remove bouquet from parental protection"), boundFunction(self.removeParentalProtection, current)), level=0)
 					menu.append(ChoiceEntryComponent(text=(_("add bouquet"), self.showBouquetInputBox)))
-					append_when_current_valid(current, menu, (_("rename entry"), self.renameEntry), level=0, key="2")
-					append_when_current_valid(current, menu, (_("remove entry"), self.removeEntry), level=0, key="8")
+					append_when_current_valid(current, menu, (_("Rename entry"), self.renameEntry), level=0, key="2")
+					append_when_current_valid(current, menu, (_("Remove entry"), self.removeEntry), level=0, key="8")
 					self.removeFunction = self.removeBouquet
 					if removed_userbouquets_available():
-						append_when_current_valid(current, menu, (_("purge deleted userbouquets"), self.purgeDeletedBouquets), level=0)
-						append_when_current_valid(current, menu, (_("restore deleted userbouquets"), self.restoreDeletedBouquets), level=0)
+						append_when_current_valid(current, menu, (_("Purge deleted userbouquets"), self.purgeDeletedBouquets), level=0)
+						append_when_current_valid(current, menu, (_("Restore deleted userbouquets"), self.restoreDeletedBouquets), level=0)
 		if self.inBouquet: # current list is editable?
 			if csel.bouquet_mark_edit == OFF:
 				if csel.movemode:
-					append_when_current_valid(current, menu, (_("disable move mode"), self.toggleMoveMode), level=0, key="6")
+					append_when_current_valid(current, menu, (_("Disable move mode"), self.toggleMoveMode), level=0, key="6")
 				else:
-					append_when_current_valid(current, menu, (_("enable move mode"), self.toggleMoveMode), level=1, key="6")
+					append_when_current_valid(current, menu, (_("Enable move mode"), self.toggleMoveMode), level=1, key="6")
 				if not csel.entry_marked and not inBouquetRootList and current_root and not (current_root.flags & eServiceReference.isGroup):
 					if current.type != -1:
-						menu.append(ChoiceEntryComponent(text=(_("add marker"), self.showMarkerInputBox)))
+						menu.append(ChoiceEntryComponent(text=(_("Add marker"), self.showMarkerInputBox)))
 					if not csel.movemode:
 						if haveBouquets:
-							append_when_current_valid(current, menu, (_("enable bouquet edit"), self.bouquetMarkStart), level=0)
+							append_when_current_valid(current, menu, (_("Enable bouquet edit"), self.bouquetMarkStart), level=0)
 						else:
-							append_when_current_valid(current, menu, (_("enable favourite edit"), self.bouquetMarkStart), level=0)
+							append_when_current_valid(current, menu, (_("Enable favourite edit"), self.bouquetMarkStart), level=0)
 					if current_sel_flags & eServiceReference.isGroup:
-						append_when_current_valid(current, menu, (_("edit alternatives"), self.editAlternativeServices), level=2)
-						append_when_current_valid(current, menu, (_("show alternatives"), self.showAlternativeServices), level=2)
-						append_when_current_valid(current, menu, (_("remove all alternatives"), self.removeAlternativeServices), level=2)
+						append_when_current_valid(current, menu, (_("Edit alternatives"), self.editAlternativeServices), level=2)
+						append_when_current_valid(current, menu, (_("Show alternatives"), self.showAlternativeServices), level=2)
+						append_when_current_valid(current, menu, (_("Remove all alternatives"), self.removeAlternativeServices), level=2)
 					elif not current_sel_flags & eServiceReference.isMarker:
-						append_when_current_valid(current, menu, (_("add alternatives"), self.addAlternativeServices), level=2)
+						append_when_current_valid(current, menu, (_("Add alternatives"), self.addAlternativeServices), level=2)
 			else:
 				if csel.bouquet_mark_edit == EDIT_BOUQUET:
 					if haveBouquets:
-						append_when_current_valid(current, menu, (_("end bouquet edit"), self.bouquetMarkEnd), level=0)
-						append_when_current_valid(current, menu, (_("abort bouquet edit"), self.bouquetMarkAbort), level=0)
+						append_when_current_valid(current, menu, (_("End bouquet edit"), self.bouquetMarkEnd), level=0)
+						append_when_current_valid(current, menu, (_("Abort bouquet edit"), self.bouquetMarkAbort), level=0)
 					else:
-						append_when_current_valid(current, menu, (_("end favourites edit"), self.bouquetMarkEnd), level=0)
-						append_when_current_valid(current, menu, (_("abort favourites edit"), self.bouquetMarkAbort), level=0)
+						append_when_current_valid(current, menu, (_("End favourites edit"), self.bouquetMarkEnd), level=0)
+						append_when_current_valid(current, menu, (_("Abort favourites edit"), self.bouquetMarkAbort), level=0)
 					if current_sel_flags & eServiceReference.isMarker:
-						append_when_current_valid(current, menu, (_("rename entry"), self.renameEntry), level=0, key="2")
-						append_when_current_valid(current, menu, (_("remove entry"), self.removeEntry), level=0, key="8")
+						append_when_current_valid(current, menu, (_("Rename entry"), self.renameEntry), level=0, key="2")
+						append_when_current_valid(current, menu, (_("Remove entry"), self.removeEntry), level=0, key="8")
 						self.removeFunction = self.removeCurrentService
 				else:
-					append_when_current_valid(current, menu, (_("end alternatives edit"), self.bouquetMarkEnd), level=0)
-					append_when_current_valid(current, menu, (_("abort alternatives edit"), self.bouquetMarkAbort), level=0)
-
-		menu.append(ChoiceEntryComponent("menu", (_("Configuration..."), self.openSetup)))
+					append_when_current_valid(current, menu, (_("End alternatives edit"), self.bouquetMarkEnd), level=0)
+					append_when_current_valid(current, menu, (_("Abort alternatives edit"), self.bouquetMarkAbort), level=0)
+
+		menu.append(ChoiceEntryComponent("menu", (_("Configuration"), self.openSetup)))
 		self["menu"] = ChoiceList(menu)
 
 	def set3DMode(self, value):
@@ -834,6 +839,9 @@
 		self.saved_title = None
 		self.saved_root = None
 		self.current_ref = None
+#+++>
+		self["title"] = StaticText()
+#+++<
 		self.editMode = False
 		self.confirmRemove = True
 
@@ -941,7 +949,7 @@
 				if mutableAlternatives:
 					mutableAlternatives.setListName(name)
 					if mutableAlternatives.addService(cur_service.ref):
-						print "add", cur_service.ref.toString(), "to new alternatives failed"
+						print "Adding", cur_service.ref.toString(), "to new alternatives failed"
 					mutableAlternatives.flushChanges()
 					self.servicelist.addService(new_ref.ref, True)
 					self.servicelist.removeCurrent()
@@ -952,7 +960,7 @@
 					if self.startServiceRef and cur_service.ref == self.startServiceRef:
 						self.startServiceRef = new_ref.ref
 				else:
-					print "get mutable list for new created alternatives failed"
+					print "Get mutable list for new created alternatives failed"
 			else:
 				print "add", str, "to", cur_root.getServiceName(), "failed"
 		else:
@@ -973,10 +981,10 @@
 					if services is not None:
 						for service in services:
 							if mutableBouquet.addService(service):
-								print "add", service.toString(), "to new bouquet failed"
+								print "Adding", service.toString(), "to new bouquet failed"
 					mutableBouquet.flushChanges()
 				else:
-					print "get mutable list for new created bouquet failed"
+					print "Get mutable list for newly created bouquet failed"
 				# do some voodoo to check if current_root is equal to bouquet_root
 				cur_root = self.getRoot();
 				str1 = cur_root and cur_root.toString()
@@ -986,9 +994,9 @@
 					self.servicelist.addService(new_bouquet_ref)
 					self.servicelist.resetRoot()
 			else:
-				print "add", str, "to bouquets failed"
-		else:
-			print "bouquetlist is not editable"
+				print "Adding", str, "to bouquets failed"
+		else:
+			print "Bouquet list is not editable"
 
 	def copyCurrentToBouquetList(self):
 		provider = ServiceReference(self.getCurrentSelection())
@@ -1014,11 +1022,11 @@
 					if self.startServiceRef and cur_service.ref == self.startServiceRef:
 						self.startServiceRef = first_in_alternative
 				else:
-					print "couldn't add first alternative service to current root"
-			else:
-				print "couldn't edit current root!!"
-		else:
-			print "remove empty alternative list !!"
+					print "Could not add first alternative service to current root"
+			else:
+				print "Could not edit current root!!"
+		else:
+			print "Removing empty alternative list !!"
 		self.removeBouquet()
 		if not end:
 			self.servicelist.moveUp()
@@ -1100,6 +1108,9 @@
 			else:
 				new_title += ' ' + _("[favourite edit]")
 		self.setTitle(new_title)
+#+++>
+		self["title"].setText(new_title)
+#+++<
 		self.__marked = self.servicelist.getRootServices()
 		for x in self.__marked:
 			self.servicelist.addMarked(eServiceReference(x))
@@ -1127,6 +1138,9 @@
 		self.bouquet_mark_edit = OFF
 		self.mutableList = None
 		self.setTitle(self.saved_title)
+#+++>
+		self["title"].setText(self.saved_title)
+#+++<
 		self.saved_title = None
 		# self.servicePath is just a reference to servicePathTv or Radio...
 		# so we never ever do use the asignment operator in self.servicePath
@@ -1203,6 +1217,9 @@
 			self.mutableList.flushChanges() # FIXME add check if changes was made
 			self.mutableList = None
 			self.setTitle(self.saved_title)
+#+++>
+			self["title"].setText(self.saved_title)
+#+++<
 			self.saved_title = None
 			self.servicelist.resetRoot()
 			self.servicelist.l.setHideNumberMarker(config.usage.hide_number_markers.value)
@@ -1214,6 +1231,9 @@
 			self.saved_title = self.getTitle()
 			pos = self.saved_title.find(')')
 			self.setTitle(self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:])
+#+++>
+			self["title"].setText(self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:])
+#+++<
 			self.servicelist.l.setHideNumberMarker(False)
 			self.setCurrentSelection(self.servicelist.getCurrent())
 		self["Service"].editmode = True
@@ -1269,6 +1289,11 @@
 
 		self["list"] = ServiceList(self)
 		self.servicelist = self["list"]
+
+#+++>
+		self["boquet"] = Label(_("Channel Selection"))
+		self["title"] = StaticText()
+#+++<
 
 		self.numericalTextInput = NumericalTextInput(handleTimeout=False)
 		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
@@ -1362,6 +1387,9 @@
 			title = title[:pos]
 		title += _(" (TV)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRadioMode(self):
 		self.mode = MODE_RADIO
@@ -1373,6 +1401,9 @@
 			title = title[:pos]
 		title += _(" (Radio)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRoot(self, root, justSet=False):
 		if self.startRoot is None:
@@ -1427,6 +1458,9 @@
 					end_ref = None
 				nameStr = self.getServiceName(base_ref)
 				titleStr += ' - ' + nameStr
+#+++>
+				self["boquet"].setText("Channel Selection")
+#+++<
 				if end_ref is not None:
 					if Len > 2:
 						titleStr += '/../'
@@ -1434,7 +1468,13 @@
 						titleStr += '/'
 					nameStr = self.getServiceName(end_ref)
 					titleStr += nameStr
+#+++>
+					self["boquet"].setText(nameStr)
+#+++<
 				self.setTitle(titleStr)
+#+++>
+				self["title"].setText(titleStr)
+#+++<
 
 	def moveUp(self):
 		self.servicelist.moveUp()
--- enigma2.org/lib/python/Screens/InfoBarGenerics.py
+++ enigma2/lib/python/Screens/InfoBarGenerics.py
@@ -9,7 +9,7 @@
 from Components.PluginComponent import plugins
 from Components.ServiceEventTracker import ServiceEventTracker
 from Components.Sources.Boolean import Boolean
-from Components.config import config, ConfigBoolean, ConfigClock
+from Components.config import config, ConfigBoolean, ConfigClock, ConfigSubsection, ConfigYesNo
 from Components.SystemInfo import SystemInfo
 from Components.UsageConfig import preferredInstantRecordPath, defaultMoviePath
 from Components.VolumeControl import VolumeControl
@@ -37,6 +37,7 @@
 
 from Tools import Notifications, ASCIItranslit
 from Tools.Directories import fileExists, getRecordingFilename, moveFiles
+from Tools.Command import command
 
 from enigma import eTimer, eServiceCenter, eDVBServicePMTHandler, iServiceInformation, iPlayableService, eServiceReference, eEPGCache, eActionMap, getDesktop, eDVBDB
 
@@ -104,7 +105,7 @@
 	global resumePointCache, resumePointCacheLast
 	import cPickle
 	try:
-		f = open('/home/root/resumepoints.pkl', 'wb')
+		f = open('/etc/enigma2/resumepoints.pkl', 'wb')
 		cPickle.dump(resumePointCache, f, cPickle.HIGHEST_PROTOCOL)
 	except Exception, ex:
 		print "[InfoBar] Failed to write resumepoints:", ex
@@ -113,7 +114,7 @@
 def loadResumePoints():
 	import cPickle
 	try:
-		return cPickle.load(open('/home/root/resumepoints.pkl', 'rb'))
+		return cPickle.load(open('/etc/enigma2/resumepoints.pkl', 'rb'))
 	except Exception, ex:
 		print "[InfoBar] Failed to load resumepoints:", ex
 		return {}
@@ -225,6 +226,7 @@
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+	STATE_EPG = 4
 	FLAG_HIDE_VBI = 512
 
 	def __init__(self):
@@ -363,6 +365,12 @@
 		else:
 			self.toggleShow()
 
+	def epg(self):
+		self.__state = self.STATE_EPG
+		self.hide()
+		self.hideTimer.stop()
+		self.openEventView()
+
 	def toggleShow(self):
 		if self.__state == self.STATE_HIDDEN:
 			self.showFirstInfoBar()
@@ -377,7 +385,9 @@
 			self.show()
 			self.actualSecondInfoBarScreen.show()
 			self.startHideTimer()
-		else:
+		elif self.__state == self.STATE_SHOWN:
+			self.epg()
+		elif self.__state == self.STATE_EPG:
 			self.hide()
 			self.hideTimer.stop()
 
@@ -658,6 +668,20 @@
 				"historyNext": (self.historyNext, _("Switch to next channel in history")),
 				"keyChannelUp": (self.keyChannelUpCheck, self.getKeyChannelUpHelptext),
 				"keyChannelDown": (self.keyChannelDownCheck, self.getKeyChannelDownHelptext),
+#added
+				'aspectratio': (self.aspectratioSelection, 'Select aspect ratio'),
+				'sleepTimer': (self.sleepTimer, 'Sleeptimer'),
+				'timer': (self.timer, 'Timer'),
+				'showFavourites': (self.showFavourites, _('Bouquet list')),
+				"showSatellites": (self.showSatellites, _('Satellite list')),
+				"volumeUp": (self.volumeUp, _("Volume up")),
+				"volumeDown": (self.volumeDown, _("Volume Down")),
+#compatibility with older keymaps
+				"switchChannelUp": (self.keyUpCheck, self.getKeyUpHelptext),
+				"switchChannelDown": (self.keyDownCheck, self.getKeyDownHelpText),
+				"zapUp": (self.keyChannelDownCheck, self.getKeyChannelDownHelptext),
+				"zapDown": (self.keyChannelUpCheck, self.getKeyChannelUpHelptext),
+				"openServiceList": (self.openServiceList, _("Open service list"))
 			})
 
 	def showTvChannelList(self, zap=False):
@@ -822,6 +846,36 @@
 			self.servicelist.moveUp()
 		self.servicelist.zap(enable_pipzap = True)
 
+	def aspectratioSelection(self):
+		from Screens.AspectRatio import AspectRatio
+		self.session.open(AspectRatio)
+
+	def sleepTimer(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
+
+	def timer(self):
+		from Screens.TimerEdit import TimerEditList
+		self.session.open(TimerEditList)
+
+	def showFavourites(self):
+		self.servicelist.showFavourites()
+		self.session.execDialog(self.servicelist)
+
+	def showSatellites(self):
+		self.servicelist.showSatellites()
+		self.session.execDialog(self.servicelist)
+
+	def volumeUp(self):
+		from enigma import eDVBVolumecontrol
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def volumeDown(self):
+		from enigma import eDVBVolumecontrol
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+
 	def zapDown(self):
 		if self.servicelist.inBouquet():
 			prev = self.servicelist.getCurrentSelection()
@@ -856,7 +910,7 @@
 	def __init__(self):
 		self["MenuActions"] = HelpableActionMap(self, "InfobarMenuActions",
 			{
-				"mainMenu": (self.mainMenu, _("Enter main menu...")),
+				"mainMenu": (self.mainMenu, _("Enter main menu")),
 			})
 		self.session.infobar = None
 
@@ -971,7 +1025,7 @@
 
 		self["EPGActions"] = HelpableActionMap(self, "InfobarEPGActions",
 			{
-				"showEventInfo": (self.showDefaultEPG, _("Show EPG...")),
+				"showEventInfo": (self.showDefaultEPG, _("Show EPG")),
 				"showEventInfoSingleEPG": (self.showSingleEPG, _("Show single service EPG")),
 				"showEventInfoMultiEPG": (self.showMultiEPG, _("Show multi channel EPG")),
 				"showInfobarOrEpgWhenInfobarAlreadyVisible": self.showEventInfoWhenNotVisible,
@@ -982,7 +1036,7 @@
 				if 'selectedevent' not in p.__call__.func_code.co_varnames] or []
 		from Components.ServiceEventTracker import InfoBarCount
 		if getAll or InfoBarCount == 1:
-			pluginlist.append((_("Show EPG for current channel..."), self.openSingleServiceEPG, "current_channel"))
+			pluginlist.append((_("Show EPG for current channel"), self.openSingleServiceEPG, "current_channel"))
 		pluginlist.append((_("Multi EPG"), self.openMultiServiceEPG, "multi_epg"))
 		pluginlist.append((_("Current event EPG"), self.openEventView, "event_epg"))
 		return pluginlist
@@ -1136,7 +1190,7 @@
 	def showEventInfoPlugins(self):
 		pluginlist = self.getEPGPluginList()
 		if pluginlist:
-			self.session.openWithCallback(self.EventInfoPluginChosen, ChoiceBox, title=_("Please choose an extension..."), list=pluginlist, skin_name="EPGExtensionsList", reorderConfig="eventinfo_order", windowTitle=_("Events info menu"))
+			self.session.openWithCallback(self.EventInfoPluginChosen, ChoiceBox, title=_("Please select an extension"), list=pluginlist, skin_name="EPGExtensionsList", reorderConfig="eventinfo_order", windowTitle=_("Events info menu"))
 		else:
 			self.openSingleServiceEPG()
 
@@ -1209,7 +1263,7 @@
 				self.eventView = self.session.openWithCallback(self.closed, EventViewEPGSelect, epglist[0], ServiceReference(ref), self.eventViewCallback, self.openSingleServiceEPG, self.openMultiServiceEPG, self.openSimilarList)
 				self.dlg_stack.append(self.eventView)
 		if not epglist:
-			print "no epg for the service avail.. so we show multiepg instead of eventinfo"
+			print "No EPG for the service available; show multiEPG instead of eventinfo"
 			self.openMultiServiceEPG(False)
 
 	def eventViewCallback(self, setEvent, setService, val): #used for now/next displaying
@@ -1309,7 +1363,7 @@
 
 		self["SeekActions"] = InfoBarSeekActionMap(self, actionmap,
 			{
-				"playpauseService": (self.playpauseService, _("Pauze/Continue playback")),
+				"playpauseService": (self.playpauseService, _("Pause/Continue playback")),
 				"pauseService": (self.pauseService, _("Pause playback")),
 				"unPauseService": (self.unPauseService, _("Continue playback")),
 				"okButton": (self.okButton, _("Continue playback")),
@@ -2069,7 +2123,7 @@
 		self.addExtension((lambda: _("Softcam Setup"), self.openSoftcamSetup, lambda: config.misc.softcam_setup.extension_menu.value), "1")
 		self["InstantExtensionsActions"] = HelpableActionMap(self, "InfobarExtensions",
 			{
-				"extensions": (self.showExtensionSelection, _("Show extensions...")),
+				"extensions": (self.showExtensionSelection, _("Show extensions")),
 			}, 1) # lower priority
 
 	def openSoftcamSetup(self):
@@ -2095,7 +2149,7 @@
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:
@@ -2123,7 +2177,7 @@
 					extensionsList.remove(extension)
 		list.extend([(x[0](), x) for x in extensionsList])
 		keys += [""] * len(extensionsList)
-		self.session.openWithCallback(self.extensionCallback, ChoiceBox, title=_("Please choose an extension..."), list=list, keys=keys, skin_name="ExtensionsList", reorderConfig="extension_order", windowTitle=_("Extensions menu"))
+		self.session.openWithCallback(self.extensionCallback, ChoiceBox, title=_("Please select an extension"), list=list, keys=keys, skin_name="ExtensionsList", reorderConfig="extension_order", windowTitle=_("Extensions menu")) 
 
 	def extensionCallback(self, answer):
 		if answer is not None:
@@ -2326,11 +2380,11 @@
 
 class InfoBarInstantRecord:
 	"""Instant Record - handles the instantRecord action in order to
-	start/stop instant records"""
+	start/stop instant recordings"""
 	def __init__(self):
 		self["InstantRecordActions"] = HelpableActionMap(self, "InfobarInstantRecord",
 			{
-				"instantRecord": (self.instantRecord, _("Instant recording...")),
+				"instantRecord": (self.instantRecord, _("Instant recording")),
 			})
 		self.SelectedInstantServiceRef = None
 		if isStandardInfoBar(self):
@@ -2413,7 +2467,7 @@
 	def startInstantRecording(self, limitEvent = False):
 		begin = int(time())
 		end = begin + 3600      # dummy
-		name = "instant record"
+		name = "Instant recording"
 		info = { }
 
 		self.getProgramInfoAndEvent(info, name)
@@ -2642,7 +2696,7 @@
 	def __init__(self):
 		self["AudioSelectionAction"] = HelpableActionMap(self, "InfobarAudioSelectionActions",
 			{
-				"audioSelection": (self.audioSelection, _("Audio options...")),
+				"audioSelection": (self.audioSelection, _("Audio options")),
 			})
 
 	def audioSelection(self):
@@ -2656,7 +2710,7 @@
 	def __init__(self):
 		self["SubserviceSelectionAction"] = HelpableActionMap(self, "InfobarSubserviceSelectionActions",
 			{
-				"subserviceSelection": (self.subserviceSelection, _("Subservice list...")),
+				"subserviceSelection": (self.subserviceSelection, _("Subservice list")),
 			})
 
 		self["SubserviceQuickzapAction"] = HelpableActionMap(self, "InfobarSubserviceQuickzapActions",
@@ -2740,18 +2794,18 @@
 				idx += 1
 
 			if cnt_parent and self.bouquets and len(self.bouquets):
-				keys = ["red", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+				keys = ["red", "blue", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
 				if config.usage.multibouquet.value:
-					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
 				else:
-					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
-				selection += 3
-			else:
-				tlist = [(_("Quick zap"), "quickzap", service.subServices()), ("--", "")] + tlist
-				keys = ["red", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
-				selection += 2
-
-			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a sub service..."), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
+					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+				selection += 4
+			else:
+				tlist = [(_("Quick zap"), "quickzap", service.subServices()), ("Exit", "exit"), ("--", "")] + tlist
+				keys = ["red", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+ 				selection += 3
+
+			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a sub service"), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
 
 	def subserviceSelected(self, service):
 		del self.bouquets
--- enigma2.org/lib/python/Screens/InfoBar.py
+++ enigma2/lib/python/Screens/InfoBar.py
@@ -9,6 +9,9 @@
 
 profile("LOAD:enigma")
 import enigma
+#+++>
+from enigma import iServiceInformation, iPlayableService
+#+++<
 
 profile("LOAD:InfoBarGenerics")
 from Screens.InfoBarGenerics import InfoBarShowHide, \
@@ -50,6 +53,10 @@
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
 				"toggleTvRadio": (self.toggleTvRadio, _("Toggle the tv and the radio player...")),
+				"volumeUp": (self._volUp, _("Volume up")),
+				"volumeDown": (self._volDown, _("Volume Down")),
+				"resolution": (self.resolution, _("Select display resolution")),
+				"aspect": (self.aspect, _("Select aspect ratio")),
 			}, prio=2)
 
 		self.radioTV = 0
@@ -65,8 +68,8 @@
 				InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarHotkey:
 			x.__init__(self)
 
-		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings..."))]))
-		self.helpList.append((self["actions"], "InfobarActions", [("showRadio", _("Listen to the radio..."))]))
+		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings"))]))
+		self.helpList.append((self["actions"], "InfobarActions", [("showRadio", _("Listen to the radio"))]))
 
 		self.__event_tracker = ServiceEventTracker(screen=self, eventmap=
 			{
@@ -77,6 +80,88 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+	def aspect(self):
+		selection = 0
+		tlist = []
+		try:
+			policy = open("/proc/stb/video/policy_choices").read()[:-1]
+		except IOError:
+			print "couldn't read available policymodes."
+			policy_available = [ ]
+			return
+		policy_available = policy.split(' ')
+		for x in policy_available:
+			tlist.append((x[0].upper() + x[1:], _(x)))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.aspectSelect, ChoiceBox, title=_("Please select an aspect ratio"), list = tlist, selection = selection, keys = keys)
+
+	def aspectSelect(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def resolution(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+		keys = ["green", "", "yellow", "blue", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.ResolutionSelect, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelect(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				open("/proc/stb/video/videomode", "w").write(Resolution[1])
+				from enigma import gMainDC
+				gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+	def _volUp(self):
+		print "_volUp"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def _volDown(self):
+		print "_volDown"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+ 
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -95,6 +180,22 @@
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService()
+		info = service.info()
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID)
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID)
+
+		print "sAudioPID", AudioPID
+		print "sVideoPID", VideoPID
+
+		if VideoPID == -1:
+			print "Radio->TV"
+			self.showTv2()
+		else:
+			print "TV->Radio"
+			self.showRadio2()
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -118,6 +223,19 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+	def showTv2(self):
+		self.showTvChannelList(False)
+		self.openServiceList()
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+			self.openServiceList()
+		else:
+			self.rds_display.hide() # in InfoBarRdsDecoder
+			from Screens.ChannelSelection import ChannelSelectionRadio
+			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+
 	def toggleTvRadio(self):
 		if self.radioTV == 1:
 			self.radioTV = 0
@@ -151,6 +265,7 @@
 class MoviePlayer(InfoBarBase, InfoBarShowHide, InfoBarMenu, InfoBarSeek, InfoBarShowMovies, InfoBarInstantRecord,
 		InfoBarAudioSelection, HelpableScreen, InfoBarNotifications, InfoBarServiceNotifications, InfoBarPVRState,
 		InfoBarCueSheetSupport, InfoBarMoviePlayerSummarySupport, InfoBarSubtitleSupport, Screen, InfoBarTeletextPlugin,
+		InfoBarSubserviceSelection,
 		InfoBarServiceErrorPopupSupport, InfoBarExtensions, InfoBarPlugins, InfoBarPiP, InfoBarHDMI, InfoBarHotkey):
 
 	ENABLE_RESUME_SUPPORT = True
@@ -161,10 +276,10 @@
 
 		self["actions"] = HelpableActionMap(self, "MoviePlayerActions",
 			{
-				"leavePlayer": (self.leavePlayer, _("leave movie player...")),
-				"leavePlayerOnExit": (self.leavePlayerOnExit, _("leave movie player...")),
-				"channelUp": (self.channelUp, _("when PiPzap enabled zap channel up...")),
-				"channelDown": (self.channelDown, _("when PiPzap enabled zap channel down...")),
+				"leavePlayer": (self.leavePlayer, _("Leave movie player")),
+				"leavePlayerOnExit": (self.leavePlayerOnExit, _("Leave movie player")),
+				"channelUp": (self.channelUp, _("When PiPzap enabled zap channel up")),
+				"channelDown": (self.channelDown, _("When PiPzap enabled zap channel down")),
 			})
 
 		self["DirectionActions"] = HelpableActionMap(self, "DirectionActions",
@@ -542,3 +657,7 @@
 
 	def ref2HumanName(self, ref):
 		return enigma.eServiceCenter.getInstance().info(ref).getName(ref)
+
+	def sleepTimer(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
--- enigma2.org/lib/python/Screens/ScanSetup.py
+++ enigma2/lib/python/Screens/ScanSetup.py
@@ -1196,7 +1196,7 @@
 		self.cable_toggle = {"single_transponder":"complete", "complete":"single_transponder"}
 		self.scan_typeterrestrial = ConfigSelection(default = defaultTerrSearchType, choices = [("single_transponder", _("User defined transponder")), ("predefined_transponder", _("Predefined transponder")), ("complete", _("Complete"))])
 		self.scan_type_atsc = ConfigSelection(default = defaultATSCSearchType, choices = [("single_transponder", _("User defined transponder")), ("predefined_transponder", _("Predefined transponder")), ("complete", _("Complete"))])
-		self.scan_input_as = ConfigSelection(default = "channel", choices = [("frequency", _("Frequency")), ("channel", _("Channel"))])
+		self.scan_input_as = ConfigSelection(default = "frequency", choices = [("frequency", _("Frequency")), ("channel", _("Channel"))])
 		self.scan_ter_complete_type = ConfigSelection(default = "all", choices = [("all", _("All frequency")), ("extended", _("Extended"))])
 		self.scan_clearallservices = ConfigSelection(default = "no", choices = [("no", _("no")), ("yes", _("yes")), ("yes_hold_feeds", _("yes (keep feeds)"))])
 		self.scan_onlyfree = ConfigYesNo(default = False)
--- enigma2.org/lib/python/Screens/Standby.py
+++ enigma2/lib/python/Screens/Standby.py
@@ -14,11 +14,50 @@
 from enigma import eDVBVolumecontrol, eTimer, eDVBLocalTimeHandler, eServiceReference
 from Tools.HardwareInfo import HardwareInfo
 
+pll0 = '/proc/cpu_frequ/pll0_ndiv_mdiv'
+stb = HardwareInfo().get_device_name()
+
 inStandby = None
 
 class Standby(Screen):
 	def Power(self):
 		print "[Standby] leave standby"
+		if stb.lower() == 'spark' or stb.lower() == 'spark7162':
+			#apply CPU clock frequency
+#			if config.plugins.systemoptions.freq.value:
+#				if config.plugins.systemoptions.freq.value == "200":
+#					overclk=5123
+#				elif config.plugins.systemoptions.freq.value == "300":
+#					overclk=2561
+#				elif config.plugins.systemoptions.freq.value == "450":
+#					overclk=3841
+#				elif config.plugins.systemoptions.freq.value == "500":
+#					overclk=12803
+#				elif config.plugins.systemoptions.freq.value == "540":
+#					overclk=4609
+#				elif config.plugins.systemoptions.freq.value == "600":
+#					overclk=5121
+#				elif config.plugins.systemoptions.freq.value == "630":
+#					overclk=5377
+#				elif config.plugins.systemoptions.freq.value == "650":
+#					overclk=16643
+#				elif config.plugins.systemoptions.freq.value == "700":
+#					overclk=17923
+#				elif config.plugins.systemoptions.freq.value == "710":
+#					overclk=18179
+#				elif config.plugins.systemoptions.freq.value == "750":
+#					overclk=19203
+#				elif config.plugins.systemoptions.freq.value == "775":
+#					overclk=39686
+#				elif config.plugins.systemoptions.freq.value == "800":
+#					overclk=20483
+#			else:
+			overclk=4609
+#			print "Clockspeed =", config.plugins.systemoptions.freq.value, "PLL = ", str(overclk)
+			open(pll0, 'w').write(str(overclk))
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("on")
+#+++<
 		self.close(True)
 
 	def setMute(self):
@@ -60,6 +99,40 @@
 		self.timeHandler = None
 
 		self.setMute()
+		if stb.lower() == 'spark' or stb.lower() == 'spark7162':
+			#apply standby CPU clock frequency
+#			if config.plugins.systemoptions.stbyfreq.value:
+#				if config.plugins.systemoptions.stbyfreq.value == "200":
+#					overclk=5123
+#				elif config.plugins.systemoptions.stbyfreq.value == "300":
+#					overclk=2561
+#				elif config.plugins.systemoptions.stbyfreq.value == "450":
+#					overclk=3841
+#				elif config.plugins.systemoptions.stbyfreq.value == "500":
+#					overclk=12803
+#				elif config.plugins.systemoptions.stbyfreq.value == "540":
+#					overclk=4609
+#				elif config.plugins.systemoptions.stbyfreq.value == "600":
+#					overclk=5121
+#				elif config.plugins.systemoptions.stbyfreq.value == "630":
+#					overclk=5377
+#				elif config.plugins.systemoptions.stbyfreq.value == "650":
+#					overclk=16643
+#				elif config.plugins.systemoptions.stbyfreq.value == "700":
+#					overclk=17923
+#				elif config.plugins.systemoptions.stbyfreq.value == "710":
+#					overclk=18179
+#				elif config.plugins.systemoptions.stbyfreq.value == "750":
+#					overclk=19203
+#				elif config.plugins.systemoptions.stbyfreq.value == "775":
+#					overclk=39686
+#				elif config.plugins.systemoptions.stbyfreq.value == "800":
+#					overclk=20483
+#			else:
+			overclk=4609
+#			print "STBY Clockspeed =", config.plugins.systemoptions.stbyfreq.value, "PLL = ", str(overclk)
+			open(pll0, 'w').write(str(overclk))
+
 
 		self.paused_service = self.paused_action = False
 
@@ -90,6 +163,9 @@
 			self.avswitch.setInput("SCART")
 		else:
 			self.avswitch.setInput("AUX")
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("off")
+#+++<
 
 		gotoShutdownTime = int(config.usage.standby_to_shutdown_timer.value)
 		if gotoShutdownTime:
@@ -202,6 +278,7 @@
 			3: _("The user interface of your receiver is restarting"),
 			4: _("Your frontprocessor will be upgraded\nPlease wait until your receiver reboots\nThis may take a few minutes"),
 			5: _("The user interface of your receiver is restarting\ndue to an error in mytest.py"),
+			10: _('Your receiver is rebooting to Spark now\nThis may take a while'),
 			42: _("Unattended upgrade in progress\nPlease wait until your receiver reboots\nThis may take a few minutes") }.get(retvalue)
 		self["text"] = Label(text)
 
@@ -230,6 +307,7 @@
 				2: _("Really reboot now?"),
 				3: _("Really restart now?"),
 				4: _("Really upgrade the frontprocessor and reboot now?"),
+				10: _('Really reboot to Spark now?'),
 				42: _("Really upgrade your settop box and reboot now?") }.get(retvalue)
 			if text:
 				MessageBox.__init__(self, session, reason+text, type = MessageBox.TYPE_YESNO, timeout = timeout, default = default_yes)
--- enigma2.org/lib/python/Screens/Wizard.py
+++ enigma2/lib/python/Screens/Wizard.py
@@ -13,6 +13,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	def __init__(self, session, parent):
@@ -350,6 +353,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -442,6 +448,9 @@
 			if "onselect" in self.wizard[self.currStep]:
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string(self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 
 	def resetCounter(self):
--- enigma2.org/lib/python/Tools/Command.py
+++ enigma2/lib/python/Tools/Command.py
@@ -0,0 +1,22 @@
+from os import stat as os_stat, path as os_path, system
+import os
+
+def command(comandline, strip=1):
+	comandline = comandline + " >/tmp/command.txt"
+	os.system(comandline)
+	text = ""
+	if os.path.exists("/tmp/command.txt") is True:
+		file = open("/tmp/command.txt", "r")
+		if strip == 1:
+			for line in file:
+				text = text + line.strip() + '\n'
+		else:
+			for line in file:
+				text = text + line
+				if text[-1:] != '\n': text = text + "\n"
+		file.close
+	if text[-1:] == '\n': text = text[:-1]
+	comandline = text
+	os.system("rm /tmp/command.txt")
+	return comandline
+
--- enigma2.org/lib/python/Tools/Makefile.am
+++ enigma2/lib/python/Tools/Makefile.am
@@ -5,5 +5,5 @@
 	KeyBindings.py BoundFunction.py ISO639.py Notifications.py __init__.py \
 	RedirectOutput.py StbHardware.py Import.py Event.py CList.py \
 	LoadPixmap.py Profile.py HardwareInfo.py Transponder.py ASCIItranslit.py \
-	Downloader.py Trashcan.py GetEcmInfo.py Alternatives.py TextBoundary.py \
+	Downloader.py Trashcan.py GetEcmInfo.py Alternatives.py TextBoundary.py Command.py \
 	camcontrol.py
--- enigma2.org/lib/service/listboxservice.cpp
+++ enigma2/lib/service/listboxservice.cpp
@@ -186,14 +186,14 @@
 	{
 		--i;
 		--index;
-		if (!(i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible)))
+		if (! ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible)))
 			break;
 	}
 	while (index)
 	{
 		--i;
 		--index;
-		if (i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible))
+		if ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible))
 			break;
 	}
 	return cursorResolve(index);
@@ -209,7 +209,7 @@
 	{
 		++i;
 		++index;
-		if (i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible))
+		if ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible))
 			break;
 	}
 	return cursorResolve(index);
--- enigma2.org/lib/service/Makefile.inc
+++ enigma2/lib/service/Makefile.inc
@@ -10,14 +10,23 @@
 	service/servicedvb.cpp \
 	service/servicedvbrecord.cpp \
 	service/servicefs.cpp \
-	service/servicemp3.cpp \
-	service/servicemp3record.cpp \
 	service/servicem2ts.cpp \
 	service/servicedvbstream.cpp \
 	service/servicehdmi.cpp \
 	service/servicepeer.cpp \
 	service/servicets.cpp \
 	service/servicewebts.cpp
+
+if ENABLE_MEDIAFWGSTREAMER
+service_libenigma_service_a_SOURCES += \
+	service/servicemp3.cpp \
+	service/servicemp3record.cpp
+endif
+
+if ENABLE_LIBEPLAYER3 
+service_libenigma_service_a_SOURCES += \
+	service/serviceeplayer3.cpp
+endif
 
 serviceincludedir = $(pkgincludedir)/lib/service
 serviceinclude_HEADERS = \
@@ -37,6 +46,17 @@
 	service/servicets.h \
 	service/servicewebts.h
 
+if ENABLE_MEDIAFWGSTREAMER
+service_libenigma_service_a_SOURCES += \
+	service/servicemp3.h \
+	service/servicemp3record.h
+endif
+
+if ENABLE_LIBEPLAYER3 
+service_libenigma_service_a_SOURCES += \
+	service/serviceeplayer3.h
+endif
+
 if HAVE_LIBXINE
 service_libenigma_service_a_SOURCES += \
 	service/servicexine.cpp
--- enigma2.org/lib/service/servicedvb.cpp
+++ enigma2/lib/service/servicedvb.cpp
@@ -642,6 +642,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
--- enigma2.org/lib/service/servicedvbrecord.cpp
+++ enigma2/lib/service/servicedvbrecord.cpp
@@ -11,6 +11,10 @@
 #include <byteswap.h>
 #include <netinet/in.h>
 
+#if defined(__sh__)
+#include <sys/vfs.h>
+#include <linux/magic.h>
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref, bool isstreamclient): m_ref(ref)
@@ -283,9 +287,43 @@
 
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__)
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("[eDVBServiceRecord] Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__)
+		//we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY | O_CREAT | O_LARGEFILE | O_CLOEXEC, 0666);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0)
+		{
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!");
+		} else
+		{
+			if (sbuf.f_type == EXT3_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n");
+			else
+			if (sbuf.f_type == NFS_SUPER_MAGIC)
+			{
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n");
+				flags |= O_DIRECT;
+			}
+			else
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - USB Device\n");
+			else
+			if (sbuf.f_type == SMB_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - SMBs Device\n");
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - MSDOS Device\n");
+		}
+		fd = ::open(m_filename.c_str(), flags, 0644);
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY | O_CREAT | O_LARGEFILE | O_CLOEXEC, 0666);
+#endif
 		if (fd == -1)
 		{
 			eDebug("[eDVBServiceRecord] can't open recording file: %m");
--- enigma2.org/lib/service/serviceeplayer3.cpp
+++ enigma2/lib/service/serviceeplayer3.cpp
@@ -0,0 +1,1303 @@
+	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
+	/* it's currently hardcoded to use a big-endian alsasink as sink. */
+#include <lib/base/ebase.h>
+#include <lib/base/eerror.h>
+#include <lib/base/init_num.h>
+#include <lib/base/init.h>
+#include <lib/base/nconfig.h>
+#include <lib/base/object.h>
+#include <lib/dvb/decoder.h>
+#include <lib/components/file_eraser.h>
+#include <lib/gui/esubtitle.h>
+#include <lib/service/serviceeplayer3.h>
+#include <lib/service/service.h>
+#include <lib/gdi/gpixmap.h>
+
+#include <string>
+#include <sys/stat.h>
+
+#if not defined ENABLE_MEDIAFWGSTREAMER
+#include <player.h>
+#endif 
+
+#define HTTP_TIMEOUT 60
+
+typedef enum
+{
+	GST_PLAY_FLAG_VIDEO         = 0x00000001,
+	GST_PLAY_FLAG_AUDIO         = 0x00000002,
+	GST_PLAY_FLAG_TEXT          = 0x00000004,
+	GST_PLAY_FLAG_VIS           = 0x00000008,
+	GST_PLAY_FLAG_SOFT_VOLUME   = 0x00000010,
+	GST_PLAY_FLAG_NATIVE_AUDIO  = 0x00000020,
+	GST_PLAY_FLAG_NATIVE_VIDEO  = 0x00000040,
+	GST_PLAY_FLAG_DOWNLOAD      = 0x00000080,
+	GST_PLAY_FLAG_BUFFERING     = 0x00000100
+} GstPlayFlags;
+
+// eServiceFactoryEPlayer3
+
+/*
+ * gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
+ * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
+ * As a workaround, we run the subsink in sync=false mode
+ */
+#define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+/**/
+
+void ep3Blit(){
+	fbClass *fb = fbClass::getInstance();
+	fb->blit();
+}
+
+
+eServiceFactoryEPlayer3::eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+	{
+		std::list<std::string> extensions;
+		//extensions.push_back("dts");
+		//extensions.push_back("mp2");
+		//extensions.push_back("mp3");
+		//extensions.push_back("ogg");
+		//extensions.push_back("ogm");
+		//extensions.push_back("ogv");
+		extensions.push_back("mpg");
+		extensions.push_back("vob");
+		//extensions.push_back("wav");
+		//extensions.push_back("wave");
+		extensions.push_back("m4v");
+		extensions.push_back("mkv");
+		extensions.push_back("avi");
+		extensions.push_back("divx");
+		extensions.push_back("dat");
+		//extensions.push_back("flac");
+		//extensions.push_back("flv");
+		extensions.push_back("mp4");
+		extensions.push_back("mov");
+		//extensions.push_back("m4a");
+		//extensions.push_back("3gp");
+		//extensions.push_back("3g2");
+		//extensions.push_back("asf");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		extensions.push_back("wmv");
+#endif
+		//extensions.push_back("wma");
+		sc->addServiceFactory(eServiceFactoryEPlayer3::id, this, extensions);
+	}
+
+	m_service_info = new eStaticServiceEPlayer3Info();
+}
+
+eServiceFactoryEPlayer3::~eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+		sc->removeServiceFactory(eServiceFactoryEPlayer3::id);
+}
+
+DEFINE_REF(eServiceFactoryEPlayer3)
+
+	// iServiceHandler
+RESULT eServiceFactoryEPlayer3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
+{
+	// check resources...
+	ptr = new eServiceEPlayer3(ref);
+	return 0;
+}
+
+RESULT eServiceFactoryEPlayer3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::list(const eServiceReference &, ePtr<iListableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
+{
+	ptr = m_service_info;
+	return 0;
+}
+
+class eEPlayer3ServiceOfflineOperations: public iServiceOfflineOperations
+{
+	DECLARE_REF(eEPlayer3ServiceOfflineOperations);
+	eServiceReference m_ref;
+public:
+	eEPlayer3ServiceOfflineOperations(const eServiceReference &ref);
+
+	RESULT deleteFromDisk(int simulate);
+	RESULT getListOfFilenames(std::list<std::string> &);
+	RESULT reindex();
+};
+
+DEFINE_REF(eEPlayer3ServiceOfflineOperations);
+
+eEPlayer3ServiceOfflineOperations::eEPlayer3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
+{
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::deleteFromDisk(int simulate)
+{
+	if (!simulate)
+	{
+		std::list<std::string> res;
+		if (getListOfFilenames(res))
+			return -1;
+
+		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
+		if (!eraser)
+			eDebug("FATAL !! can't get background file eraser");
+
+		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
+		{
+			eDebug("Removing %s...", i->c_str());
+			if (eraser)
+				eraser->erase(i->c_str());
+			else
+				::unlink(i->c_str());
+		}
+	}
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
+{
+	res.clear();
+	res.push_back(m_ref.path);
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::reindex()
+{
+	return -1;
+}
+
+
+RESULT eServiceFactoryEPlayer3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
+{
+	ptr = new eEPlayer3ServiceOfflineOperations(ref);
+	return 0;
+}
+
+// eStaticServiceEPlayer3Info
+
+
+// eStaticServiceEPlayer3Info is seperated from eServiceEPlayer3 to give information
+// about unopened files.
+
+// probably eServiceEPlayer3 should use this class as well, and eStaticServiceEPlayer3Info
+// should have a database backend where ID3-files etc. are cached.
+// this would allow listing the mp3 database based on certain filters.
+
+DEFINE_REF(eStaticServiceEPlayer3Info)
+
+eStaticServiceEPlayer3Info::eStaticServiceEPlayer3Info()
+{
+}
+
+RESULT eStaticServiceEPlayer3Info::getName(const eServiceReference &ref, std::string &name)
+{
+	if ( ref.name.length() )
+		name = ref.name;
+	else
+	{
+		size_t last = ref.path.rfind('/');
+		if (last != std::string::npos)
+			name = ref.path.substr(last+1);
+		else
+			name = ref.path;
+	}
+	return 0;
+}
+
+int eStaticServiceEPlayer3Info::getLength(const eServiceReference &ref)
+{
+	return -1;
+}
+
+int eStaticServiceEPlayer3Info::getInfo(const eServiceReference &ref, int w)
+{
+	switch (w)
+	{
+	case iServiceInformation::sTimeCreate:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_mtime;
+			}
+		}
+		break;
+	case iServiceInformation::sFileSize:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_size;
+			}
+		}
+		break;
+	}
+	return iServiceInformation::resNA;
+}
+
+long long eStaticServiceEPlayer3Info::getFileSize(const eServiceReference &ref)
+{
+	struct stat s;
+	if (stat(ref.path.c_str(), &s) == 0)
+	{
+		return s.st_size;
+	}
+	return 0;
+}
+
+DEFINE_REF(eStreamBufferEPlayer3Info)
+
+eStreamBufferEPlayer3Info::eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size)
+: bufferPercentage(percentage),
+	inputRate(inputrate),
+	outputRate(outputrate),
+	bufferSpace(space),
+	bufferSize(size)
+{
+}
+
+int eStreamBufferEPlayer3Info::getBufferPercentage() const
+{
+	return bufferPercentage;
+}
+
+int eStreamBufferEPlayer3Info::getAverageInputRate() const
+{
+	return inputRate;
+}
+
+int eStreamBufferEPlayer3Info::getAverageOutputRate() const
+{
+	return outputRate;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSpace() const
+{
+	return bufferSpace;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSize() const
+{
+	return bufferSize;
+}
+
+// eServiceEPlayer3
+int eServiceEPlayer3::ac3_delay = 0,
+    eServiceEPlayer3::pcm_delay = 0;
+
+eServiceEPlayer3::eServiceEPlayer3(eServiceReference ref)
+	:m_ref(ref), m_pump(eApp, 1)
+{
+	m_subtitle_sync_timer = eTimer::create(eApp);
+	m_streamingsrc_timeout = 0;
+
+	m_currentAudioStream = -1;
+	m_currentSubtitleStream = -1;
+	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
+	m_subtitle_widget = 0;
+	m_currentTrickRatio = 1.0;
+	m_buffer_size = 8 * 1024 * 1024;
+
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	m_errorInfo.missing_codec = "";
+
+
+	CONNECT(m_subtitle_sync_timer->timeout, eServiceEPlayer3::pushSubtitles);
+
+	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
+
+	m_state = stIdle;
+	eDebug("eServiceEPlayer3::construct!");
+
+	const char *filename = m_ref.path.c_str();
+	const char *ext = strrchr(filename, '.');
+	if (!ext)
+		ext = filename + strlen(filename);
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+#else
+	player = new Player();
+#endif
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		out.framebufferBlit = ep3Blit;
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+#endif
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+#else
+	if (player->Open(file))
+#endif
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+#if defined ENABLE_MEDIAFWGSTREAMER
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+#else
+		if (player)
+		{
+			std::vector<Track> tracks = player->manager.getAudioTracks();
+		}
+		m_state = stRunning;
+#endif
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+#if defined ENABLE_MEDIAFWGSTREAMER
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+#else
+		player->Stop();
+		player->output.Close();
+		player->Close();
+#endif
+	}
+	//m_state = stRunning;
+	eDebug("eServiceEPlayer3-<\n");
+}
+
+eServiceEPlayer3::~eServiceEPlayer3()
+{
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+	if (m_state == stRunning)
+		stop();
+#if not defined ENABLE_MEDIAFWGSTREAMER
+	delete player;
+#endif
+}
+
+DEFINE_REF(eServiceEPlayer3);
+
+RESULT eServiceEPlayer3::connectEvent(const Slot2<void, iPlayableService*, int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+	m_event(this, evSeekableStatusChanged);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::start()
+{
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+
+	m_state = stRunning;
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#else
+	if (player)
+	{
+		player->output.Open();
+		player->Play();
+ 	}
+#endif
+
+	m_event(this, evStart);
+
+	return 0;
+}
+
+void eServiceEPlayer3::sourceTimeout()
+{
+	eDebug("eServiceEPlayer3::http source timeout! issuing eof...");
+	m_event((iPlayableService*)this, evEOF);
+}
+
+RESULT eServiceEPlayer3::stop()
+{
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+
+	if (m_state == stStopped)
+		return -1;
+
+	eDebug("eServiceEPlayer3::stop %s", m_ref.path.c_str());
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+	if (player)
+		free(player);
+
+	if (player != NULL)
+		player = NULL;
+
+#else
+	if (player)
+	{
+		player->Stop();
+		player->output.Close();
+		player->Close();
+	}
+#endif
+
+	m_state = stStopped;
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTarget(int target, bool noaudio)
+{
+	return -1;
+}
+
+RESULT eServiceEPlayer3::pause(ePtr<iPauseableService> &ptr)
+{
+	ptr=this;
+	return 0;
+}
+
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::setSlowMotion(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && (speed != -1))
+#else
+	if (player && (speed != -1))
+#endif
+	{
+		int result = 0;
+		if (ratio > 1)
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+#else
+			result = player->SlowMotion(speed);
+#endif
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setFastForward(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && (speed != -1))
+#else
+	if (player && (speed != -1))
+#endif
+	{
+		int result = 0;
+		if (ratio > 1)
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+#else
+			result = player->FastForward(speed);
+#endif
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+#else
+			result = player->FastBackward(speed);
+#endif
+		}
+		else
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#else
+			result = player->Continue();
+#endif
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+}
+
+		// iPausableService
+RESULT eServiceEPlayer3::pause()
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#else
+	if (player)
+		player->Pause();
+#endif
+	return 0;
+}
+
+RESULT eServiceEPlayer3::unpause()
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#else
+	if (player)
+		player->Continue();
+#endif
+
+	return 0;
+}
+
+	/* iSeekableService */
+RESULT eServiceEPlayer3::seek(ePtr<iSeekableService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getLength(pts_t &pts)
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+#else
+	int64_t length = 0;
+
+	if (player)
+		player->GetDuration(length);
+#endif
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekToImpl(pts_t to)
+{
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekTo(pts_t to)
+{
+	RESULT ret = -1;
+
+	float pos = (to/90000.0)-10;
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+#else
+	if (player)
+		player->Seek(pos,true);
+#endif
+
+	ret =0;
+	return ret;
+}
+
+RESULT eServiceEPlayer3::seekRelative(int direction, pts_t to)
+{
+	pts_t ppos;
+	if (getPlayPosition(ppos) < 0) return -1;
+	ppos += to * direction;
+	if (ppos < 0)
+		ppos = 0;
+
+	float pos = direction*(to/90000.0);
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+#else
+	if (player)
+		player->Seek(pos,true);
+#endif
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getPlayPosition(pts_t &pts)
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && !player->playback->isPlaying)
+#else
+	if (player && !player->isPlaying)
+#endif
+	{
+		eDebug("eServiceEPlayer3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+#else
+	if (player)
+		player->GetPts((int64_t &) pts);
+#endif
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTrickmode(int trick)
+{
+		/* trickmode is not yet supported by our dvbmediasinks. */
+	return -1;
+}
+
+RESULT eServiceEPlayer3::isCurrentlySeekable()
+{
+	return 3;
+}
+
+RESULT eServiceEPlayer3::info(ePtr<iServiceInformation>&i)
+{
+	i = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getName(std::string &name)
+{
+	std::string title = m_ref.getName();
+	if (title.empty())
+	{
+		name = m_ref.path;
+		size_t n = name.rfind('/');
+		if (n != std::string::npos)
+			name = name.substr(n + 1);
+	}
+	else
+		name = title;
+	return 0;
+}
+
+int eServiceEPlayer3::getInfo(int w)
+{
+	switch (w)
+	{
+	case sServiceref: return m_ref;
+	case sVideoHeight: return m_height;
+	case sVideoWidth: return m_width;
+	case sFrameRate: return m_framerate;
+	case sProgressive: return m_progressive;
+	case sAspect: return m_aspect;
+	case sTagTitle:
+	case sTagArtist:
+	case sTagAlbum:
+	case sTagTitleSortname:
+	case sTagArtistSortname:
+	case sTagAlbumSortname:
+	case sTagDate:
+	case sTagComposer:
+	case sTagGenre:
+	case sTagComment:
+	case sTagExtendedComment:
+	case sTagLocation:
+	case sTagHomepage:
+	case sTagDescription:
+	case sTagVersion:
+	case sTagISRC:
+	case sTagOrganization:
+	case sTagCopyright:
+	case sTagCopyrightURI:
+	case sTagContact:
+	case sTagLicense:
+	case sTagLicenseURI:
+	case sTagCodec:
+	case sTagAudioCodec:
+	case sTagVideoCodec:
+	case sTagEncoder:
+	case sTagLanguageCode:
+	case sTagKeywords:
+	case sTagChannelMode:
+	case sUser+12:
+#if not defined(__sh__)
+		return resIsString;
+#endif
+	case sTagTrackGain:
+	case sTagTrackPeak:
+	case sTagAlbumGain:
+	case sTagAlbumPeak:
+	case sTagReferenceLevel:
+	case sTagBeatsPerMinute:
+	case sTagImage:
+	case sTagPreviewImage:
+	case sTagAttachment:
+		return resIsPyObject;
+	default:
+		return resNA;
+	}
+
+	return 0;
+}
+
+std::string eServiceEPlayer3::getInfoString(int w)
+{
+	char * tag = NULL;
+#if defined ENABLE_MEDIAFWGSTREAMER
+	char * res_str = NULL;
+#else
+	std::vector<std::string> keys, values;
+	std::string res = "";
+#endif
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+#else
+	if (player)
+		player->input.GetMetadata(keys, values);
+
+	for (int i = 0; i < keys.size(); i++)
+	{
+		if (tag == keys[i])
+			res = values[i];
+	}	
+
+#endif
+	free(tag);
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	return "";
+#else
+	return res;
+#endif
+}
+
+RESULT eServiceEPlayer3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::subtitle(ePtr<iSubtitleOutput> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioDelay(ePtr<iAudioDelay> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+int eServiceEPlayer3::getNumberOfTracks()
+{
+ 	return m_audioStreams.size();
+}
+
+int eServiceEPlayer3::getCurrentTrack()
+{
+	return m_currentAudioStream;
+}
+
+RESULT eServiceEPlayer3::selectTrack(unsigned int i)
+{
+	int ret = selectAudioStream(i);
+
+	return ret;
+}
+
+int eServiceEPlayer3::selectAudioStream(int i)
+{
+	if (i != m_currentAudioStream)
+	{
+#if defined ENABLE_MEDIAFWGSTREAMER
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+#else
+		if (player)
+			player->SwitchAudio(i);
+#endif
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+}
+
+int eServiceEPlayer3::getCurrentChannel()
+{
+	return STEREO;
+}
+
+RESULT eServiceEPlayer3::selectChannel(int i)
+{
+	eDebug("eServiceEPlayer3::selectChannel(%i)",i);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
+{
+ 	if (i >= m_audioStreams.size())
+		return -2;
+
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+
+	if (info.m_language.empty())
+		info.m_language = m_audioStreams[i].language_code;
+	return 0;
+}
+
+eAutoInitPtr<eServiceFactoryEPlayer3> init_eServiceFactoryEPlayer3(eAutoInitNumbers::service+1, "eServiceFactoryEPlayer3");
+
+void eServiceEPlayer3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceEPlayer3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceEPlayer3 *_this = (eServiceEPlayer3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceEPlayer3::%s <", __func__);
+}
+
+void eServiceEPlayer3::pushSubtitles()
+{
+}
+
+RESULT eServiceEPlayer3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
+{
+	if (m_currentSubtitleStream != track.pid)
+	{
+		m_subtitle_sync_timer->stop();
+		m_subtitle_pages.clear();
+		m_prev_decoder_time = -1;
+		m_decoder_time_valid_state = 0;
+
+		m_subtitle_widget = user;
+
+	}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+#else
+	if (player)
+		player->SwitchSubtitle(track.pid);
+#endif
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::disableSubtitles()
+{
+	eDebug("eServiceEPlayer3::disableSubtitles");
+
+	m_subtitle_sync_timer->stop();
+	m_subtitle_pages.clear();
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+	int pid = -1;
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#else
+	if (player)
+		player->SwitchSubtitle(pid);
+#endif
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getCachedSubtitle(struct SubtitleTrack &track)
+{
+
+	bool autoturnon = eConfigManager::getConfigBoolValue("config.subtitles.pango_autoturnon", true);
+	if (!autoturnon)
+		return -1;
+
+	if (m_cachedSubtitleStream >= 0 && m_cachedSubtitleStream < (int)m_subtitleStreams.size())
+	{
+		track.type = 2;
+		track.pid = m_cachedSubtitleStream;
+		track.page_number = int(m_subtitleStreams[m_cachedSubtitleStream].type);
+		track.magazine_number = 0;
+		return 0;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::getSubtitleList(std::vector<struct SubtitleTrack> &subtitlelist)
+{
+// 	eDebug("eServiceEPlayer3::getSubtitleList");
+	int stream_idx = 0;
+
+	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
+	{
+		subtype_t type = IterSubtitleStream->type;
+		switch(type)
+		{
+		case stUnknown:
+		case stVOB:
+		case stPGS:
+			break;
+		default:
+		{
+			struct SubtitleTrack track;
+			track.type = 2;
+			track.pid = stream_idx;
+			track.page_number = int(type);
+			track.magazine_number = 0;
+			track.language_code = IterSubtitleStream->language_code;
+			subtitlelist.push_back(track);
+		}
+		}
+		stream_idx++;
+	}
+	eDebug("eServiceEPlayer3::getSubtitleList finished");
+	return 0;
+}
+
+RESULT eServiceEPlayer3::streamed(ePtr<iStreamedService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+ePtr<iStreamBufferInfo> eServiceEPlayer3::getBufferCharge()
+{
+	return new eStreamBufferEPlayer3Info(m_bufferInfo.bufferPercent, m_bufferInfo.avgInRate, m_bufferInfo.avgOutRate, m_bufferInfo.bufferingLeft, m_buffer_size);
+}
+
+int eServiceEPlayer3::setBufferSize(int size)
+{
+	m_buffer_size = size;
+	return 0;
+}
+
+int eServiceEPlayer3::getAC3Delay()
+{
+	return ac3_delay;
+}
+
+int eServiceEPlayer3::getPCMDelay()
+{
+	return pcm_delay;
+}
+
+void eServiceEPlayer3::setAC3Delay(int delay)
+{
+
+}
+
+void eServiceEPlayer3::setPCMDelay(int delay)
+{
+}
--- enigma2.org/lib/service/serviceeplayer3.h
+++ enigma2/lib/service/serviceeplayer3.h
@@ -0,0 +1,313 @@
+#ifndef __serviceeplayer3_h
+#define __serviceeplayer3_h
+
+#include <lib/base/message.h>
+#include <lib/service/iservice.h>
+#include <lib/dvb/pmt.h>
+#include <lib/dvb/subtitle.h>
+#include <lib/dvb/teletext.h>
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+#include <common.h>
+#include <subtitle.h>
+#endif
+#define gint int
+#define gint64 int64_t
+#if defined ENABLE_MEDIAFWGSTREAMER
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
+
+/* for subtitles */
+#include <lib/gui/esubtitle.h>
+
+#if not defined ENABLE_MEDIAFWGSTREAMER
+class Player;
+#endif
+class eStaticServiceEPlayer3Info;
+
+class eServiceFactoryEPlayer3: public iServiceHandler
+{
+	DECLARE_REF(eServiceFactoryEPlayer3);
+public:
+	eServiceFactoryEPlayer3();
+	virtual ~eServiceFactoryEPlayer3();
+	enum { id = 0x1003 };
+
+		// iServiceHandler
+	RESULT play(const eServiceReference &, ePtr<iPlayableService> &ptr);
+	RESULT record(const eServiceReference &, ePtr<iRecordableService> &ptr);
+	RESULT list(const eServiceReference &, ePtr<iListableService> &ptr);
+	RESULT info(const eServiceReference &, ePtr<iStaticServiceInformation> &ptr);
+	RESULT offlineOperations(const eServiceReference &, ePtr<iServiceOfflineOperations> &ptr);
+private:
+	ePtr<eStaticServiceEPlayer3Info> m_service_info;
+};
+
+class eStaticServiceEPlayer3Info: public iStaticServiceInformation
+{
+	DECLARE_REF(eStaticServiceEPlayer3Info);
+	friend class eServiceFactoryEPlayer3;
+	eStaticServiceEPlayer3Info();
+public:
+	RESULT getName(const eServiceReference &ref, std::string &name);
+	int getLength(const eServiceReference &ref);
+	int getInfo(const eServiceReference &ref, int w);
+	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore, bool simulate) { return 1; }
+	long long getFileSize(const eServiceReference &ref);
+};
+
+class eStreamBufferEPlayer3Info: public iStreamBufferInfo
+{
+	DECLARE_REF(eStreamBufferEPlayer3Info);
+	int bufferPercentage;
+	int inputRate;
+	int outputRate;
+	int bufferSpace;
+	int bufferSize;
+
+public:
+	eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size);
+
+	int getBufferPercentage() const;
+	int getAverageInputRate() const;
+	int getAverageOutputRate() const;
+	int getBufferSpace() const;
+	int getBufferSize() const;
+};
+
+class eServiceEPlayer3InfoContainer: public iServiceInfoContainer
+{
+	DECLARE_REF(eServiceEPlayer3InfoContainer);
+
+	double doubleValue;
+
+
+	unsigned char *bufferData;
+	unsigned int bufferSize;
+
+public:
+	eServiceEPlayer3InfoContainer();
+	~eServiceEPlayer3InfoContainer();
+
+	double getDouble(unsigned int index) const;
+	unsigned char *getBuffer(unsigned int &size) const;
+
+	void setDouble(double value);
+};
+
+typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
+typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
+typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA, ctASF, ctOGG } containertype_t;
+
+class eServiceEPlayer3: public iPlayableService, public iPauseableService,
+	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection, 
+	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public Object
+{
+	DECLARE_REF(eServiceEPlayer3);
+public:
+	virtual ~eServiceEPlayer3();
+
+		// iPlayableService
+	RESULT connectEvent(const Slot2<void, iPlayableService*, int> &event, ePtr<eConnection> &connection);
+	RESULT start();
+	RESULT stop();
+	RESULT setTarget(int target, bool noaudio);
+	
+	RESULT pause(ePtr<iPauseableService> &ptr);
+	RESULT setSlowMotion(int ratio);
+	RESULT setFastForward(int ratio);
+
+	RESULT seek(ePtr<iSeekableService> &ptr);
+	RESULT audioTracks(ePtr<iAudioTrackSelection> &ptr);
+	RESULT audioChannel(ePtr<iAudioChannelSelection> &ptr);
+	RESULT subtitle(ePtr<iSubtitleOutput> &ptr);
+	RESULT audioDelay(ePtr<iAudioDelay> &ptr);
+
+		// not implemented (yet)
+	RESULT frontendInfo(ePtr<iFrontendInformation> &ptr) { ptr = 0; return -1; }
+	RESULT subServices(ePtr<iSubserviceList> &ptr) { ptr = 0; return -1; }
+	RESULT timeshift(ePtr<iTimeshiftService> &ptr) { ptr = 0; return -1; }
+	RESULT cueSheet(ePtr<iCueSheet> &ptr) { ptr = 0; return -1; }
+
+	RESULT rdsDecoder(ePtr<iRdsDecoder> &ptr) { ptr = 0; return -1; }
+	RESULT keys(ePtr<iServiceKeys> &ptr) { ptr = 0; return -1; }
+	RESULT stream(ePtr<iStreamableService> &ptr) { ptr = 0; return -1; }
+
+		// iPausableService
+	RESULT pause();
+	RESULT unpause();
+	
+	RESULT info(ePtr<iServiceInformation>&);
+	
+		// iSeekableService
+	RESULT getLength(pts_t &SWIG_OUTPUT);
+	RESULT seekTo(pts_t to);
+	RESULT seekRelative(int direction, pts_t to);
+	RESULT getPlayPosition(pts_t &SWIG_OUTPUT);
+	RESULT setTrickmode(int trick);
+	RESULT isCurrentlySeekable();
+
+		// iServiceInformation
+	RESULT getName(std::string &name);
+	int getInfo(int w);
+	std::string getInfoString(int w);
+
+		// iAudioTrackSelection	
+	int getNumberOfTracks();
+	RESULT selectTrack(unsigned int i);
+	RESULT getTrackInfo(struct iAudioTrackInfo &, unsigned int n);
+	int getCurrentTrack();
+
+		// iAudioChannelSelection	
+	int getCurrentChannel();
+	RESULT selectChannel(int i);
+
+		// iSubtitleOutput
+	RESULT enableSubtitles(iSubtitleUser *user, SubtitleTrack &track);
+	RESULT disableSubtitles();
+	RESULT getSubtitleList(std::vector<SubtitleTrack> &sublist);
+	RESULT getCachedSubtitle(SubtitleTrack &track);
+
+		// iStreamedService
+	RESULT streamed(ePtr<iStreamedService> &ptr);
+	ePtr<iStreamBufferInfo> getBufferCharge();
+	int setBufferSize(int size);
+
+		// iAudioDelay
+	int getAC3Delay();
+	int getPCMDelay();
+	void setAC3Delay(int);
+	void setPCMDelay(int);
+
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+
+	struct bufferInfo
+	{
+		gint bufferPercent;
+		gint avgInRate;
+		gint avgOutRate;
+		gint64 bufferingLeft;
+		bufferInfo()
+			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
+		{
+		}
+	};
+	struct errorInfo
+	{
+		std::string error_message;
+		std::string missing_codec;
+	};
+
+private:
+#if not defined ENABLE_MEDIAFWGSTREAMER
+	Player *player;
+#endif
+	static int pcm_delay;
+	static int ac3_delay;
+	int m_currentAudioStream;
+	int m_currentSubtitleStream;
+	int m_cachedSubtitleStream;
+	int selectAudioStream(int i);
+	std::vector<audioStream> m_audioStreams;
+	std::vector<subtitleStream> m_subtitleStreams;
+	iSubtitleUser *m_subtitle_widget;
+
+	int m_currentTrickRatio;
+
+	friend class eServiceFactoryEPlayer3;
+	eServiceReference m_ref;
+	int m_buffer_size;
+
+	bufferInfo m_bufferInfo;
+	errorInfo m_errorInfo;
+	std::string m_download_buffer_path;
+	eServiceEPlayer3(eServiceReference ref);
+	Signal2<void,iPlayableService*,int> m_event;
+	enum
+	{
+		stIdle, stRunning, stStopped,
+	};
+	int m_state;
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	Context_t * player;
+#endif
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+
+	struct subtitle_page_t
+	{
+		uint32_t start_ms;
+		uint32_t end_ms;
+		std::string text;
+
+		subtitle_page_t(uint32_t start_ms_in, uint32_t end_ms_in, std::string text_in)
+			: start_ms(start_ms_in), end_ms(end_ms_in), text(text_in)
+		{
+		}
+	};
+
+	typedef std::map<uint32_t, subtitle_page_t> subtitle_pages_map_t;
+	typedef std::pair<uint32_t, subtitle_page_t> subtitle_pages_map_pair_t;
+	subtitle_pages_map_t m_subtitle_pages;
+	ePtr<eTimer> m_subtitle_sync_timer;
+	
+	ePtr<eTimer> m_streamingsrc_timeout;
+	pts_t m_prev_decoder_time;
+	int m_decoder_time_valid_state;
+
+	void pushSubtitles();
+
+	void sourceTimeout();
+	sourceStream m_sourceinfo;
+
+	RESULT seekToImpl(pts_t to);
+
+	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
+	std::string m_useragent;
+};
+
+#endif
--- enigma2.org/lib/service/servicemp3.cpp
+++ enigma2/lib/service/servicemp3.cpp
@@ -17,11 +17,13 @@
 
 #include <string>
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
-#define HTTP_TIMEOUT 30
+#define HTTP_TIMEOUT 60
 
 /*
  * UNUSED variable from service reference is now used as buffer flag for gstreamer
@@ -73,6 +75,11 @@
 #undef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
 #endif
 /**/
+
+void mp3Blit(){
+	fbClass *fb = fbClass::getInstance();
+	fb->blit();
+}
 
 eServiceFactoryMP3::eServiceFactoryMP3()
 {
@@ -98,26 +105,50 @@
 		extensions.push_back("aac");
 		extensions.push_back("ape");
 		extensions.push_back("alac");
-		extensions.push_back("mpg");
-		extensions.push_back("vob");
+		extensions.push_back("flv");
+		extensions.push_back("m4a");
+		extensions.push_back("3gp");
+		extensions.push_back("3g2");
+		extensions.push_back("asf");
+#if defined(__sh__)
+#if !defined(ENABLE_MEDIAFWGSTREAMER) || !defined(ENABLE_LIBEPLAYER3)
+/* Hellmaster1024: if both gst and eplayer3 are enabled, this is the GST service!
+ * We only select the audio extensions (above), and leave the Video extensions for
+ * the ePlayer3 service located in serviceeplayer3
+ * If only one of GST and ePlayer3 this service handles all extensions and switches between
+ * GST and ePlayer3
+*/
 		extensions.push_back("m4v");
 		extensions.push_back("mkv");
 		extensions.push_back("avi");
 		extensions.push_back("divx");
 		extensions.push_back("dat");
-		extensions.push_back("flv");
 		extensions.push_back("mp4");
 		extensions.push_back("mov");
-		extensions.push_back("wmv");
-		extensions.push_back("asf");
-		extensions.push_back("3gp");
-		extensions.push_back("3g2");
 		extensions.push_back("mpeg");
 		extensions.push_back("mpe");
 		extensions.push_back("rm");
 		extensions.push_back("rmvb");
 		extensions.push_back("ogm");
 		extensions.push_back("ogv");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+ 		extensions.push_back("wmv");
+#endif
+#endif
+ 		extensions.push_back("wma");
 		extensions.push_back("stream");
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
@@ -349,6 +380,7 @@
 	return bufferSize;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(eServiceMP3InfoContainer);
 
 eServiceMP3InfoContainer::eServiceMP3InfoContainer()
@@ -399,6 +431,7 @@
 	bufferSize = map.size;
 #endif
 }
+#endif
 
 // eServiceMP3
 int eServiceMP3::ac3_delay = 0,
@@ -412,13 +445,16 @@
 	m_pump(eApp, 1)
 {
 	m_subtitle_sync_timer = eTimer::create(eApp);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_stream_tags = 0;
+#endif
 	m_currentAudioStream = -1;
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = -2; /* report subtitle stream to be 'cached'. TODO: use an actual cache. */
 	m_subtitle_widget = 0;
 	m_currentTrickRatio = 1.0;
 	m_buffer_size = 5 * 1024 * 1024;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_ignore_buffering_messages = 0;
 	m_is_live = false;
 	m_use_prefillbuffer = false;
@@ -432,13 +468,18 @@
 	m_useragent = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenPLi;;;)";
 	m_extra_headers = "";
 	m_download_buffer_path = "";
+#endif
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	m_errorInfo.missing_codec = "";
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	audioSink = videoSink = NULL;
+#endif
 
 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
 	CONNECT(m_nownext_timer->timeout, eServiceMP3::updateEpgCacheNowNext);
 	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
 
@@ -471,6 +512,7 @@
 	if (!ext)
 		ext = filename + strlen(filename);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_sourceinfo.is_video = FALSE;
 	m_sourceinfo.audiotype = atUnknown;
 	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpe") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )
@@ -652,10 +694,178 @@
 		eDebug("[eServiceMP3] sorry, can't play: %s",m_errorInfo.error_message.c_str());
 	}
 	g_free(uri);
+#else
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		out.framebufferBlit = mp3Blit;
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("eServiceMP3-<\n");
+#endif
 }
 
 eServiceMP3::~eServiceMP3()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	// disconnect subtitle callback
 	GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
 
@@ -664,10 +874,12 @@
 		g_signal_handler_disconnect (subsink, m_subs_to_pull_handler_id);
 		gst_object_unref(subsink);
 	}
+#endif
 
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 	m_subtitle_widget = 0;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
@@ -679,9 +891,11 @@
 #endif
 		gst_object_unref(bus);
 	}
+#endif
 
 	stop();
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_stream_tags)
 		gst_tag_list_free(m_stream_tags);
 
@@ -700,6 +914,7 @@
 		gst_object_unref (GST_OBJECT (m_gst_playbin));
 		eDebug("[eServiceMP3] destruct!");
 	}
+#endif
 }
 
 void eServiceMP3::updateEpgCacheNowNext()
@@ -749,18 +964,33 @@
 
 DEFINE_REF(eServiceMP3);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(GstMessageContainer);
+#endif
 
 RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	m_event(this, evSeekableStatusChanged);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::start()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ASSERT(m_state == stIdle);
-
+#else
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		eDebug("[eServiceMP3] starting pipeline");
@@ -783,6 +1013,15 @@
 			break;
 		}
 	}
+#else
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#endif
+
+	m_event(this, evStart);
 
 	return 0;
 }
@@ -820,41 +1059,123 @@
 	return 0;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+#endif
+
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!ratio)
 		return 0;
 	eDebug("[eServiceMP3] setSlowMotion ratio=%f",1.0/(gdouble)ratio);
 	return trickSeek(1.0/(gdouble)ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
-	eDebug("[eServiceMP3] setFastForward ratio=%i",ratio);
+#ifdef ENABLE_MEDIAFWGSTREAMER
+//	eDebug("[eServiceMP3] setFastForward ratio=%i",ratio);
 	return trickSeek(ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	eDebug("[eServiceMP3] pause");
 	trickSeek(0.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
 
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
-	/* no need to unpase if we are not paused already */
+	/* no need to unpause if we are not paused already */
 	if (m_currentTrickRatio == 1.0 && !m_paused)
 	{
 		eDebug("[eServiceMP3] trickSeek no need to unpause!");
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
 		return 0;
 	}
 
@@ -873,6 +1194,7 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
@@ -887,11 +1209,23 @@
 		/* len is in nanoseconds. we have 90 000 pts per second. */
 
 	pts = len / 11111LL;
+#else
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		/* convert pts to nanoseconds */
 #if GST_VERSION_MAJOR < 1
 	gint64 time_nanoseconds = to * 11111LL;
@@ -921,22 +1255,31 @@
 
 	return 0;
 }
+#endif
 
 RESULT eServiceMP3::seekTo(pts_t to)
 {
 	RESULT ret = -1;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
 		ret = seekToImpl(to);
 	}
-
+#else
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	ret =0;
+#endif
 	return ret;
 }
 
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
@@ -1045,21 +1388,32 @@
 	m_decoder_time_valid_state = 0;
 	return 0;
 }
-
+#endif
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin)
 		return -1;
+#endif
 
 	pts_t ppos;
 	if (getPlayPosition(ppos) < 0) return -1;
 	ppos += to * direction;
 	if (ppos < 0)
 		ppos = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	return seekTo(ppos);
-}
-
+#else
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+#endif
+}
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #if GST_VERSION_MAJOR < 1
 gint eServiceMP3::match_sinktype(GstElement *element, gpointer type)
 {
@@ -1143,9 +1497,11 @@
 	return value;
 }
 #endif
+#endif
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gint64 pos;
 	pts = 0;
 
@@ -1182,6 +1538,27 @@
 
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111LL;
+#else
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
 	return 0;
 }
 
@@ -1193,12 +1570,16 @@
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER // Hellmaster1024: 1 for skipping 3 for skipping anf fast forward
 	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
 
 	if (!m_gst_playbin)
 		return 0;
 
 	return ret;
+#else
+	return 3;
+#endif
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -1232,7 +1613,9 @@
 
 int eServiceMP3::getInfo(int w)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	const gchar *tag = 0;
+#endif
 
 	switch (w)
 	{
@@ -1272,7 +1655,9 @@
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
@@ -1283,6 +1668,7 @@
 	case sTagPreviewImage:
 	case sTagAttachment:
 		return resIsPyObject;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	case sTagTrackNumber:
 		tag = GST_TAG_TRACK_NUMBER;
 		break;
@@ -1316,17 +1702,20 @@
 	case sTagCRC:
 		tag = "has-crc";
 		break;
+#endif
 	case sBuffer: return m_bufferInfo.bufferPercent;
 	default:
 		return resNA;
 	}
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_stream_tags || !tag)
 		return 0;
 
 	guint value;
 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
 		return (int) value;
+#endif
 
 	return 0;
 }
@@ -1351,6 +1740,7 @@
 		}
 	}
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if ( !m_stream_tags && w < sUser && w > 26 )
 		return "";
 	const gchar *tag = 0;
@@ -1478,9 +1868,69 @@
 		g_free(value);
 		return res;
 	}
+#else
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+#endif
 	return "";
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 ePtr<iServiceInfoContainer> eServiceMP3::getInfoObject(int w)
 {
 	eServiceMP3InfoContainer *container = new eServiceMP3InfoContainer;
@@ -1544,6 +1994,7 @@
 	}
 	return retval;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1582,13 +2033,16 @@
 
 int eServiceMP3::getCurrentTrack()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_currentAudioStream == -1)
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
 	return m_currentAudioStream;
 }
 
 RESULT eServiceMP3::selectTrack(unsigned int i)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	bool validposition = false;
 	pts_t ppos = 0;
 	if (getPlayPosition(ppos) >= 0)
@@ -1603,11 +2057,13 @@
 		/* flush */
 		seekTo(ppos);
 	}
+#endif
 	return selectAudioStream(i);
 }
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 #if HAVE_AMLOGIC
@@ -1622,6 +2078,16 @@
 		return 0;
 	}
 	return -1;
+#else
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1640,10 +2106,33 @@
 	if (i >= m_audioStreams.size())
 	{
 		return -2;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+		info.m_description = m_audioStreams[i].codec;
+/*	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+	else if (m_audioStreams[i].type == atFLAC)
+		info.m_description = "FLAC";
+	else
+		info.m_description = "???";*/
+	}
+#else
 	}
 
 	info.m_description = m_audioStreams[i].codec;
 
+#endif
 	if (info.m_language.empty())
 	{
 		info.m_language = m_audioStreams[i].language_code;
@@ -1652,6 +2141,7 @@
 	return 0;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
 {
 	subtype_t type = stUnknown;
@@ -2551,9 +3041,11 @@
 		}
 	}
 }
+#endif
 
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
@@ -2686,9 +3178,30 @@
 #endif
 	}
 }
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
 
 void eServiceMP3::pushSubtitles()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	pts_t running_pts = 0;
 	int32_t next_timer = 0, decoder_ms, start_ms, end_ms, diff_start_ms, diff_end_ms;
 	subtitle_pages_map_t::iterator current;
@@ -2789,24 +3302,30 @@
 
 	m_subtitle_sync_timer->start(next_timer, true);
 
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
 {
 	if (m_currentSubtitleStream != track.pid)
 	{
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
+#endif
 		m_subtitle_sync_timer->stop();
 		m_subtitle_pages.clear();
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		m_currentSubtitleStream = track.pid;
 		m_cachedSubtitleStream = m_currentSubtitleStream;
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 
 		m_subtitle_widget = user;
 
-		eDebug ("[eServiceMP3] switched to subtitle stream %i", m_currentSubtitleStream);
+#ifdef ENABLE_MEDIAFWGSTREAMER
+//		eDebug ("[eServiceMP3] switched to subtitle stream %i", m_currentSubtitleStream);
 
 #ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
 		/*
@@ -2815,23 +3334,37 @@
 		 */
 		seekRelative(-1, 90000);
 #endif
-	}
+#endif
+	}
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+#endif
 
 	return 0;
 }
 
 RESULT eServiceMP3::disableSubtitles()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	eDebug("[eServiceMP3] disableSubtitles");
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = m_currentSubtitleStream;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 	m_subtitle_sync_timer->stop();
 	m_subtitle_pages.clear();
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 	m_subtitle_widget = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 	return 0;
 }
 
@@ -2993,7 +3526,9 @@
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -3009,6 +3544,7 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -3036,10 +3572,12 @@
 			eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -3067,6 +3605,7 @@
 			eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
 		}
 	}
+#endif
 }
 /* cuesheet CVR */
 void eServiceMP3::loadCuesheet()
--- enigma2.org/lib/service/servicemp3.h
+++ enigma2/lib/service/servicemp3.h
@@ -6,7 +6,18 @@
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#else
+#include <common.h>
+#include <subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -68,7 +79,9 @@
 	DECLARE_REF(eServiceMP3InfoContainer);
 
 	double doubleValue;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	GstBuffer *bufferValue;
+#endif
 
 	unsigned char *bufferData;
 	unsigned int bufferSize;
@@ -83,9 +96,12 @@
 	double getDouble(unsigned int index) const;
 	unsigned char *getBuffer(unsigned int &size) const;
 	void setDouble(double value);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	void setBuffer(GstBuffer *buffer);
-};
-
+#endif
+};
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
 class GstMessageContainer: public iObject
 {
 	DECLARE_REF(GstMessageContainer);
@@ -115,6 +131,7 @@
 };
 
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
 typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
@@ -179,7 +196,9 @@
 	RESULT getEvent(ePtr<eServiceEvent> &evt, int nownext);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ePtr<iServiceInfoContainer> getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection
 	int getNumberOfTracks();
@@ -212,6 +231,8 @@
 	void AmlSwitchAudio(int index);
 	unsigned int get_pts_pcrscr(void);
 #endif
+
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	struct audioStream
 	{
 		GstPad* pad;
@@ -244,6 +265,38 @@
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
 	struct bufferInfo
 	{
 		gint bufferPercent;
@@ -296,10 +349,15 @@
 	std::vector<audioStream> m_audioStreams;
 	std::vector<subtitleStream> m_subtitleStreams;
 	iSubtitleUser *m_subtitle_widget;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gdouble m_currentTrickRatio;
+#else
+	int m_currentTrickRatio;
+#endif
 	friend class eServiceFactoryMP3;
 	eServiceReference m_ref;
 	int m_buffer_size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	int m_ignore_buffering_messages;
 	bool m_is_live;
 	bool m_use_prefillbuffer;
@@ -323,6 +381,8 @@
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#endif
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	GstElement *m_gst_playbin, *audioSink, *videoSink;
 	GstTagList *m_stream_tags;
 
@@ -346,6 +406,22 @@
 	static gint match_sinktype(const GValue *velement, const gchar *type);
 #endif
 	static void handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data);
+#else
+	Context_t * player;
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+#endif
 
 	struct subtitle_page_t
 	{
@@ -368,17 +444,23 @@
 	int m_decoder_time_valid_state;
 
 	void pushSubtitles();
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	void pullSubtitle(GstBuffer *buffer);
+#endif
 	void sourceTimeout();
 	sourceStream m_sourceinfo;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gulong m_subs_to_pull_handler_id;
+#endif
 
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
 	std::string m_useragent;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	std::string m_extra_headers;
 	RESULT trickSeek(gdouble ratio);
-};
-
-#endif
+#endif
+};
+
+#endif
--- enigma2.org/lib/service/servicets.cpp
+++ enigma2/lib/service/servicets.cpp
@@ -111,6 +111,7 @@
 
 DEFINE_REF(eServiceTS);
 
+#if 0
 static size_t crop(char *buf)
 {
 	size_t len = strlen(buf) - 1;
@@ -119,6 +120,7 @@
 	}
 	return len;
 }
+#endif
 
 static int getline(char** pbuffer, size_t* pbufsize, int fd)
 {
--- enigma2.org/lib/service/servicewebts.cpp
+++ enigma2/lib/service/servicewebts.cpp
@@ -182,6 +182,7 @@
 
 DEFINE_REF(eServiceWebTS);
 
+#if 0
 static size_t crop(char *buf)
 {
 	size_t len = strlen(buf) - 1;
@@ -190,6 +191,7 @@
 	}
 	return len;
 }
+#endif
 
 static int getline(char** pbuffer, size_t* pbufsize, int fd)
 {
--- enigma2.org/m4/ax_python_devel.m4
+++ enigma2/m4/ax_python_devel.m4
@@ -154,7 +154,7 @@
 		python_path=`$PYTHON -c "import distutils.sysconfig; \
 			print (distutils.sysconfig.get_python_inc ());"`
 		if test -n "${python_path}"; then
-			python_path="-I$python_path"
+			python_path="-I$PY_PATH/include/python$PYTHON_VER_MAJOR"
 		fi
 		PYTHON_CPPFLAGS=$python_path
 	fi
@@ -235,7 +235,8 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LDFLAGS="-L$PY_PATH/include/python$PYTHON_VER_MAJOR -lpython$ac_python_version"
+#			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LDFLAGS"; then
@@ -253,8 +254,9 @@
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH/lib/python$PYTHON_VER_MAJOR/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
--- enigma2.org/main/bsod.cpp
+++ enigma2/main/bsod.cpp
@@ -162,7 +162,7 @@
 	gPainter p(my_dc);
 	p.resetOffset();
 	p.resetClip(eRect(ePoint(0, 0), my_dc->size()));
-	p.setBackgroundColor(gRGB(0x008000));
+	p.setBackgroundColor(gRGB(0x000080));
 	p.setForegroundColor(gRGB(0xFFFFFF));
 
 	int hd =  my_dc->size().width() == 1920;
@@ -177,13 +177,13 @@
 	os << "We are really sorry. Your STB encountered "
 		"a software problem, and needs to be restarted.\n"
 		"Please send the logfile " << crashlog_name << " to " << crash_emailaddr << ".\n"
-		"Your STB restarts in 10 seconds!\n"
+		"Your STB will restart in 30 seconds...\n"
 		"Component: " << component;
 
 	p.renderText(usable_area, os.str().c_str(), gPainter::RT_WRAP|gPainter::RT_HALIGN_LEFT);
 
 	std::string logtail;
-	int lines = 20;
+	int lines = 35;
 	
 	if (logp2)
 	{
@@ -227,12 +227,12 @@
 
 	if (!logtail.empty())
 	{
-		font = new gFont("Regular", hd ? 21 : 14);
+		font = new gFont("Regular", hd ? 14 : 10);
 		p.setFont(font);
 		usable_area = eRect(hd ? 30 : 100, hd ? 180 : 170, my_dc->size().width() - (hd ? 60 : 180), my_dc->size().height() - (hd ? 30 : 20));
 		p.renderText(usable_area, logtail, gPainter::RT_HALIGN_LEFT);
 	}
-	sleep(10);
+	sleep(30);
 
 	/*
 	 * When 'component' is NULL, we are called because of a python exception.
--- enigma2.org/main/enigma.cpp
+++ enigma2/main/enigma.cpp
@@ -32,10 +32,20 @@
 #include <lib/python/pythonconfig.h>
 #include <lib/service/servicepeer.h>
 
+#ifndef ENABLE_MEDIAFWGSTREAMER
+#include <fstream>
+#include <sstream>
+#endif
+
+#if defined(__sh__) // vfd class
+#include <lib/driver/vfd.h>
+#endif
 #include "bsod.h"
 #include "version_info.h"
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#endif
 
 #ifdef OBJECT_DEBUG
 int object_total_remaining;
@@ -187,7 +197,9 @@
 	atexit(object_dump);
 #endif
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gst_init(&argc, &argv);
+#endif
 
 	// set pythonpath if unset
 	setenv("PYTHONPATH", eEnv::resolve("${libdir}/enigma2/python").c_str(), 0);
@@ -195,7 +207,7 @@
 	printf("DVB_API_VERSION %d DVB_API_VERSION_MINOR %d\n", DVB_API_VERSION, DVB_API_VERSION_MINOR);
 
 	// get enigma2 debug level settings
-	debugLvl = getenv("ENIGMA_DEBUG_LVL") ? atoi(getenv("ENIGMA_DEBUG_LVL")) : 3;
+	debugLvl = getenv("ENIGMA_DEBUG_LVL") ? atoi(getenv("ENIGMA_DEBUG_LVL")) : 4;
 	if (debugLvl < 0)
 		debugLvl = 0;
 	printf("ENIGMA_DEBUG_LVL=%d\n", debugLvl);
@@ -226,6 +238,11 @@
 	eWidgetDesktop dsk_lcd(my_lcd_dc->size());
 
 	dsk.setStyleID(0);
+#ifdef HAVE_GRAPHLCD
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 320 ? 1 : 2);
+#else
+ 	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 96 ? 2 : 1);
+#endif
 	dsk_lcd.setStyleID(1);
 
 /*	if (double_buffer)
@@ -266,14 +283,14 @@
 				if (!i)
 					eDebug("[MAIN] failed to load %s: %m", rfilename.c_str());
 				else
-					eDebug("[MAIN] found %d spinner!\n", i);
+					eDebug("[MAIN] found %d spinners!\n", i);
 				break;
 			}
 		}
 		if (i)
-			my_dc->setSpinner(eRect(ePoint(100, 100), wait[0]->size()), wait, i);
+			my_dc->setSpinner(eRect(ePoint(50, 50), wait[0]->size()), wait, i);
 		else
-			my_dc->setSpinner(eRect(100, 100, 0, 0), wait, 1);
+			my_dc->setSpinner(eRect(50, 50, 0, 0), wait, 1);
 	}
 
 	gRC::getInstance()->setSpinnerDC(my_dc);
@@ -343,7 +366,11 @@
 
 const char *getGStreamerVersionString()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	return gst_version_string();
+#else
+	return "ePlayer3";
+#endif
 }
 
 #include <malloc.h>
--- enigma2.org/main/Makefile.am
+++ enigma2/main/Makefile.am
@@ -8,6 +8,8 @@
 	$(LIBSDL_CFLAGS)
 
 bin_PROGRAMS = enigma2
+
+installdir = $(targetprefix)/usr/local/bin
 
 enigma2_SOURCES = \
 	bsod.cpp \
@@ -48,6 +50,26 @@
 	@AVAHI_LIBS@ \
 	-ltuxtxt -ltuxtxt32bpp -lcrypt -lrt
 
+if ENABLE_LIBEPLAYER3
+if ENABLE_MEDIAFWGSTREAMER
+enigma2_LDADD += \
+	-leplayer3
+else
+enigma2_LDADD_WHOLE += \
+	$(top_builddir)/../../apps/tools/eplayer3/libeplayer3.a
+enigma2_LDADD += \
+	@AVFORMAT_LIBS@ \
+	@AVUTIL_LIBS@ \
+	@AVCODEC_LIBS@ \
+	@SWSCALE_LIBS@ \
+	@SWRESAMPLE_LIBS@
+endif
+endif
+
+if HAVE_GRAPHLCD
+enigma2_LDADD += -lglcddrivers -lglcdgraphics -lglcdskin
+endif
+
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
 if HAVE_GIT_DIR
--- enigma2.org/mytest.py
+++ enigma2/mytest.py
@@ -295,6 +295,10 @@
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+
+		if dlg is None:
+			return
+
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -488,10 +492,10 @@
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+		if (startTime[0] - nowTime) < 330: # no time to switch box back on
 			wptime = nowTime + 30  # so switch back on in 30 seconds
 		else:
-			wptime = startTime[0] - 240
+			wptime = startTime[0] - 300
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
--- enigma2.org/lib/gdi/picload.cpp
+++ enigma2/lib/gdi/picload.cpp
@@ -35,7 +35,7 @@
 		return orgin;
 	}
 	const int stride = 3 * dx;
-	#pragma omp parallel for
+//	#pragma omp parallel for
 	for (int j = 0; j < dy; j++)
 	{
 		unsigned char* p = cr + (j * stride);
@@ -477,8 +477,10 @@
 	ColorMapObject *cmap;
 	int cmaps;
 	int extcode;
-
-	gft = DGifOpenFileName(filepara->file, &extcode);
+	int GifLastError;
+
+	gft = DGifOpenFileName(filepara->file, &GifLastError); 
+
 	if (gft == NULL)
 		return;
 	do
@@ -568,11 +570,11 @@
 	}
 	while (rt != TERMINATE_RECORD_TYPE);
 
-	DGifCloseFile(gft, &extcode);
+	DGifCloseFile(gft, &GifLastError);
 	return;
 ERROR_R:
 	eDebug("[ePicLoad] <Error gif>");
-	DGifCloseFile(gft, &extcode);
+	DGifCloseFile(gft, &GifLastError);
 }
 
 //---------------------------------------------------------------------------------------------
@@ -1019,11 +1021,11 @@
 			for (int x = 0; x < m_filepara->max_x; ++x) // fill first line
 				*row_buffer++ = background;
 			int y;
-			#pragma omp parallel for
+//			#pragma omp parallel for
 			for (y = 1; y < yoff; ++y) // copy from first line
 				memcpy(tmp_buffer + y*surface->stride, tmp_buffer,
 					m_filepara->max_x * surface->bypp);
-			#pragma omp parallel for
+//			#pragma omp parallel for
 			for (y = yoff + scry; y < m_filepara->max_y; ++y)
 				memcpy(tmp_buffer + y * surface->stride, tmp_buffer,
 					m_filepara->max_x * surface->bypp);
@@ -1036,7 +1038,7 @@
 			row_buffer += scrx;
 			for (x = xoff + scrx; x < m_filepara->max_x; ++x) // fill right side of first line
 				*row_buffer++ = background;
-			#pragma omp parallel for
+//			#pragma omp parallel for
 			for (int y = yoff + 1; y < scry; ++y) { // copy from first line
 				memcpy(tmp_buffer + y*surface->stride,
 					tmp_buffer + yoff * surface->stride,
@@ -1119,7 +1121,7 @@
 	// Fill surface with image data, resize and correct for orientation on the fly
 	if (m_filepara->bits == 8)
 	{
-		#pragma omp parallel for
+//		#pragma omp parallel for
 		for (int y = 0; y < scry; ++y) {
 			const unsigned char *irow, *irowy = origin + iyfac * (int)(y * yscale);
 			unsigned char *srow = tmp_buffer + surface->stride * y;
@@ -1133,7 +1135,7 @@
 	}
 	else // 24-bit images
 	{
-		#pragma omp parallel for
+//		#pragma omp parallel for
 		for (int y = 0; y < scry; ++y) {
 			const unsigned char *irow, *irowy = origin + iyfac * (int)(yscale * y);
 			unsigned char *srow = tmp_buffer + surface->stride * y;
--- enigma2.org/lib/python/Screens/InstallWizard.py
+++ enigma2.patched/lib/python/Screens/InstallWizard.py
@@ -44,7 +44,7 @@
 			if is_found is False:
 				self.createMenu()
 		elif self.index == self.STATE_CHOISE_CHANNELLIST:
-			self.enabled = ConfigYesNo(default = True)
+			self.enabled = ConfigYesNo(default = False)
 			modes = {"19e-23e-basis": "Astra1 Astra3 basis", "19e-23e": "Astra 1 Astra 3", "19e-23e-28e": "Astra 1 Astra 2 Astra 3", "13e-19e-23e-28e": "Astra 1 Astra 2 Astra 3 Hotbird", "kabelnl": "Kabel-NL"}
 			self.channellist_type = ConfigSelection(choices = modes, default = "19e-23e-basis")
 			self.createMenu()
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
+++ enigma2.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
@@ -9,6 +9,7 @@
 from Tools.Directories import resolveFilename, SCOPE_PLUGINS
 from Tools.HardwareInfo import HardwareInfo
+from enigma import evfd
 
-config.misc.showtestcard = ConfigBoolean(default = False)
+config.misc.showtestcard = ConfigBoolean(default = True)
 
 class VideoWizardSummary(WizardSummary):
@@ -70,6 +71,7 @@
 		config.misc.videowizardenabled.value = 0
 		config.misc.videowizardenabled.save()
 		configfile.save()
+		evfd.getInstance().vfd_write_string("                ")
 
 	def listInputChannels(self):
 		hw_type = HardwareInfo().get_device_name()
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/videowizard.xml
+++ enigma2.patched/lib/python/Plugins/SystemPlugins/Videomode/videowizard.xml
@@ -1,5 +1,5 @@
 <wizard>
-	<step id="inputselection" nextstep="modeselection" timeout="20" timeoutaction="selectnext">
+	<step id="inputselection" nextstep="modeselection" timeout="10" timeoutaction="selectnext">
-		<text value="Video input selection\n\nPlease press OK if you can see this page on your TV (or select a different input port).\n\nThe next input port will be automatically probed in 20 seconds." />
+		<text value="Video input selection\n\nPlease press OK if you can see this page on your TV (or select a different input port).\n\nThe next input port will be automatically probed in 10 seconds." />
 		<displaytext value="Select video input with up/down buttons" />
 		<list type="dynamic" source="listInputChannels" evaluation="inputSelectionMade" onselect="inputSelectionMoved" />
@@ -9,7 +9,7 @@
 self.selectKey("OK")
 		</code>
 	</step>
-	<step id="modeselection" nextstep="rateselection" timeout="20" timeoutaction="selectnext">
+	<step id="modeselection" nextstep="rateselection" timeout="10" timeoutaction="selectnext">
 		<text value="Video mode selection." />
 		<displaytext value="Select video mode" />
 		<list type="dynamic" source="listModes" evaluation="modeSelectionMade" onselect="modeSelectionMoved" />
@@ -20,7 +20,7 @@
 self["portpic"].hide()
 		</code>
 	</step>
-	<step id="rateselection" timeout="20" timeoutaction="selectnext">
+	<step id="rateselection" timeout="10" timeoutaction="selectnext">
 		<condition>
 self.condition = (self.port != "DVI" or self.mode == "PC")
 		</condition>
--- enigma2.org/lib/python/Components/About.py
+++ enigma2/lib/python/Components/About.py
@@ -42,7 +42,7 @@
 		return _("unknown")
 
 def getHardwareTypeString():
-	return HardwareInfo().get_device_string()
+	return HardwareInfo().get_device_string().upper()
 
 def getImageTypeString():
 	try:
@@ -57,21 +57,12 @@
 		temperature = None
 		for line in open("/proc/cpuinfo").readlines():
 			line = [x.strip() for x in line.strip().split(":")]
-			if line[0] in ("system type", "model name"):
+			if line[0] in ("cpu type", "model name"):
 				processor = line[1].split()[0]
+				cpu_speed = "unknown"
 			elif line[0] == "cpu MHz":
 				cpu_speed = "%1.0f" % float(line[1])
-			elif line[0] == "processor":
 				cpu_count += 1
-		if not cpu_speed:
-			try:
-				cpu_speed = int(open("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq").read()) / 1000
-			except:
-				try:
-					import binascii
-					cpu_speed = int(int(binascii.hexlify(open('/sys/firmware/devicetree/base/cpus/cpu@0/clock-frequency', 'rb').read()), 16) / 100000000) * 100
-				except:
-					cpu_speed = "-"
 		if os.path.isfile('/proc/stb/fp/temp_sensor_avs'):
 			temperature = open("/proc/stb/fp/temp_sensor_avs").readline().replace('\n','')
 		if os.path.isfile("/sys/devices/virtual/thermal/thermal_zone0/temp"):
--- enigma2.org/lib/python/Screens/About.py
+++ enigma2/lib/python/Screens/About.py
@@ -36,7 +36,7 @@
 		AboutText += EnigmaVersion + "\n"
 		AboutText += _("Enigma (re)starts: %d\n") % config.misc.startCounter.value
 
-		GStreamerVersion = "GStreamer: " + about.getGStreamerVersionString().replace("GStreamer","")
+		GStreamerVersion = "Media framework: " + about.getGStreamerVersionString()
 		self["GStreamerVersion"] = StaticText(GStreamerVersion)
 		AboutText += GStreamerVersion + "\n"
 
--- enigma2.org/lib/python/Tools/KeyBindings.py
+++ enigma2/lib/python/Tools/KeyBindings.py
@@ -5,7 +5,7 @@
 from Components.config import config
 from Components.RcModel import rc_model
 
-keyDescriptions = [{
+keyDescriptions = [{ # for remotes with ID 0 (DMM)
 		KEYIDS["BTN_0"]: ("UP", "fp"),
 		KEYIDS["BTN_1"]: ("DOWN", "fp"),
 		KEYIDS["KEY_OK"]: ("OK", ""),
@@ -47,7 +47,7 @@
 		KEYIDS["KEY_STOP"]: ("STOP",),
 		KEYIDS["KEY_RECORD"]: ("RECORD",)
 	},
-	{
+	{  # for remotes with ID 1 (DMM advanced)
 		KEYIDS["BTN_0"]: ("UP", "fp"),
 		KEYIDS["BTN_1"]: ("DOWN", "fp"),
 		KEYIDS["KEY_OK"]: ("OK", ""),
@@ -87,9 +87,12 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("TV", "SHIFT"),
-		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT")
-	},
-	{
+		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT"),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
+	},
+	{ # for remotes with ID 2 (default)
 		KEYIDS["BTN_0"]: ("UP", "fp"),
 		KEYIDS["BTN_1"]: ("DOWN", "fp"),
 		KEYIDS["KEY_OK"]: ("OK", ""),
@@ -133,36 +136,12 @@
 		KEYIDS["KEY_PAGEUP"]: ("PAGEUP",),
 		KEYIDS["KEY_PAGEDOWN"]: ("PAGEDOWN",)
 	},
-	{       # XP1000
-		KEYIDS["BTN_0"]: ("UP", "fp"),
-		KEYIDS["BTN_1"]: ("DOWN", "fp"),
-		KEYIDS["KEY_OK"]: ("OK", ""),
-		KEYIDS["KEY_UP"]: ("UP",),
-		KEYIDS["KEY_DOWN"]: ("DOWN",),
+	{  # for remotes with ID 3 (Spark RC12)
 		KEYIDS["KEY_POWER"]: ("POWER",),
-		KEYIDS["KEY_RED"]: ("RED",),
-		KEYIDS["KEY_BLUE"]: ("BLUE",),
-		KEYIDS["KEY_GREEN"]: ("GREEN",),
-		KEYIDS["KEY_YELLOW"]: ("YELLOW",),
-		KEYIDS["KEY_MENU"]: ("MENU",),
-		KEYIDS["KEY_LEFT"]: ("LEFT",),
-		KEYIDS["KEY_RIGHT"]: ("RIGHT",),
-		KEYIDS["KEY_VIDEO"]: ("PVR",),
-		KEYIDS["KEY_INFO"]: ("INFO",),
-		KEYIDS["KEY_AUDIO"]: ("AUDIO",),
-		KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
-		KEYIDS["KEY_TV"]: ("TV",),
-		KEYIDS["KEY_RADIO"]: ("RADIO",),
-		KEYIDS["KEY_TEXT"]: ("TEXT",),
-		KEYIDS["KEY_NEXT"]: ("ARROWRIGHT",),
-		KEYIDS["KEY_PREVIOUS"]: ("ARROWLEFT",),
-		KEYIDS["KEY_PREVIOUSSONG"]: ("SKIPBACK",),
-		KEYIDS["KEY_REWIND"]: ("REWIND",),
-		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
-		KEYIDS["KEY_NEXTSONG"]: ("SKIPFORWARD",),
-		KEYIDS["KEY_PLAYPAUSE"]: ("PLAYPAUSE",),
-		KEYIDS["KEY_CHANNELUP"]: ("BOUQUET+",),
-		KEYIDS["KEY_CHANNELDOWN"]: ("BOUQUET-",),
+		KEYIDS["KEY_V"]: ("V.FORMAT",),
+		KEYIDS["KEY_AUX"]: ("TV/SAT",),
+		KEYIDS["KEY_TIME"]: ("TIME",),
+		KEYIDS["KEY_MUTE"]: ("MUTE",),
 		KEYIDS["KEY_0"]: ("0",),
 		KEYIDS["KEY_1"]: ("1",),
 		KEYIDS["KEY_2"]: ("2",),
@@ -173,63 +152,204 @@
 		KEYIDS["KEY_7"]: ("7",),
 		KEYIDS["KEY_8"]: ("8",),
 		KEYIDS["KEY_9"]: ("9",),
-		KEYIDS["KEY_EXIT"]: ("EXIT",),
-		KEYIDS["KEY_STOP"]: ("STOP",),
-		KEYIDS["KEY_RECORD"]: ("RECORD",),
-		KEYIDS["KEY_BOOKMARKS"]: ("PORTAL",),
-		KEYIDS["KEY_VMODE"]: ("VMODE",),
-		KEYIDS["KEY_PROGRAM"]: ("TIMER",),
-		KEYIDS["KEY_SLEEP"]: ("SLEEP",),
+		KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+		KEYIDS["KEY_BACK"]: ("RECALL",),
+		KEYIDS["KEY_PAGEUP"]: ("PAGE+",),
+		KEYIDS["KEY_PAGEDOWN"]: ("PAGE-",),
+		KEYIDS["KEY_FIND"]: ("FIND",),
+		KEYIDS["KEY_ARCHIVE"]: ("FOLDER",),
+		KEYIDS["KEY_VOLUMEUP"]: ("VOL+",),
+		KEYIDS["KEY_VOLUMEDOWN"]: ("VOL-",),
+		KEYIDS["KEY_MENU"]: ("MENU",),
+		KEYIDS["KEY_INFO"]: ("INFO",),
+		KEYIDS["KEY_UP"]: ("UP",),
+		KEYIDS["KEY_DOWN"]: ("DOWN",),
+		KEYIDS["KEY_LEFT"]: ("LEFT",),
+		KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+		KEYIDS["KEY_OK"]: ("OK", ""),
+		KEYIDS["KEY_HOME"]: ("EXIT",),
 		KEYIDS["KEY_EPG"]: ("EPG",),
-	},
-	{       # Formuler F1
-		KEYIDS["BTN_0"]: ("UP", "fp"),
-		KEYIDS["BTN_1"]: ("DOWN", "fp"),
-		KEYIDS["KEY_OK"]: ("OK", ""),
-		KEYIDS["KEY_UP"]: ("UP",),
-		KEYIDS["KEY_DOWN"]: ("DOWN",),
-		KEYIDS["KEY_POWER"]: ("POWER",),
-		KEYIDS["KEY_RED"]: ("RED",),
-		KEYIDS["KEY_BLUE"]: ("BLUE",),
-		KEYIDS["KEY_GREEN"]: ("GREEN",),
-		KEYIDS["KEY_YELLOW"]: ("YELLOW",),
-		KEYIDS["KEY_MENU"]: ("MENU",),
-		KEYIDS["KEY_LEFT"]: ("LEFT",),
-		KEYIDS["KEY_RIGHT"]: ("RIGHT",),
-		KEYIDS["KEY_VIDEO"]: ("PVR",),
-		KEYIDS["KEY_INFO"]: ("INFO",),
-		KEYIDS["KEY_AUDIO"]: ("AUDIO",),
-		KEYIDS["KEY_TV"]: ("TV",),
-		KEYIDS["KEY_RADIO"]: ("RADIO",),
-		KEYIDS["KEY_TEXT"]: ("TEXT",),
+		KEYIDS["KEY_FAVORITES"]: ("FAV",),
+		KEYIDS["KEY_SAT"]: ("SAT",),
+		KEYIDS["KEY_RED"]: ("RED",),
+		KEYIDS["KEY_GREEN"]: ("GREEN",),
+		KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+		KEYIDS["KEY_BLUE"]: ("BLUE",),
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_STOP"]: ("STOP",),
+		KEYIDS["KEY_PLAY"]: ("PLAY",),
+		KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_PREVIOUS"]: ("ARROWLEFT",),
 		KEYIDS["KEY_NEXT"]: ("ARROWRIGHT",),
-		KEYIDS["KEY_PREVIOUS"]: ("ARROWLEFT",),
-		KEYIDS["KEY_REWIND"]: ("REWIND",),
-		KEYIDS["KEY_PAUSE"]: ("PAUSE",),
-		KEYIDS["KEY_PLAY"]: ("PLAY",),
-		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
-		KEYIDS["KEY_CHANNELUP"]: ("BOUQUET+",),
-		KEYIDS["KEY_CHANNELDOWN"]: ("BOUQUET-",),
-		KEYIDS["KEY_0"]: ("0",),
-		KEYIDS["KEY_1"]: ("1",),
-		KEYIDS["KEY_2"]: ("2",),
-		KEYIDS["KEY_3"]: ("3",),
-		KEYIDS["KEY_4"]: ("4",),
-		KEYIDS["KEY_5"]: ("5",),
-		KEYIDS["KEY_6"]: ("6",),
-		KEYIDS["KEY_7"]: ("7",),
-		KEYIDS["KEY_8"]: ("8",),
-		KEYIDS["KEY_9"]: ("9",),
-		KEYIDS["KEY_EXIT"]: ("EXIT",),
-		KEYIDS["KEY_STOP"]: ("STOP",),
-		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_F"]: ("FAST",),
+		KEYIDS["KEY_SLOW"]: ("SLOW",),
+		KEYIDS["KEY_P"]: ("PLAY_MODE",),
+		KEYIDS["KEY_CLOSE"]: ("USB",),
+		KEYIDS["KEY_T"]: ("Tms",),
 		KEYIDS["KEY_F1"]: ("F1",),
 		KEYIDS["KEY_F2"]: ("F2",),
 		KEYIDS["KEY_F3"]: ("F3",),
-		KEYIDS["KEY_BACK"]: ("RECALL",),
-		KEYIDS["KEY_CONTEXT_MENU"]: ("CONTEXT",),
+		KEYIDS["KEY_OPEN"]: ("PORTAL",),
+	},
+	{  # for remotes with ID 4 (All Fortis)
+		KEYIDS["KEY_MUTE"]: ("MUTE",),
+		KEYIDS["KEY_POWER"]: ("STANDBY",),
+		KEYIDS["KEY_ANGLE"]: ("VFORMAT",),
+		KEYIDS["KEY_SCREEN"]: ("RESOLUTION",),
+		KEYIDS["KEY_1"]: ("1BUTTON",),
+		KEYIDS["KEY_2"]: ("2BUTTON",),
+		KEYIDS["KEY_3"]: ("3BUTTON",),
+		KEYIDS["KEY_4"]: ("4BUTTON",),
+		KEYIDS["KEY_5"]: ("5BUTTON",),
+		KEYIDS["KEY_6"]: ("6BUTTON",),
+		KEYIDS["KEY_7"]: ("7BUTTON",),
+		KEYIDS["KEY_8"]: ("8BUTTON",),
+		KEYIDS["KEY_9"]: ("9BUTTON",),
+		KEYIDS["KEY_HELP"]: ("INFO",),
+		KEYIDS["KEY_0"]: ("0BUTTON",),
+		KEYIDS["KEY_MEMO"]: ("RECALL",),
+		KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+		KEYIDS["KEY_MENU"]: ("MENU",),
+		KEYIDS["KEY_PAGEUP"]: ("CHANNELUP",),
+		KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+		KEYIDS["KEY_HOME"]: ("EXIT",),
+		KEYIDS["KEY_PAGEDOWN"]: ("CHANNELDOWN",),
+		KEYIDS["KEY_UP"]: ("UP",),
+		KEYIDS["KEY_LEFT"]: ("LEFT",),
+		KEYIDS["KEY_OK"]: ("OK",),
+		KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+		KEYIDS["KEY_DOWN"]: ("DOWN",),
+		KEYIDS["KEY_TEEN"]: ("UPUP",),
 		KEYIDS["KEY_EPG"]: ("EPG",),
-		KEYIDS["KEY_BOOKMARKS"]: ("PLAYLIST",),
+		KEYIDS["KEY_TWEN"]: ("DOWNDOWN",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_PLAY"]: ("PLAY",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+		KEYIDS["KEY_PREVIOUS"]: ("LAST",),
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_NEXT"]: ("NEXT",),
+		KEYIDS["KEY_DIRECTORY"]: ("OPEN",),
+		KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+		KEYIDS["KEY_STOP"]: ("STOP",),
+		KEYIDS["KEY_SELECT"]: ("CHECK",),
+		KEYIDS["KEY_RED"]: ("RED",),
+		KEYIDS["KEY_GREEN"]: ("GREEN",),
+		KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+		KEYIDS["KEY_BLUE"]: ("BLUE",),
+		KEYIDS["KEY_OPTION"]: ("PIP",),
+		KEYIDS["KEY_GOTO"]: ("SWAP",),
+#		KEYIDS["KEY_PIPSEL"]: ("PIP_SEL",), # PIP list
+		KEYIDS["KEY_SLOW"]: ("SLEEP",),
+		KEYIDS["KEY_FAVORITES"]: ("FAV",),
+		KEYIDS["KEY_MODE"]: ("TVRADIO",),
+		KEYIDS["KEY_SUBTITLE"]: ("LIST",),
+		KEYIDS["KEY_TEXT"]: ("TEXT",),
+		KEYIDS["KEY_ZOOM"]: ("ZOOM",),
+	},
+	{  # for remotes with ID 5 (Topfield TF77X0HDPVR)
+		KEYIDS["KEY_POWER"]: ("STANDBY",),
+		KEYIDS["KEY_MUTE"]: ("MUTE",),
+		KEYIDS["KEY_ZOOM"]: ("V.FORMAT",),
+		KEYIDS["KEY_SCREEN"]: ("A/R",),
+		KEYIDS["KEY_AUX"]: ("AUX",),
+		KEYIDS["KEY_1"]: ("1BUTTON",),
+		KEYIDS["KEY_2"]: ("2BUTTON",),
+		KEYIDS["KEY_3"]: ("3BUTTON",),
+		KEYIDS["KEY_4"]: ("4BUTTON",),
+		KEYIDS["KEY_5"]: ("5BUTTON",),
+		KEYIDS["KEY_6"]: ("6BUTTON",),
+		KEYIDS["KEY_7"]: ("7BUTTON",),
+		KEYIDS["KEY_8"]: ("8BUTTON",),
+		KEYIDS["KEY_9"]: ("9BUTTON",),
+		KEYIDS["KEY_BACK"]: ("BACK",),
+		KEYIDS["KEY_0"]: ("0BUTTON",),
+		KEYIDS["KEY_HELP"]: ("INFO",),
+		KEYIDS["KEY_LANGUAGE"]: ("AUDIO",),
+		KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
+		KEYIDS["KEY_TEXT"]: ("TEXT",),
+		KEYIDS["KEY_MENU"]: ("MENU",),
+		KEYIDS["KEY_EPG"]: ("GUIDE",),
+		KEYIDS["KEY_UP"]: ("UP/P+",),
+		KEYIDS["KEY_LEFT"]: ("LEFT/V-",),
+		KEYIDS["KEY_OK"]: ("OK/LIST",),
+		KEYIDS["KEY_RIGHT"]: ("RIGHT/V+",),
+		KEYIDS["KEY_DOWN"]: ("DOWN/P-",),
+		KEYIDS["KEY_HOME"]: ("EXIT",),
+		KEYIDS["KEY_FAVORITES"]: ("FAV",),
+		KEYIDS["KEY_RED"]: ("RED",),
+		KEYIDS["KEY_GREEN"]: ("GREEN",),
+		KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+		KEYIDS["KEY_BLUE"]: ("BLUE",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+		KEYIDS["KEY_PLAY"]: ("PLAY",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_STOP"]: ("STOP",),
+		KEYIDS["KEY_SLOW"]: ("SLOWMOTION",),
+		KEYIDS["KEY_LIST"]: ("RECORDLIST" ,),
+		KEYIDS["KEY_SAT"]: ("SAT",),
+		KEYIDS["KEY_PREVIOUS"]: ("STEPBACK",),
+		KEYIDS["KEY_NEXT"]: ("STEPFORWARD",),
+		KEYIDS["KEY_OPTION"]: ("MARK",),
+		KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+		KEYIDS["KEY_ARCHIVE"]: ("USB",),
+		KEYIDS["KEY_TIME"]: ("TIMER",),
+		# Frontpanel keys
+		KEYIDS["KEY_PAGEDOWN"]: ("CHANNELDOWN",),
+		KEYIDS["KEY_PAGEUP"]: ("CHANNELUP",),
+		KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+		KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+		KEYIDS["KEY_POWER"]: ("STANDBY",),
+	},
+	{  # for remotes with ID 6 (Kathrein UFS912)
+		KEYIDS["KEY_MEDIA"]: ("MEDIA",),
+		KEYIDS["KEY_ARCHIVE"]: ("ARCHIVE",),
+		KEYIDS["KEY_MENU"]: ("MENU",),
+		KEYIDS["KEY_RED"]: ("RED",),
+		KEYIDS["KEY_GREEN"]: ("GREEN",),
+		KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+		KEYIDS["KEY_BLUE"]: ("BLUE",),
+		KEYIDS["KEY_HOME"]: ("EXIT",),
+		KEYIDS["KEY_TEXT"]: ("TEXT",),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+		KEYIDS["KEY_PLAY"]: ("PLAY",),
+		KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_STOP"]: ("STOP",),
+		KEYIDS["KEY_POWER"]: ("STANDBY",),
+		KEYIDS["KEY_MUTE"]: ("MUTE",),
+		KEYIDS["KEY_PAGEUP"]: ("CHANNELUP",),
+		KEYIDS["KEY_PAGEDOWN"]: ("CHANNELDOWN",),
+		KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+		KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+		KEYIDS["KEY_HELP"]: ("HELP",),
+		KEYIDS["KEY_INFO"]: ("INFO",),
+		KEYIDS["KEY_OK"]: ("OK",),
+		KEYIDS["KEY_UP"]: ("UP",),
+		KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+		KEYIDS["KEY_DOWN"]: ("DOWN",),
+		KEYIDS["KEY_LEFT"]: ("LEFT",),
+		KEYIDS["KEY_0"]: ("0BUTTON",),
+		KEYIDS["KEY_1"]: ("1BUTTON",),
+		KEYIDS["KEY_2"]: ("2BUTTON",),
+		KEYIDS["KEY_3"]: ("3BUTTON",),
+		KEYIDS["KEY_4"]: ("4BUTTON",),
+		KEYIDS["KEY_5"]: ("5BUTTON",),
+		KEYIDS["KEY_6"]: ("6BUTTON",),
+		KEYIDS["KEY_7"]: ("7BUTTON",),
+		KEYIDS["KEY_8"]: ("8BUTTON",),
+		KEYIDS["KEY_9"]: ("9BUTTON",),
+		# Front panel keys
+		KEYIDS["KEY_MEDIA"]: ("FP_MEDIA",),
+		KEYIDS["KEY_POWER"]: ("FP_ON_OFF",),
+		KEYIDS["KEY_DOWN"]: ("FP_MINUS",),
+		KEYIDS["KEY_UP"]: ("FP_PLUS",),
+		KEYIDS["KEY_OK"]: ("FP_TV_R",),
 	},
 ]
 
@@ -248,10 +368,24 @@
 		idx = config.misc.rcused.value
 	else:
 		rctype = config.plugins.remotecontroltype.rctype.value
-		if rctype == 14:	# XP1000
+		print "[Keybindings.py] RC type is:", rctype
+		rctype = 11
+		if rctype == 10:	# Spark
 			idx = 3
-		elif rctype == 18:	# F1
+		elif rctype == 7:	# Fortis FS9000/FS9200/HS8200
 			idx = 4
+		elif rctype == 8:	# Fortis HS9510/HS7420/HS7429/HS7810A/HS7819
+			idx = 4
+		elif rctype == 9:	# Fortis HS7110/HS7119
+			idx = 4
+		elif rctype == 11:	# Topfield TF77X0HDPVR
+			idx = 5
+		elif rctype == 12:	# Kathrein UFS912
+			idx = 6
+#		elif rctype == 13:	# Cuberevo
+#			idx = 7
+#		elif rctype == 14:	# ...
+#			idx = 8
 		else:
 			idx = 2
 	if key in keyDescriptions[idx]:
--- enigma2.org/lib/python/Screens/InputDeviceSetup.py
+++ enigma2/lib/python/Screens/InputDeviceSetup.py
@@ -299,55 +299,22 @@
 	rcList = [
 			("0", _("Default")),
 			("4", _("DMM normal")),
-			("5", _("et9000/et9100")),
 			("6", _("DMM advanced")),
-			("7", _("et5000/6000")),
-			("8", _("VU+")),
-			("9", _("et8000/et10000")),
-			("11", _("et9200/9500/6500")),
-			("13", _("et4000")),
-			("14", _("xp1000")),
-			("16", _("HD11/HD51/HD1100/HD1200/HD1265/HD1500/HD500C/HD530C/VS1000/VS1500/et7x00/et8500/et7000mini")),
-			("18", _("F1/F3/F4/F4-TURBO")),
-			("19", _("HD2400")),
-			("20", _("Zgemma Star S/2S/H1/H2")),
-			("21", _("Zgemma H.S/H.2S/H.2H/H5/H7"))
+			("7", _("fs9000")),
+			("8", _("hs9510")),
+			("9", _("hs7110")),
+			("10", _("spark")),
+			("11", _("tf7700")),
+			("12", _("ufs912")),
 		]
 
 	defaultRcList = [
-			("et4000", 13),
-			("et5000", 7),
-			("et6000", 7),
-			("et6500", 11),
-			("et8000", 9),
-			("et9000", 5),
-			("et9100", 5),
-			("et9200", 11),
-			("et9500", 11),
-			("et10000", 9),
-			("formuler1", 18),
-			("formuler3", 18),
-			("formuler4", 18),
-			("formuler4turbo", 18),
-			("xp1000", 14),
-			("vs1000", 16),
-			("vs1500", 16),
-			("hd500c", 16),
-			("hd530c", 16),
-			("hd11", 16),
-			("hd51", 16),
-			("hd1200", 16),
-			("hd1265", 16),
-			("hd1100", 16),
-			("hd2400", 19),
-			("et7000", 16),
-			("et7500", 16),
-			("et8500", 16),
-			("sh1", 20),
-			("h3", 21),
-			("h5", 21),
-			("h7", 21),
-			("et7000mini", 16)
+			("fs9000", 7),
+			("hs9510", 8),
+			("hs7110", 9),
+			("spark", 10),
+			("tf7700", 11),
+			("ufs912", 12),
 		]
 
 	def __init__(self, session):
--- enigma2.org/data/rc_models/rc_models.cfg	2014-04-03 08:38:53.154073324 +0200
+++ enigma2/data/rc_models/rc_models.cfg	2014-05-28 20:18:22.000000000 +0200
@@ -19,70 +19,18 @@
 #
 # When no entry matches at all, 'default' will be used as remoteName
 #
-et10000  et8000
-et10000.4   dmm
-et10000.6   dmmadv
-et4000   et4x00
-et6500   et6x00
-et6500.4   dmm
-et6500.6   dmmadv
-et8000   et8000
-et8000.4   dmm
-et8000.6   dmmadv
-et9000   et9x00
-et9000.4   dmm
-et9000.6   dmmadv
-et9000.9  et9500
-et9200   et9x00
-et9500   et9500
-vuduo2   vuduo2
-vuduo    vu
-vusolo2  vu
-vusolo   vu
-vusolo4k   vu
-vuultimo vuultimo
-vuuno    vu
-xp1000   xp1000
-vusolose vu
-vuzero   vu
-vuuno4k   vu
-vuultimo4k vu
-formuler1   formuler1
-formuler3   formuler1
-formuler4   formuler1
-formuler4turbo	formuler1
-et7000 et7x00
-et7500 et7x00
-et8500 et8000
-hd2400	hd2400
-hd11	hd1100
-hd1100	hd1100
-hd1200  hd1100
-hd1265	hd1100
-hd1500	hd1100
-hd500c	hd1100
-hd51	hd1100
-vs1000	hd1100
-vs1500	hd1100
-fusionhd  xsarius
-fusionhdse  xsarius
-purehd	xsarius
-revo4k	revo4k
-galaxy4k revo4k
-wetekplay   wetekplay
-osmega osmini
-osmini osmini
-osminiplus osmini
-h3 zgemma
-h5 zgemma
-g300 miraclebox
-7000S miraclebox2
-7005S miraclebox2
-spycat spycat
-spycatmini spycat
-spycatminiplus	spycat
-xpeedlx xpeedlx
-et7000mini et7000mini
-et11000	et7000mini
-alphatriplehd sab
+hdbox       fs9000
+octagon1008 hs9510
+atevio7500  fs9000
+hs7110      hs7110
+hs7119      hs7110
+hs7420      hs9510
+hs7429      hs9510
+hs7810a     hs9510
+hs7819      hs9510
+spark       spark
+spark7162   spark
+tf7700hdpvr tf7700
+ufs910      ufs912
+ufs912      ufs912
 
--- enigma2.org/data/rc_models/Makefile.am
+++ enigma2/data/rc_models/Makefile.am
@@ -2,11 +2,9 @@
 
 dist_install_DATA = \
 	rc_models.cfg \
-	dmmadv.png  et4x00.png  et8000.png  et9x00.png  vu.png        xp1000.png \
-	dmm.png     et6x00.png  et9500.png  vuduo2.png  vuultimo.png  et7x00.png    formuler1.png \
-	hd2400.png  hd1100.png  wetekplay.png osmini.png miraclebox.png miraclebox2.png spycat.png \
-	xpeedlx.png revo4k.png sab.png \
-	dmmadv.xml  et4x00.xml  et8000.xml  et9x00.xml  vuultimo.xml  xp1000.xml \
-	dmm.xml     et6x00.xml  et9500.xml  et7x00.xml  vuduo2.xml    vu.xml	formuler1.xml \
-	hd2400.xml  hd1100.xml 	xsarius.xml  xsarius.png wetekplay.xml osmini.xml zgemma.png zgemma.xml miraclebox.xml miraclebox2.xml spycat.xml \
-	xpeedlx.xml et7000mini.png et7000mini.xml revo4k.xml sab.xml
+	dmmadv.png \
+	fs9000.png  hs7110.png  hs9510.png  spark.png tf7700.png ufs912.png \
+	dmm.png \
+	dmmadv.xml  \
+	fs9000.xml  hs7110.xml  hs9510.xml  spark.xml tf7700.xml ufs912.xml \
+	dmm.xml

