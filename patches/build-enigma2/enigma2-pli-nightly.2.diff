# revision 37427c7c563c47ab0a964da872f817a6f8900173 06/08/2022 13:10
--- enigma2.org/configure.ac
+++ enigma2/configure.ac
@@ -18,6 +18,7 @@
 AC_PATH_PROG(MSGFMT, msgfmt, AC_MSG_ERROR(Could not find msgfmt))
 
 AM_PATH_PYTHON
+PYTHON_NOVERSIONCHECK=no
 AX_PYTHON_DEVEL
 AX_PKG_SWIG
 AX_SWIG_ENABLE_CXX
@@ -35,6 +36,321 @@
 PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
 AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
 PKG_CHECK_MODULES(AVAHI, avahi-client)
+
+AC_ARG_ENABLE(run_from_usb,
+	[  --enable-run_from_usb      enable run_from_usb stuff],
+	[AC_DEFINE(ENABLE_RUN_FROM_USB, 1, [enable run_from_usb stuff])])
+AM_CONDITIONAL(ENABLE_RUN_FROM_USB, test "$enable_run_from_usb" = "yes")
+if test "$run_from_usb" = "yes"; then
+	AC_DEFINE(ENABLE_RUN_FROM_USB, 1, [enable run_from_usb stuff])
+fi
+
+AC_ARG_ENABLE(tf7700,
+	[  --enable-tf7700            enable tf7700 stuff],
+	[AC_DEFINE(ENABLE_TF7700, 1, [enable tf7700 stuff])])
+AM_CONDITIONAL(ENABLE_TF7700, test "$enable_tf7700" = "yes")
+if test "$enable_tf7700" = "yes"; then
+	AC_DEFINE(ENABLE_TF7700, 1, [enable tf7700 stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_250hd,
+	[  --enable-cuberevo_250hd    enable cuberevo_250d stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_250HD, 1, [enable cuberevo_250hd stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_250HD, test "$enable_cuberevo_250hd" = "yes")
+if test "$enable_cuberevo_250hd" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_250HD, 1, [enable cuberevo_250hd stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_2000hd,
+	[  --enable-cuberevo_2000hd   enable cuberevo_2000hd stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_2000HD, 1, [enable cuberevo_2000hd stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_2000HD, test "$enable_cuberevo_2000hd" = "yes")
+if test "$enable_cuberevo_2000hd" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_2000HD, 1, [enable cuberevo_2000hd stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_3000hd,
+	[  --enable-cuberevo_3000hd   enable cuberevo_3000hd stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_3000HD, 1, [enable cuberevo_3000hd stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_3000HD, test "$enable_cuberevo_3000hd" = "yes")
+if test "$enable_cuberevo_3000hd" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_3000HD, 1, [enable cuberevo_3000hd stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_9500hd,
+	[  --enable-cuberevo_9500hd   enable cuberevo_9500hd stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_9500HD, 1, [enable cuberevo_9500hd stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_9500HD, test "$enable_cuberevo_9500hd" = "yes")
+if test "$enable_cuberevo_9500hd" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_9500HD, 1, [enable cuberevo_9500hd stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_mini,
+	[  --enable-cuberevo_mini     enable cuberevo_mini stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_MINI, 1, [enable cuberevo_mini stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_MINI, test "$enable_cuberevo_mini" = "yes")
+if test "$enable_cuberevo_mini" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_MINI, 1, [enable cuberevo_mini stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_mini2,
+	[  --enable-cuberevo_mini2    enable cuberevo_mini2 stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_MINI2, 1, [enable cuberevo_mini2 stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_MINI2, test "$enable_cuberevo_mini2" = "yes")
+if test "$enable_cuberevo_mini2" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_MINI2, 1, [enable cuberevo_mini2 stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo_mini_fta,
+	[  --enable-cuberevo_mini_fta enable cuberevo_mini_fta stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO_MINI_FTA, 1, [enable cuberevo_mini_fta stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO_MINI_FTA, test "$enable_cuberevo_mini_fta" = "yes")
+if test "$enable_cuberevo_mini_fta" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO_MINI_FTA, 1, [enable cuberevo_mini_fta stuff])
+fi
+
+AC_ARG_ENABLE(cuberevo,
+	[  --enable-cuberevo          enable cuberevo stuff],
+	[AC_DEFINE(ENABLE_CUBEREVO, 1, [enable cuberevo stuff])])
+AM_CONDITIONAL(ENABLE_CUBEREVO, test "$enable_cuberevo" = "yes")
+if test "$enable_cuberevo" = "yes"; then
+	AC_DEFINE(ENABLE_CUBEREVO, 1, [enable cuberevo stuff])
+fi
+
+AC_ARG_ENABLE(spark,
+	[  --enable-spark             enable spark stuff],
+	[AC_DEFINE(ENABLE_SPARK, 1, [enable spark stuff])])
+AM_CONDITIONAL(ENABLE_SPARK, test "$enable_spark" = "yes")
+if test "$enable_spark" = "yes"; then
+	AC_DEFINE(ENABLE_SPARK, 1, [enable spark stuff])
+fi
+
+AC_ARG_ENABLE(spark7162,
+	[  --enable-spark7162         enable spark7162 stuff],
+	[AC_DEFINE(ENABLE_SPARK7162, 1, [enable spark7162 stuff])])
+AM_CONDITIONAL(ENABLE_SPARK7162, test "$enable_spark7162" = "yes")
+if test "$enable_spark7162" = "yes"; then
+	AC_DEFINE(ENABLE_SPARK7162, 1, [enable spark stuff])
+fi
+
+AC_ARG_ENABLE(hs9510,
+	[  --enable-hs9510            enable hs9510 stuff],
+	[AC_DEFINE(ENABLE_HS9510, 1, [enable hs9510 stuff])])
+AM_CONDITIONAL(ENABLE_HS9510, test "$enable_hs9510" = "yes")
+if test "$enable_hs9510" = "yes"; then
+	AC_DEFINE(ENABLE_HS9510, 1, [enable hs9510 stuff])
+fi
+
+AC_ARG_ENABLE(hs8200,
+	[  --enable-hs8200            enable hs8200 stuff],
+	[AC_DEFINE(ENABLE_HS8200, 1, [enable hs8200 stuff])])
+AM_CONDITIONAL(ENABLE_HS8200, test "$enable_hs8200" = "yes")
+if test "$enable_hs8200" = "yes"; then
+	AC_DEFINE(ENABLE_HS8200, 1, [enable hs8200 stuff])
+fi
+
+AC_ARG_ENABLE(fs9000,
+	[  --enable-fs9000            enable fs9000 stuff],
+[AC_DEFINE(ENABLE_FS9000, 1, [enable fs9000 stuff])])
+
+AM_CONDITIONAL(ENABLE_FS9000, test "$enable_fs9000" = "yes")
+if test "$enable_fs9000" = "yes"; then
+	AC_DEFINE(ENABLE_FS9000, 1, [enable fs9000 stuff])
+fi
+
+AC_ARG_ENABLE(hs7110,
+	[  --enable-hs7110            enable hs7110 stuff],
+[AC_DEFINE(ENABLE_HS7110, 1, [enable hs7110 stuff])])
+
+AM_CONDITIONAL(ENABLE_HS7110, test "$enable_hs7110" = "yes")
+if test "$enable_hs7110" = "yes"; then
+	AC_DEFINE(ENABLE_HS7110, 1, [enable hs7110 stuff])
+fi
+
+AC_ARG_ENABLE(hs7119,
+	[  --enable-hs7119            enable hs7119 stuff],
+[AC_DEFINE(ENABLE_HS7119, 1, [enable hs7119 stuff])])
+
+AM_CONDITIONAL(ENABLE_HS7119, test "$enable_hs7119" = "yes")
+if test "$enable_hs7119" = "yes"; then
+	AC_DEFINE(ENABLE_HS7119, 1, [enable hs7119 stuff])
+fi
+
+AC_ARG_ENABLE(hs7420,
+	[  --enable-hs7420            enable hs7420 stuff],
+	[AC_DEFINE(ENABLE_HS7420, 1, [enable hs7420 stuff])])
+AM_CONDITIONAL(ENABLE_HS7420, test "$enable_hs7420" = "yes")
+if test "$enable_hs7420" = "yes"; then
+	AC_DEFINE(ENABLE_HS7420, 1, [enable hs7420 stuff])
+fi
+
+AC_ARG_ENABLE(hs7429,
+	[  --enable-hs7429            enable hs7429 stuff],
+	[AC_DEFINE(ENABLE_HS7429, 1, [enable hs7429 stuff])])
+AM_CONDITIONAL(ENABLE_HS7429, test "$enable_hs7429" = "yes")
+if test "$enable_hs7429" = "yes"; then
+	AC_DEFINE(ENABLE_HS7429, 1, [enable hs7429 stuff])
+fi
+
+AC_ARG_ENABLE(hs7810a,
+	[  --enable-hs7810a           enable hs7810a stuff],
+	[AC_DEFINE(ENABLE_HS7810A, 1, [enable hs7810a stuff])])
+AM_CONDITIONAL(ENABLE_HS7810A, test "$enable_hs7810a" = "yes")
+if test "$enable_hs7810a" = "yes"; then
+	AC_DEFINE(ENABLE_HS7810A, 1, [enable hs7810a stuff])
+fi
+
+AC_ARG_ENABLE(hs7819,
+	[  --enable-hs7819            enable hs7819 stuff],
+	[AC_DEFINE(ENABLE_HS7819, 1, [enable hs7819 stuff])])
+AM_CONDITIONAL(ENABLE_HS7819, test "$enable_hs7819" = "yes")
+if test "$enable_hs7819" = "yes"; then
+	AC_DEFINE(ENABLE_HS7819, 1, [enable hs7819 stuff])
+fi
+
+AC_ARG_ENABLE(ufs910,
+	[  --enable-ufs910            enable ufs910 stuff],
+	[AC_DEFINE(ENABLE_UFS910, 1, [enable ufs910 stuff])])
+AM_CONDITIONAL(ENABLE_UFS910, test "$enable_ufs910" = "yes")
+if test "$enable_ufs910" = "yes"; then
+	AC_DEFINE(ENABLE_UFS910, 1, [enable ufs910 stuff])
+fi
+
+AC_ARG_ENABLE(ufs910,
+	[  --enable-ufs910            enable ufs910 stuff],
+	[AC_DEFINE(ENABLE_UFS910, 1, [enable ufs910 stuff])])
+AM_CONDITIONAL(ENABLE_UFS910, test "$enable_ufs910" = "yes")
+if test "$enable_ufs910" = "yes"; then
+	AC_DEFINE(ENABLE_UFS910, 1, [enable ufs910 stuff])
+fi
+
+AC_ARG_ENABLE(ufs912,
+	[  --enable-ufs912            enable ufs912 stuff],
+	[AC_DEFINE(ENABLE_UFS912, 1, [enable ufs912 stuff])])
+AM_CONDITIONAL(ENABLE_UFS912, test "$enable_ufs912" = "yes")
+if test "$enable_ufs912" = "yes"; then
+	AC_DEFINE(ENABLE_UFS912, 1, [enable ufs912 stuff])
+fi
+
+AC_ARG_ENABLE(ufs913,
+	[  --enable-ufs913            enable ufs913 stuff],
+	[AC_DEFINE(ENABLE_UFS913, 1, [enable ufs913 stuff])])
+AM_CONDITIONAL(ENABLE_UFS913, test "$enable_ufs913" = "yes")
+if test "$enable_ufs913" = "yes"; then
+	AC_DEFINE(ENABLE_UFS913, 1, [enable ufs913 stuff])
+fi
+
+AC_ARG_ENABLE(ufs922,
+	[  --enable-ufs922            enable ufs922 stuff],
+	[AC_DEFINE(ENABLE_UFS922, 1, [enable ufs922 stuff])])
+AM_CONDITIONAL(ENABLE_UFS922, test "$enable_ufs922" = "yes")
+if test "$enable_ufs922" = "yes"; then
+	AC_DEFINE(ENABLE_UFS922, 1, [enable ufs922 stuff])
+fi
+
+AC_ARG_ENABLE(ufc960,
+	[  --enable-ufc960            enable ufc960 stuff],
+	[AC_DEFINE(ENABLE_UFC960, 1, [enable ufc960 stuff])])
+AM_CONDITIONAL(ENABLE_UFC960, test "$enable_ufc960" = "yes")
+if test "$enable_ufc960" = "yes"; then
+	AC_DEFINE(ENABLE_UFC960, 1, [enable ufc960 stuff])
+fi
+
+AC_ARG_ENABLE(adb_box,
+	[  --adb_box                  enable adb_box stuff],
+	[AC_DEFINE(ENABLE_ADB_BOX, 1, [enable adb_box stuff])])
+AM_CONDITIONAL(ENABLE_ADB_BOX, test "$enable_adb_box" = "yes")
+if test "$enable_adb_box" = "yes"; then
+	AC_DEFINE(ENABLE_ADB_BOX, 1, [enable adb_box stuff])
+fi
+
+AC_ARG_ENABLE(vitamin_hd5000,
+	[  --enable-vitamin_hd5000    enable vitamin_hd5000 stuff],
+	[AC_DEFINE(ENABLE_VITAMIN_HD5000, 1, [enable vitamin_hd5000 stuff])])
+AM_CONDITIONAL(ENABLE_VITAMIN_HD5000, test "$enable_vitamin_hd5000" = "yes")
+if test "$enable_vitamin_hd5000" = "yes"; then
+	AC_DEFINE(ENABLE_VITAMIN_HD5000, 1, [enable vitamin_hd5000 stuff])
+fi
+
+AC_ARG_ENABLE(hl101,
+	[  --enable-hl101             enable hl101 stuff],
+	[AC_DEFINE(ENABLE_HL101, 1, [enable hl101 stuff])])
+AM_CONDITIONAL(ENABLE_HL101, test "$enable_hl101" = "yes")
+if test "$enable_hl101" = "yes"; then
+	AC_DEFINE(ENABLE_HL101, 1, [enable hl101 stuff])
+fi
+
+AC_ARG_ENABLE(vip1_v1,
+	[  --enable-vip1_v1           enable vip1_v1 stuff],
+	[AC_DEFINE(ENABLE_VIP1_V1, 1, [enable vip1_v1 stuff])])
+AM_CONDITIONAL(ENABLE_VIP1_V1, test "$enable_vip1_v1" = "yes")
+if test "$enable_vip1_v1" = "yes"; then
+	AC_DEFINE(ENABLE_VIP1_V1, 1, [enable vip1_v1 stuff])
+fi
+
+AC_ARG_ENABLE(vip1_v2,
+	[  --enable-vip1_v2           enable vip1_v2 stuff],
+	[AC_DEFINE(ENABLE_VIP1_V2, 1, [enable vip1_v2 stuff])])
+AM_CONDITIONAL(ENABLE_VIP1_V2, test "$enable_vip1_v2" = "yes")
+if test "$enable_vip1_v2" = "yes"; then
+	AC_DEFINE(ENABLE_VIP1_V2, 1, [enable vip1_v2 stuff])
+fi
+
+AC_ARG_ENABLE(vip2,
+	[  --enable-vip2              enable vip2 stuff],
+	[AC_DEFINE(ENABLE_VIP2, 1, [enable vip2 stuff])])
+AM_CONDITIONAL(ENABLE_VIP2, test "$enable_vip2" = "yes")
+if test "$enable_vip2" = "yes"; then
+	AC_DEFINE(ENABLE_VIP2, 1, [enable vip2 stuff])
+fi
+
+AC_ARG_ENABLE(pace7241,
+	[  --enable-pace7241          enable pace7241 stuff],
+	[AC_DEFINE(ENABLE_PACE7241, 1, [enable pace7241 stuff])])
+AM_CONDITIONAL(ENABLE_PACE7241, test "$enable_pace7241" = "yes")
+if test "$enable_pace7241" = "yes"; then
+	AC_DEFINE(ENABLE_PACE7241, 1, [enable pace7241 stuff])
+fi
+
+AC_ARG_ENABLE(opt9600,
+	[  --enable-opt9600           enable opt9600 stuff],
+	[AC_DEFINE(ENABLE_OPT9600, 1, [enable opt9600 stuff])])
+AM_CONDITIONAL(ENABLE_OPT9600, test "$enable_opt9600" = "yes")
+if test "$enable_opt9600" = "yes"; then
+	AC_DEFINE(ENABLE_OPT9600, 1, [enable opt9600 stuff])
+fi
+
+AC_ARG_ENABLE(opt9600mini,
+	[  --enable-opt9600mini       enable opt9600mini stuff],
+	[AC_DEFINE(ENABLE_OPT9600MINI, 1, [enable opt9600mini stuff])])
+AM_CONDITIONAL(ENABLE_OPT9600MINI, test "$enable_opt9600mini" = "yes")
+if test "$enable_opt9600mini" = "yes"; then
+	AC_DEFINE(ENABLE_OPT9600MINI, 1, [enable opt9600mini stuff])
+fi
+
+AC_ARG_ENABLE(opt9600prima,
+	[  --enable-opt9600prima      enable opt9600prima stuff],
+	[AC_DEFINE(ENABLE_OPT9600PRIMA, 1, [enable opt9600prima stuff])])
+AM_CONDITIONAL(ENABLE_OPT9600PRIMA, test "$enable_opt9600prima" = "yes")
+if test "$enable_opt9600prima" = "yes"; then
+	AC_DEFINE(ENABLE_OPT9600PRIMA, 1, [enable opt9600prima stuff])
+fi
+
+AC_ARG_ENABLE(atemio520,
+	[  --enable-atemio520         enable atemio520 stuff],
+	[AC_DEFINE(ENABLE_ATEMIO520, 1, [enable atemio520 stuff])])
+AM_CONDITIONAL(ENABLE_ATEMIO520, test "$enable_atemio520" = "yes")
+if test "$enable_atemio520" = "yes"; then
+	AC_DEFINE(ENABLE_ATEMIO520, 1, [enable atemio520 stuff])
+fi
+
+AC_ARG_ENABLE(hchs8100,
+	[  --enable-hchs8100          enable hchs8100 stuff],
+	[AC_DEFINE(ENABLE_HCHS8100, 1, [enable hchs8100 stuff])])
+AM_CONDITIONAL(ENABLE_HCHS8100, test "$enable_hchs8100" = "yes")
+if test "$enable_hchs8100" = "yes"; then
+	AC_DEFINE(ENABLE_HCHS8100, 1, [enable hchs8100 stuff])
+fi
 
 AC_CHECK_LIB([udfread], [udfread_init])
 AC_CHECK_LIB([dl], [dlopen], [LIBDL_LIBS="-ldl"], [AC_MSG_ERROR([Could not find libdl])])
@@ -51,13 +367,13 @@
 AC_DEFINE_UNQUOTED(CRASH_EMAILADDR,"$CRASHLOGEMAIL",[crash log email address])
 
 AC_ARG_WITH(boxtype,
-	[  --with-boxtype=NAME box type [[none,dm800...]]],
-	[BOXTYPE="$withval"],[BOXTYPE="dm800"])
+	[  --with-boxtype=NAME box type [[none,hs8200...]]],
+	[BOXTYPE="$withval"],[BOXTYPE="hs8200"])
 AC_SUBST(BOXTYPE)
 AC_DEFINE_UNQUOTED(BOXTYPE,"$BOXTYPE",[box type])
 
 AM_CONDITIONAL(DREAMBOX, test `echo "$BOXTYPE" | cut -b 1-2` == "dm")
-AM_CONDITIONAL(HAVE_TEMPFANCONTROL, test "$BOXTYPE" == dm8000 -o "$BOXTYPE" == dm800se -o "$BOXTYPE" == dm500hd)
+AM_CONDITIONAL(HAVE_TEMPFANCONTROL, test "$BOXTYPE" == adb_box -o "$BOXTYPE" == cuberevo -o "$BOXTYPE" == cuberevo-9500hd -o "$BOXTYPE" == ipbox99 -o "$BOXTYPE" == ipbox9900 -o "$BOXTYPE" == sagemcom88 -o "$BOXTYPE" == pace7241 -o "$BOXTYPE" == ufs922)
 if test `echo "$BOXTYPE" | cut -b 1-2` == "dm"; then
 	AC_DEFINE(DREAMBOX, 1, [Dreambox hardware])
 	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
@@ -79,19 +395,6 @@
 	[[TEXTSKIN="default"]]
 )
 AC_SUBST(TEXTSKIN)
-
-if test `echo "$BOXTYPE" | cut -b 1-7` == "mbmicro"; then
-	AC_DEFINE(FORCE_NO_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration does not have alphablending support, though the autodetection might indicate that it does])
-	AC_DEFINE(FORCE_NO_FILL_ACCELERATION, 1,[define when the framebuffer acceleration does not have fill support])
-	AC_DEFINE(FORCE_ADVANCED_REMOTE, 1,[define to fixup the input device identification when the remote control is actually an 'advanced' remote (with play/forward/rewind keys)])
-	AC_DEFINE(KEY_PLAY_ACTUALLY_IS_KEY_PLAYPAUSE, 1,[define when rc sends a KEY_PLAY event for its KEY_PLAYPAUSE key])
-fi
-
-if test `echo "$BOXTYPE" | cut -b 1-2` == "vu"; then
-	AC_DEFINE(FORCE_NO_BLENDING_ACCELERATION, 1,[define when the framebuffer acceleration does not have alphablending support, though the autodetection might indicate that it does])
-	AC_DEFINE(FORCE_NO_FILL_ACCELERATION, 1,[define when the framebuffer acceleration does not have fill support])
-	AC_DEFINE(FORCE_ADVANCED_REMOTE, 1,[define to fixup the input device identification when the remote control is actually an 'advanced' remote (with play/forward/rewind keys)])
-fi
 
 AC_ARG_WITH(libsdl,
 	AS_HELP_STRING([--with-libsdl],[use libsdl, yes or no]),
@@ -141,8 +444,8 @@
 
 AC_ARG_WITH(alsa,
 	AC_HELP_STRING([--with-alsa], [Enable ALSA support]),
-	[[with_alse=$withval]],
-	[[with_alse=no]]
+	[[with_alsa=$withval]],
+	[[with_alsa=no]]
 )
 if test x"$with_alsa" == xyes ; then
 	AC_DEFINE(HAVE_ALSA, 1,[Enables ALSA support])
@@ -190,19 +485,37 @@
 	[[with_alphablendingacceleration=$withval]],
 	[[with_alphablendingacceleration=auto]]
 )
-
 if test x"$with_alphablendingacceleration" = xnever ; then
 	AC_DEFINE_UNQUOTED(FORCE_NO_BLENDING_ACCELERATION, 1, [Do not attempt to accelerate alphablending blits])
 elif test x"$with_alphablendingacceleration" = xalways ; then
 	AC_DEFINE_UNQUOTED(FORCE_ALPHABLENDING_ACCELERATION, 1, [Accelerate alphablending blits])
 fi
 
+AC_ARG_WITH(graphlcd,
+	AC_HELP_STRING([--with-graphlcd], [use GraphLCD color display, yes or no]),
+	[[withgraphlcd=$withval]],
+	[[withgraphlcd=no]]
+)
+if test x"$withgraphlcd" != xno ; then
+	AC_DEFINE(HAVE_GRAPHLCD, 1,[Define when using a GraphLCD color display device])
+fi
+AM_CONDITIONAL(HAVE_GRAPHLCD, test x"$withgraphlcd" != xno)
+
+AC_ARG_WITH(lcd4linux,
+	AC_HELP_STRING([--with-lcd4linux], [use LCD4Linux color display, yes or no]),
+	[[withlcd4linux=$withval]],
+	[[withlcd4linux=no]]
+)
+if test x"$withlcd4linux" != xno ; then
+	AC_DEFINE(HAVE_LCD4LINUX, 1,[Define when using a LCD4Linux color display device])
+fi
+AM_CONDITIONAL(HAVE_LCD4LINUX, test x"$withlcd4linux" != xno)
+
 AC_ARG_WITH(accelerationthreshold,
 	AC_HELP_STRING([--with-accelerationthreshold=n], [use acceleration threshold of n bytes]),
 	[[with_accelerationthreshold=$withval]],
 	[[with_accelerationthreshold=48000]]
 )
-
 AC_DEFINE_UNQUOTED(GFX_SURFACE_ACCELERATION_THRESHOLD, $with_accelerationthreshold,[Configure threshold for accelerated surfaces (in bytes)])
 
 AC_ARG_WITH(fillaccelerationthreshold,
@@ -210,7 +531,6 @@
 	[[with_fillaccelerationthreshold=$withval]],
 	[[with_fillaccelerationthreshold=80000]]
 )
-
 AC_DEFINE_UNQUOTED(GFX_SURFACE_FILL_ACCELERATION_THRESHOLD, $with_fillaccelerationthreshold,[Configure threshold for accelerated fill operations (in bytes)])
 
 AC_ARG_WITH(blitaccelerationthreshold,
@@ -218,7 +538,6 @@
 	[[with_blitaccelerationthreshold=$withval]],
 	[[with_blitaccelerationthreshold=0]]
 )
-
 AC_DEFINE_UNQUOTED(GFX_SURFACE_BLIT_ACCELERATION_THRESHOLD, $with_blitaccelerationthreshold,[Configure threshold for accelerated blit operations (in bytes)])
 
 AC_ARG_WITH(accelerationaccumulation,
@@ -226,7 +545,6 @@
 	[[with_accelerationaccumulation=$withval]],
 	[[with_accelerationaccumulation=no]]
 )
-
 if test x"$with_accelerationaccumulation" = xyes ; then
 	AC_DEFINE(SUPPORT_ACCUMULATED_ACCELERATION_OPERATIONS, 1,[Accumulate blit/fill acceleration operations])
 fi
@@ -248,17 +566,16 @@
 
 CPPFLAGS="$CPPFLAGS $PYTHON_CPPFLAGS"
 CFLAGS="$CFLAGS -Wall"
-CXXFLAGS="$CXXFLAGS -Wall -Wextra -Werror \
-	-Wformat=2 -Wformat-overflow=2 -Wformat-nonliteral -Wformat-security \
-	-Wimplicit-fallthrough=5 -Wduplicated-branches -Wtrampolines \
-	-Wdangling-else -Wshift-overflow=2 -Wswitch \
-	-Wunused-but-set-parameter -Wunused-const-variable=1 -Wuninitialized \
-	-Wstringop-overflow=3 -Woverlength-strings \
+CXXFLAGS="$CXXFLAGS -Wall -Wextra \
+	-Wformat=2 -Wformat-nonliteral -Wformat-security \
+	-Wtrampolines \
+	-Wswitch \
+	-Wunused-but-set-parameter -Wuninitialized \
+	-Woverlength-strings \
 	-Wunsafe-loop-optimizations -Wpointer-arith \
 	-Wfloat-equal -Wlogical-op \
-	-Wno-error=cast-align=strict -Wno-error=ignored-qualifiers \
-	-Wno-error=cast-function-type \
-	-Wno-error=stringop-truncation -Wno-error=shadow -Wno-error=cast-qual \
+	-Wno-error=ignored-qualifiers \
+	-Wno-error=shadow -Wno-error=cast-qual \
 	-Wno-error=aggregate-return -Wno-error=missing-field-initializers \
 	-Wno-error=packed -Wno-error=vla -Wno-error=clobbered -Wno-error=unused-parameter \
 	$BASE_CFLAGS $ENIGMA2_CFLAGS $PTHREAD_CFLAGS $OPENMP_CFLAGS $ALSA_CFLAGS"
@@ -316,8 +631,6 @@
 lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
 lib/python/Plugins/PLi/Makefile
-lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
-lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/meta/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/meta/Makefile
 lib/python/Plugins/SystemPlugins/DiseqcTester/Makefile
@@ -347,6 +662,75 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/adb_5800VFD/Makefile
+lib/python/Plugins/Extensions/adb_5800VFD/meta/Makefile
+lib/python/Plugins/Extensions/adb_5800VFD/locale/Makefile
+lib/python/Plugins/Extensions/adb_5800VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/adb_5800VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/meta/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/locale/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/fs9000VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/meta/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/locale/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs7110VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/meta/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/locale/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs742xVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/meta/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/locale/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs7810aVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/meta/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/locale/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs8200VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/meta/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/locale/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hs9510VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/opt9600VFD/Makefile
+lib/python/Plugins/Extensions/opt9600VFD/meta/Makefile
+lib/python/Plugins/Extensions/opt9600VFD/locale/Makefile
+lib/python/Plugins/Extensions/opt9600VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/opt9600VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/pace7241VFD/Makefile
+lib/python/Plugins/Extensions/pace7241VFD/meta/Makefile
+lib/python/Plugins/Extensions/pace7241VFD/locale/Makefile
+lib/python/Plugins/Extensions/pace7241VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/pace7241VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/sparkVFD/Makefile
+lib/python/Plugins/Extensions/sparkVFD/meta/Makefile
+lib/python/Plugins/Extensions/sparkVFD/locale/Makefile
+lib/python/Plugins/Extensions/sparkVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/sparkVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/meta/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/locale/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/spark7162VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/ufs9xxVFD/Makefile
+lib/python/Plugins/Extensions/ufs9xxVFD/meta/Makefile
+lib/python/Plugins/Extensions/ufs9xxVFD/locale/Makefile
+lib/python/Plugins/Extensions/ufs9xxVFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/ufs9xxVFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/hchsxx00VFD/Makefile
+lib/python/Plugins/Extensions/hchsxx00VFD/meta/Makefile
+lib/python/Plugins/Extensions/hchsxx00VFD/locale/Makefile
+lib/python/Plugins/Extensions/hchsxx00VFD/locale/nl/Makefile
+lib/python/Plugins/Extensions/hchsxx00VFD/locale/nl/LC_MESSAGES/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 po/Makefile
 main/Makefile
--- enigma2.org/lib/python/StartEnigma.py
+++ enigma2/lib/python/StartEnigma.py
@@ -310,6 +310,10 @@
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+
+		if dlg is None:
+			return
+
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -521,10 +525,10 @@
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+		if (startTime[0] - nowTime) < 330: # no time to switch box back on
 			wptime = nowTime + 30  # so switch back on in 30 seconds
 		else:
-			wptime = startTime[0] - 240
+			wptime = startTime[0] - 300
 		if not config.misc.useTransponderTime.value:
 			print "[StartEnigma] DVB time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
 			setRTCtime(nowTime)
--- enigma2.org/data/menu.xml
+++ enigma2/data/menu.xml
@@ -48,7 +48,7 @@
 					<item level="0" entryID="timezone_setup"><setup id="timezone"/></item>
 					<item level="0" entryID="user_interface"><setup id="userinterface"/></item>
 					<item level="0" text="GUI Skin" entryID="primary_skin_selector"><screen module="SkinSelector" screen="SkinSelector"/></item>
-					<item level="0" requires="FrontpanelDisplay" text="Display Skin" entryID="display_skin_selector"><screen module="SkinSelector" screen="LcdSkinSelector"/></item>
+					<!--item level="0" requires="FrontpanelDisplay" text="Display Skin" entryID="display_skin_selector"><screen module="SkinSelector" screen="LcdSkinSelector"/></item-->
 				</menu>
 				<menu level="0" text="EPG" entryID="epg_menu">
 					<id val="epg"/>
--- enigma2.org/data/Makefile.am
+++ enigma2/data/Makefile.am
@@ -1,4 +1,4 @@
-SUBDIRS = countries display fonts extensions keymaps skin_default rc_models hw_info
+SUBDIRS = countries display fonts extensions keymaps skin_default rc_models
 
 dist_pkgdata_DATA = \
 	black.mvi \
--- enigma2.org/data/skin_default/Makefile.am
+++ enigma2/data/skin_default/Makefile.am
@@ -1,4 +1,4 @@
-SUBDIRS = menu icons buttons spinner LCDIcons
+SUBDIRS = menu icons buttons spinner
 
 installdir = $(pkgdatadir)/skin_default
 
--- enigma2.org/data/fonts/Makefile.am
+++ enigma2/data/fonts/Makefile.am
@@ -14,9 +14,8 @@
 	LiberationSans-Bold.ttf \
 	LiberationSans-BoldItalic.ttf \
 	LiberationSans-Italic.ttf \
-	LiberationSans-Regular.ttf \
-	wqy-microhei.ttc
+	LiberationSans-Regular.ttf
 
 install-data-hook:
 	cd $(DESTDIR)$(datadir)/fonts && \
-	$(LN_S) wqy-microhei.ttc fallback.font
+	$(LN_S) -f md_khmurabi_10.ttf fallback.font
--- enigma2.org/lib/base/encoding.cpp
+++ enigma2/lib/base/encoding.cpp
@@ -70,8 +70,19 @@
 	{
 		size_t bufsize = 256;
 		char *line = (char*) malloc(bufsize);
+		if (line == NULL)
+		{
+			eDebug("[eDVBTextEncodingHandler] unable to allocate memory");
+			return;
+		}
 		char countrycode[bufsize];
 		char *s_table = (char*) malloc(bufsize);
+		if (s_table == NULL)
+		{
+			eDebug("[eDVBTextEncodingHandler] unable to allocate memory");
+			free(line);
+			return;
+		}
 		while (getline(&line, &bufsize, f) != -1)
 		{
 			int i, j = 0;	   // remove leading whitespace and control chars, and comments
--- enigma2.org/lib/base/estring.cpp
+++ enigma2/lib/base/estring.cpp
@@ -788,7 +788,7 @@
 	//	string_to_hex(std::string((char*)data, len < 15 ? len : 15)).c_str(),
 	//	output.c_str());
 	// replace EIT CR/LF with standard newline:
-	output = replace_all(replace_all(output, "\xC2\x8A", "\n"), "\xEE\x82\x8A", "\n");
+//	output = replace_all(replace_all(output, "\xC2\x8A", "\n"), "\xEE\x82\x8A", "\n");
 	return output;
 }
 
@@ -1088,6 +1088,7 @@
     return output;
 }
 
+#if 0
 std::string strip_non_graph(std::string s)
 {
 	s = std::regex_replace(s, std::regex("[[^:graph:]]"), " ");
@@ -1095,6 +1096,7 @@
 	s = std::regex_replace(s, std::regex("^\\s+|\\s+$"), "");
 	return s;
 }
+#endif
 
 std::vector<std::string> split(std::string s, const std::string& separator)
 {
--- enigma2.org/lib/base/estring.h
+++ enigma2/lib/base/estring.h
@@ -35,7 +35,7 @@
 
 std::string urlDecode(const std::string &s);
 std::string string_to_hex(const std::string& input);
-std::string strip_non_graph(std::string s);
+//std::string strip_non_graph(std::string s);
 std::vector<std::string> split(std::string s, const std::string& separator);
 int strcasecmp(const std::string& s1, const std::string& s2);
 
--- enigma2.org/lib/base/smartptr.h
+++ enigma2/lib/base/smartptr.h
@@ -4,6 +4,8 @@
 #include "object.h"
 #include <lib/python/swig.h>
 
+inline void ptrAssert(void *p) { if (!p) *(unsigned long*)0=0; }
+
 template<class T>
 class ePtr
 {
@@ -57,10 +59,10 @@
 	}
 #ifndef SWIG
 	T* grabRef() { if (!ptr) return 0; ptr->AddRef(); return ptr; }
-	T* &ptrref() { return ptr; }
+	T* &ptrref() { ASSERT(!ptr); return ptr; }
 	operator bool() const { return !!this->ptr; }
 #endif
-	T* operator->() const { return ptr; }
+	T* operator->() const { ptrAssert(ptr); return ptr; }
 	operator T*() const { return this->ptr; }
 };
 
@@ -132,9 +134,9 @@
 	}
 #ifndef SWIG
 	T* grabRef() { if (!ptr) return 0; ptr->AddRef(); ptr->AddUse(); return ptr; }
-	T* &ptrref() { return ptr; }
+	T* &ptrref() { ASSERT(!ptr); return ptr; }
 #endif
-	T* operator->() const { return ptr; }
+	T* operator->() const { ptrAssert(ptr); return ptr; }
 	operator T*() const { return this->ptr; }
 };
 
@@ -177,12 +179,12 @@
 		ePtr<T>::operator=(c);
 		return *this;
 	}
-	ePtrHelper<T> operator->() { return ePtrHelper<T>(ptr); }
+	ePtrHelper<T> operator->() { ptrAssert(ptr); return ePtrHelper<T>(ptr); }
 			/* for const objects, we don't need the helper, as they can't */
 			/* be changed outside the program flow. at least this is */
 			/* what the compiler assumes, so in case you're using const */
 			/* eMutablePtrs note that they have to be const. */
-	const T* operator->() const { return ptr; }
+	const T* operator->() const { ptrAssert(ptr); return ptr; }
 };
 #endif
 
--- enigma2.org/lib/driver/Makefile.inc
+++ enigma2/lib/driver/Makefile.inc
@@ -9,7 +9,8 @@
 	driver/rc.cpp \
 	driver/rcinput.cpp \
 	driver/rfmod.cpp \
-	driver/hdmi_cec.cpp
+	driver/hdmi_cec.cpp \
+	driver/vfd.cpp
 
 driverincludedir = $(pkgincludedir)/lib/driver
 driverinclude_HEADERS = \
@@ -24,7 +25,8 @@
 	driver/rcinput.h \
 	driver/rcinput_swig.h \
 	driver/rfmod.h \
-	driver/hdmi_cec.h
+	driver/hdmi_cec.h \
+	driver/vfd.h
 
 if HAVE_LIBSDL
 driver_libenigma_driver_a_SOURCES += \
--- enigma2.org/lib/driver/hdmi_cec.cpp
+++ enigma2/lib/driver/hdmi_cec.cpp
@@ -126,22 +126,13 @@
 
 	if (!linuxCEC)
 	{
-#ifdef DREAMBOX
-#define HDMIDEV "/dev/misc/hdmi_cec0"
-#else
 #define HDMIDEV "/dev/hdmi_cec"
-#endif
 
 		hdmiFd = ::open(HDMIDEV, O_RDWR | O_NONBLOCK | O_CLOEXEC);
 		if (hdmiFd >= 0)
 		{
 
-#ifdef DREAMBOX
-			unsigned int val = 0;
-			::ioctl(hdmiFd, 4, &val);
-#else
 			::ioctl(hdmiFd, 0); /* flush old messages */
-#endif
 		}
 	}
 
@@ -228,28 +219,6 @@
 			if (::ioctl(hdmiFd, 1, &addressinfo) >= 0)
 			{
 				hasdata = true;
-#if DREAMBOX
-				/* we do not get the device type, check the logical address to determine the type */
-				switch (addressinfo.logical)
-				{
-				case 0x1:
-				case 0x2:
-				case 0x9:
-					addressinfo.type = 1; /* recorder */
-					break;
-				case 0x3:
-				case 0x6:
-				case 0x7:
-				case 0xa:
-					addressinfo.type = 3; /* tuner */
-					break;
-				case 0x4:
-				case 0x8:
-				case 0xb:
-					addressinfo.type = 4; /* playback */
-					break;
-				}
-#endif
 			}
 		}
 		if (hasdata)
@@ -348,14 +317,6 @@
 		}
 		else
 		{
-#ifdef DREAMBOX
-			if (::ioctl(hdmiFd, 2, &rxmessage) >= 0)
-			{
-				hasdata = true;
-			}
-			unsigned int val = 0;
-			::ioctl(hdmiFd, 4, &val);
-#else
 			if (::read(hdmiFd, &rxmessage, 2) == 2)
 			{
 				if (::read(hdmiFd, &rxmessage.data, rxmessage.length) == rxmessage.length)
@@ -363,7 +324,6 @@
 					hasdata = true;
 				}
 			}
-#endif
 		}
 		bool hdmicec_enabled = eConfigManager::getConfigBoolValue("config.hdmicec.enabled", false);
 		if (hasdata && hdmicec_enabled)
@@ -541,13 +501,8 @@
 		}
 		else
 		{
-#ifdef DREAMBOX
-			message.flag = 1;
-			::ioctl(hdmiFd, 3, &message);
-#else
 			ssize_t ret = ::write(hdmiFd, &message, 2 + message.length);
 			if (ret < 0) eDebug("[eHdmiCEC] write failed: %m");
-#endif
 		}
 	}
 }
--- enigma2.org/lib/driver/hdmi_cec.h
+++ enigma2/lib/driver/hdmi_cec.h
@@ -39,28 +39,6 @@
 {
 #ifndef SWIG
 public:
-#ifdef DREAMBOX
-	struct cec_message
-	{
-		unsigned char address;
-		unsigned char data[16];
-		unsigned char length;
-		unsigned char flag;
-	}__attribute__((packed));
-	struct cec_rx_message
-	{
-		unsigned char address;
-		unsigned char destination;
-		unsigned char data[16];
-		unsigned char length;
-	}__attribute__((packed));
-	struct addressinfo
-	{
-		unsigned char physical[2];
-		unsigned char logical;
-		unsigned char type;
-	};
-#else
 	struct cec_message
 	{
 		unsigned char address;
@@ -89,7 +67,6 @@
 		int getData(char *data, int length);
 	};
 	void sendMessage(struct cec_message &message);
-#endif
 protected:
 	static eHdmiCEC *instance;
 	bool linuxCEC;
--- enigma2.org/lib/driver/rc.cpp
+++ enigma2/lib/driver/rc.cpp
@@ -164,6 +164,9 @@
 {
 	if (m_remote_control)
 		return false;
+	if (getDeviceName().find("RC") != std::string::npos)
+		return false;
+
 	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
 	return hasCap(keyCaps, KEY_A);
 }
--- enigma2.org/lib/driver/rcinput.cpp
+++ enigma2/lib/driver/rcinput.cpp
@@ -40,7 +40,7 @@
 	if (km == eRCInput::kmAscii)
 	{
 		bool ignore = false;
-		bool ascii = ev->code > 0 && ev->code < 59;
+		bool ascii = (ev->code > 0 && ev->code < 61);
 
 		switch (ev->code)
 		{
--- enigma2.org/lib/driver/vfd.cpp
+++ enigma2/lib/driver/vfd.cpp
@@ -0,0 +1,1095 @@
+/***************************************************************************
+ *
+ * vfd.cpp
+ *
+ * (c) 20?? ?
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ ***************************************************************************
+ *
+ * VFD/LED front panel driver for enigma2.
+ *
+ ***************************************************************************
+ *
+ * Changes
+ *
+ * Date     By              Description
+ * -------------------------------------------------------------------------
+ * 20130905 Audioniek       Code for Sparks added in.
+ * 20130905 Audioniek       vfd_write_string_scrollText now uses actual
+ *                          display length in stead of always 16.
+ * 20131021 Audioniek       Octagon 1008 (Fortis HS9510) added.
+ * 20131130 Audioniek       HDBOX (Fortis FS9000/9200) added
+ * 20131210 Audioniek       Sign on string now scrolls once if longer than
+ *                          displaylength.
+ * 20140221 Audioniek       Fortis HS7119 and HS7819 added.
+ * 20140527 Audioniek       Spark7162 spins circle on init.
+ * 20150316 Audioniek       Spark7162 circle spin on init removed.
+ * 20160101 Audioniek       Fortis HS7420 and HS7429 added.
+ * 20170313 Audioniek       Kathrein UFS910/912 added.
+ * 20190317 Audioniek       Several CubeRevo's added.
+ * 20190518 Audioniek       vitamin_hd5000 added.
+ * 20200417 Audioniek       adb_box added.
+ * 20200508 Audioniek       pace7241 added.
+ * 20200719 Audioniek       hl101, vip1_v2 and vip2_v1 added.
+ * 20200828 Audioniek       Add vip1_v1, rename vip2.
+ * 20201115 Audioniek       Add opt9600.
+ * 20210322 Audioniek       Set display width on spark7162 to match actual
+ *                          display type and time mode.
+ * 20210326 Audioniek       Set correct display width on spark with VFD.
+ * 20210625 Audioniek       Kathrein UFS922 added.
+ * 20210922 Audioniek       Atemio AM 520 HD added.
+ * 20211105 Audioniek       Opticum HD 9600 Mini added.
+ * 20220127 Audioniek       Opticum HD 9600 Prima added.
+ * 20221104 Audioniek       Homecast HS8100 series added.
+ *
+ ***************************************************************************/
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include <pthread.h>
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#if defined (ENABLE_TF7700)
+#include "../../../tools/tffpctl/frontpanel.h"
+#endif
+
+// global variables
+bool startloop_running = false;
+static bool icon_onoff[45];
+static int led_onoff[7];
+static pthread_t thread_start_loop = 0;
+void *start_loop (void *arg);
+int  vfd_width;
+bool blocked    = false;
+bool requested  = false;
+bool VFD_CENTER = false;
+int  VFD_SCROLL = 1;  // 1=scroll once
+bool scroll_loop = false;
+
+// E2 scroll parameters
+int scroll_repeat;
+int scroll_delay;
+int initial_scroll_delay;
+int final_scroll_delay;
+
+char chars[64];
+char g_str[64];
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+	{
+		instance = new evfd;
+	}
+	return instance;
+}
+
+evfd::evfd()
+{
+#if defined (ENABLE_SPARK) \
+ || defined (ENABLE_SPARK7162)
+	int fd;
+	int n;
+	unsigned char display_type[2];
+#endif
+
+	file_vfd = 0;
+	memset (chars, ' ', 63);
+#if defined (ENABLE_SPARK) \
+ || defined (ENABLE_SPARK7162)
+	fd = open ("/proc/stb/fp/displaytype", O_RDONLY);
+	n = read(fd, display_type, sizeof(display_type));
+	close(fd);
+
+	if (fd < 0)
+	{
+		printf("[vfd] open /proc/stb/fp/displaytype failed\n");
+		vfd_type = 8;
+		return;
+	}
+	if (n < 0)
+	{
+		n = 0;
+	}
+
+	if (display_type[0] == '1')  // if VFD
+	{
+		vfd_type = 8;
+	}
+	else
+	{
+		vfd_type = 4;
+	}		
+#elif defined (ENABLE_HS8200)
+	vfd_type = 5;
+#elif defined (ENABLE_FS9000)
+	vfd_type = 6;
+#elif defined (ENABLE_HS9510)
+	vfd_type = 7;
+#elif defined (ENABLE_HL101) \
+   || defined (ENABLE_VIP1_V1) \
+   || defined (ENABLE_VIP1_V2) \
+   || defined (ENABLE_VIP2)
+	vfd_type = 8;
+#elif defined (ENABLE_HS7810A) \
+   || defined (ENABLE_HS7819) \
+   || defined (ENABLE_HS7119)
+	vfd_type = 9;
+#elif defined (ENABLE_HS7110)
+	vfd_type = 10;
+#elif defined (ENABLE_HS7420) \
+   || defined (ENABLE_HS7429)
+	vfd_type = 11;
+#elif defined (ENABLE_UFS912) \
+   || defined (ENABLE_UFS913) \
+   || defined (ENABLE_UFS922)
+	vfd_type = 12;
+#elif defined (ENABLE_CUBEREVO)
+	vfd_type = 13;
+#elif defined (ENABLE_CUBEREVO_MINI_FTA) \
+   || defined (ENABLE_CUBEREVO_250HD)
+	vfd_type = 14;
+#elif defined (ENABLE_CUBEREVO_MINI) \
+   || defined (ENABLE_CUBEREVO_MINI2) \
+   || defined (ENABLE_CUBEREVO_2000HD) \
+   || defined (ENABLE_CUBEREVO_3000HD)
+	vfd_type = 15;
+#elif defined (ENABLE_CUBEREVO_9500HD)
+	vfd_type = 16;
+#elif defined (ENABLE_VITAMIN_HD5000)
+	vfd_type = 17;
+#elif defined (ENABLE_ADB_BOX)
+	vfd_type = 18;
+#elif defined (ENABLE_PACE7241)
+	vfd_type = 19;
+#elif defined (ENABLE_OPT9600) \
+ ||   defined (ENABLE_OPT9600PRIMA)
+	vfd_type = 20;
+#elif defined (ENABLE_OPT9600MINI)
+	vfd_type = 21;
+#elif defined (ENABLE_HCHS8100)
+	vfd_type = 22;
+#else
+	vfd_type = -1;
+#endif
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);
+}
+
+evfd::~evfd()
+{
+	// close (file_vfd);
+}
+
+#if defined (ENABLE_TF7700)
+
+char *getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if (fd < 0)
+	{
+		return 0;
+	}
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if (n < 0)
+	{
+		n = 0;
+	}
+	else if((n > 1) && (progress[n - 1] == 0xa))
+	{
+		n--;
+	}
+	progress[n] = 0;
+	return progress;
+}
+
+void *start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+//	char spc[10];
+
+	if ((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("[vfd] Failed opening devices (%d, %d, %d)\n", fplarge, fpsmall, fpc);
+		return NULL;
+	}
+	blocked = true;
+
+	// set scroll mode
+	// frontpanel_ioctl_scrollmode scrollMode = { 2, 10, 15 };
+	// ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+
+	// display string
+	char str[] = "        TOPFIELD TF77X0 ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = { 0, 0, 0xf };
+
+	// start the display loop
+	char *progress = getProgress();
+	int index = 2;
+	while (!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if (index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for (i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if ((index % 4) == 0)
+		{
+			// display progress
+			progress = getProgress();
+//			if (strlen(progress) == 1)
+//			{
+//				spc = "  ";
+//			}
+//			if (strlen(progress) == 2)
+//			{
+//				spc = " ";
+//			}
+//			strcat(spc, progress);
+			write(fpsmall, progress, strlen(progress) + 1);
+			if (strncmp("100", progress, 3) == 0)
+			{
+				break;
+			}
+		}
+	}
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = { 0xffffffff, 0xffffffff, 0x0 };
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+#else  // next code for boxes other than Topfield TF77X0HDPVR
+
+	// set display width
+void set_display_width(void)
+{
+	#if !defined (ENABLE_SPARK) \
+	 && !defined (ENABLE_SPARK7162)
+	vfd_width = VFDLENGTH;
+	#else
+	int fd;
+	int n;
+	int tmp;
+	unsigned char display_type[2] = "1";  // default to VFD
+	unsigned char time_mode[2] = "1";  // default to time mode on
+
+	vfd_width = 8;  // default to VFD
+	fd = open ("/proc/stb/fp/displaytype", O_RDONLY);
+	n = read(fd, display_type, sizeof(display_type));
+	close(fd);
+
+	if (fd < 0)
+	{
+		printf("[vfd] open /proc/stb/fp/displaytype failed\n");
+		return;
+	}
+	if (n < 0)
+	{
+		n = 0;
+	}
+
+	if (display_type[0] == '2')  // if DVFD
+	{
+		fd = open ("/proc/stb/fp/timemode", O_RDONLY);
+		n = read(fd, time_mode, sizeof(time_mode));
+		close(fd);
+
+		if (fd < 0)
+		{
+			vfd_width = 10;  // default to time on
+			return;
+		}
+
+		if (time_mode[0] == '0')
+		{
+			vfd_width = 16;
+		}
+		else
+		{
+			vfd_width = 10;
+		}
+	}
+	#if defined(ENABLE_SPARK)
+	else if (display_type[0] == '1')  // if VFD
+	{
+		vfd_width = 8;  // reflect correct values on spark with VFD (Edision Argus Pingulux Plus)
+	}
+	else
+	{
+		vfd_width = 4;  // display type must be LED
+	}
+	#endif  // defined(ENABLE_SPARK)
+	#endif  // !defined(ENABLE_SPARK) && !defined(ENABLE_SPARK7162)
+}
+
+void *start_loop(void *arg)
+{
+	evfd vfd;
+
+	set_display_width();
+
+	// display signon string
+	blocked = true;
+	#if defined (ENABLE_SPARK7162)
+		char str[] = "SPARK7162 ENIGMA2";
+	#elif defined (ENABLE_SPARK)
+		char str[] = "SPARK ENIGMA2";
+	#elif defined (ENABLE_CUBEREVO)
+		char str[] = "CubeRevo Enigma2";
+	#elif defined (ENABLE_CUBEREVO_MINI_FTA)
+		char str[] = "CubeRevo 200HD Enigma2";
+	#elif defined (ENABLE_CUBEREVO_250HD)
+		char str[] = "CubeRevo 250HD Enigma2";
+	#elif defined (ENABLE_CUBEREVO_MINI)
+		char str[] = "CubeRevo Mini Enigma2";
+	#elif defined (ENABLE_CUBEREVO_MINI2)
+		char str[] = "CubeRevo Mini II Enigma2";
+	#elif defined (ENABLE_CUBEREVO_2000HD)
+		char str[] = "CubeRevo 2000HD Enigma2";
+	#elif defined (ENABLE_CUBEREVO_3000HD)
+		char str[] = "CubeRevo 3000HD Enigma2";
+	#elif defined (ENABLE_FS9000)
+		char str[] = "FS9000/9200 Enigma2";
+	#elif defined (ENABLE_HS9510)
+		char str[] = "HS9510 Enigma2";
+	#elif defined (ENABLE_HS8200)
+		char str[] = "HS8200 Enigma2";
+	#elif defined (ENABLE_HS7119)
+		char str[] = "7119 Enigma2";
+	#elif defined (ENABLE_HS7420)
+		char str[] = "HS7420 Enigma2";
+	#elif defined (ENABLE_HS7810A)
+		char str[] = "7810 Enigma2";
+	#elif defined (ENABLE_HS7429)
+		char str[] = "HS7429 Enigma2";
+	#elif defined (ENABLE_HS7819)
+		char str[] = "7819 Enigma2";
+	#elif defined (ENABLE_UFS910)
+		char str[] = "UFS910 Enigma2";
+	#elif defined (ENABLE_UFS912)
+		char str[] = "UFS912 Enigma2";
+	#elif defined (ENABLE_UFS913)
+		char str[] = "UFS913 Enigma2";
+	#elif defined (ENABLE_UFS922)
+		char str[] = "UFS922 Enigma2";
+	#elif defined (ENABLE_VITAMIN_HD5000)
+		char str[] = "Vitamin E2";
+	#elif defined (ENABLE_ADB_BOX)
+		char str[] = "nBox Enigma2";
+	#elif defined (ENABLE_PACE7241)
+		char str[] = "Pace 7241 Enigma2";
+	#elif defined (ENABLE_HL101)
+		char str[] = "HL101 E2";
+	#elif defined (ENABLE_VIP1_V1)
+		char str[] = "VIP E2";
+	#elif defined (ENABLE_VIP1_V2)
+		char str[] = "VIP1_2 E2";
+	#elif defined (ENABLE_VIP2)
+		char str[] = "VIP2 E2";
+	#elif defined (ENABLE_OPT9600) \
+	 ||   defined (ENABLE_OPT9600PRIMA)
+		char str[] = "HD 9600 Enigma2";
+	#elif defined (ENABLE_OPT9600MINI)
+		char str[] = "Mini Enigma2";
+	#elif defined (ENABLE_ATEMIO520)
+		char str[] = "520 HD Enigma2";
+	#elif defined (ENABLE_HCHS8100)
+		char str[] = "HS8100 CI E2";
+	#else
+		char str[] = "SH4 Git Enigma2";
+	#endif
+
+	int vfddev = open ("/dev/vfd", O_WRONLY);
+	write(vfddev, str, strlen(str));
+	close(vfddev);
+
+	/* These boxes can control display brightness */
+	#if defined (ENABLE_FS9000) \
+	 || defined (ENABLE_HS9510) \
+	 || defined (ENABLE_CUBEREVO) \
+	 || defined (ENABLE_CUBEREVO_MINI) \
+	 || defined (ENABLE_CUBEREVO_MINI2) \
+	 || defined (ENABLE_CUBEREVO_MINI_FTA) \
+	 || defined (ENABLE_CUBEREVO_250HD) \
+	 || defined (ENABLE_CUBEREVO_2000HD) \
+	 || defined (ENABLE_CUBEREVO_3000HD) \
+	 || defined (ENABLE_CUBEREVO_9500HD) \
+	 || defined (ENABLE_SPARK7162) \
+	 || defined (ENABLE_UFS910) \
+	 || defined (ENABLE_UFS912) \
+	 || defined (ENABLE_UFS913) \
+	 || defined (ENABLE_UFS922) \
+	 || defined (ENABLE_HS7119) \
+	 || defined (ENABLE_HS7420) \
+	 || defined (ENABLE_HS7429) \
+	 || defined (ENABLE_HS7810A) \
+	 || defined (ENABLE_HS7819) \
+	 || defined (ENABLE_HS8200) \
+	 || defined (ENABLE_VITAMIN_HD5000) \
+	 || defined (ENABLE_ADB_BOX) \
+	 || defined (ENABLE_PACE7241) \
+	 || defined (ENABLE_HL101) \
+	 || defined (ENABLE_VIP1_V1) \
+	 || defined (ENABLE_VIP1_V2) \
+	 || defined (ENABLE_VIP2) \
+	 || defined (ENABLE_HCHS8100)
+	// Modulate brightness 3 times
+	for (int vloop = 0; vloop < 3 * 14; vloop++)
+	{
+		if (vloop % 14 == 0)
+		{
+			vfd.vfd_set_brightness(6);
+		}
+		else if (vloop % 14 == 1)
+		{
+			vfd.vfd_set_brightness(5);
+		}
+		else if (vloop % 14 == 2)
+		{
+			vfd.vfd_set_brightness(4);
+		}
+		else if (vloop % 14 == 3)
+		{
+			vfd.vfd_set_brightness(3);
+		}
+		else if (vloop % 14 == 4)
+		{
+			vfd.vfd_set_brightness(2);
+		}
+		else if (vloop % 14 == 5)
+		{
+			vfd.vfd_set_brightness(1);
+		}
+		else if (vloop % 14 == 6)
+		{
+			vfd.vfd_set_brightness(0);
+		}
+		else if (vloop % 14 == 7)
+		{
+			vfd.vfd_set_brightness(1);
+		}
+		else if (vloop % 14 == 8)
+		{
+			vfd.vfd_set_brightness(2);
+		}
+		else if (vloop % 14 == 9)
+		{
+			vfd.vfd_set_brightness(3);
+		}
+		else if (vloop % 14 == 10)
+		{
+			vfd.vfd_set_brightness(4);
+		}
+		else if (vloop % 14 == 11)
+		{
+			vfd.vfd_set_brightness(5);
+		}
+		else if (vloop % 14 == 12)
+		{
+			vfd.vfd_set_brightness(6);
+		}
+		else if (vloop % 14 == 13)
+		{
+			vfd.vfd_set_brightness(7);
+		}
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);  // set final brightness
+	#else
+	/* Others cycle their icons */
+		#if !(ICON_MAX == -1)
+	for (int vloop = 0; vloop < 128; vloop++)
+	{
+		if (vloop % 2 == 1)
+		{
+			vfd.vfd_set_icon((((vloop % 32) / 2) % 16), ICON_OFF, true);
+			usleep(2000);
+			vfd.vfd_set_icon(((((vloop % 32) / 2) % 16) + 1), ICON_ON, true);
+		}
+	}
+	vfd.vfd_clear_icons();
+		#endif // !(ICON_MAX == -1)
+	#endif  // ENABLE_FS9000
+
+	#if !defined (ENABLE_FS9000) \
+	 && !defined (ENABLE_HS9510) \
+	 && !defined (ENABLE_HS8200) \
+	 && !defined (ENABLE_CUBEREVO) \
+	 && !defined (ENABLE_CUBEREVO_MINI) \
+	 && !defined (ENABLE_CUBEREVO_MINI2) \
+	 && !defined (ENABLE_CUBEREVO_MINI_FTA) \
+	 && !defined (ENABLE_CUBEREVO_250HD) \
+	 && !defined (ENABLE_CUBEREVO_2000HD) \
+	 && !defined (ENABLE_CUBEREVO_3000HD) \
+	 && !defined (ENABLE_CUBEREVO_9500HD) \
+	 && !defined (ENABLE_SPARK7162) \
+	 && !defined (ENABLE_UFS910) \
+	 && !defined (ENABLE_UFS912) \
+	 && !defined (ENABLE_UFS913) \
+	 && !defined (ENABLE_UFS922) \
+	 && !defined (ENABLE_HS7119) \
+	 && !defined (ENABLE_HS7420) \
+	 && !defined (ENABLE_HS7429) \
+	 && !defined (ENABLE_HS7810A) \
+	 && !defined (ENABLE_HS7819) \
+	 && !defined (ENABLE_VITAMIN_HD5000) \
+	 && !defined (ENABLE_ADB_BOX) \
+	 && !defined (ENABLE_PACE7241) \
+	 && !defined (ENABLE_HL101) \
+	 && !defined (ENABLE_VIP1_V1) \
+	 && !defined (ENABLE_VIP1_V2) \
+	 && !defined (ENABLE_VIP2) \
+	 && !defined (ENABLE_OPT9600) \
+	 && !defined (ENABLE_OPT9600MINI) \
+	 && !defined (ENABLE_OPT9600PRIMA) \
+	 && !defined (ENABLE_ATEMIO520) \
+	 && !defined (ENABLE_HCHS8100)
+	// Set all blocked icons
+	for (int id = 0x10; id < 0x20; id++)
+	{
+		vfd.vfd_set_icon(id, icon_onoff[id]);
+	}
+    #endif
+	blocked = false;
+	return NULL;
+}
+#endif  // ENABLE_TF7700
+
+// These models handle display scrolling in a separate thread
+#if defined (ENABLE_FS9000) \
+ || defined (ENABLE_HS9510) \
+ || defined (ENABLE_HS8200) \
+ || defined (ENABLE_HS7420) \
+ || defined (ENABLE_HS7429) \
+ || defined (ENABLE_HS7119) \
+ || defined (ENABLE_HS7810A) \
+ || defined (ENABLE_HS7819) \
+ || defined (ENABLE_CUBEREVO) \
+ || defined (ENABLE_CUBEREVO_MINI) \
+ || defined (ENABLE_CUBEREVO_MINI2) \
+ || defined (ENABLE_CUBEREVO_MINI_FTA) \
+ || defined (ENABLE_CUBEREVO_250HD) \
+ || defined (ENABLE_CUBEREVO_2000HD) \
+ || defined (ENABLE_CUBEREVO_3000HD) \
+ || defined (ENABLE_CUBEREVO_9500HD) \
+ || defined (ENABLE_SPARK) \
+ || defined (ENABLE_SPARK7162) \
+ || defined (ENABLE_VITAMIN_HD5000) \
+ || defined (ENABLE_ADB_BOX) \
+ || defined (ENABLE_PACE7241) \
+ || defined (ENABLE_HL101) \
+ || defined (ENABLE_VIP1_V1) \
+ || defined (ENABLE_VIP1_V2) \
+ || defined (ENABLE_VIP2) \
+ || defined (ENABLE_OPT9600) \
+ || defined (ENABLE_OPT9600MINI) \
+ || defined (ENABLE_OPT9600PRIMA) \
+ || defined (ENABLE_ATEMIO520) \
+ || defined (ENABLE_HCHS8100)
+void evfd::vfd_write_string_scrollText(char *text)
+{
+	return;
+}
+
+#if 0
+int read_scroll_procfs(char *name)
+{
+	int res = 0;  // result
+	int i;
+	FILE *f;
+	char filename[30] = {0};
+	char path[] = "/proc/stb/info/lcd/";
+	char buf[6];
+//	int stat;
+
+	snprintf(filename, sizeof(filename), "%s%s", path, name);
+	printf("%s: filename = %s\n", __func__, filename);
+
+	f = fopen(filename, "r");
+	fgets(buf, sizeof(buf), f);
+
+	i = 0;
+	while (buf[i] != '\0')
+	{
+		res = (res * 10) + (buf[i] - 0x30);
+		i++;
+	}
+	return res;
+}
+
+void get_procfs_scroll_params(void)
+{	// get scroll parameters
+	scroll_repeat = read_scroll_procfs((char*)"scroll_repeat");
+	scroll_delay = read_scroll_procfs((char*)"scroll_delay");
+	initial_scroll_delay = read_scroll_procfs((char*)"initial_scroll_delay");
+	final_scroll_delay = read_scroll_procfs((char*)"final_scroll_delay");
+}
+
+// We cannot use a member function (vfd_write_string_scrollText) in pthread,
+// so we use a second (same content) non-member function (vfd_write_string_scrollText1)
+static void *vfd_write_string_scrollText1(void *arg)
+{
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	char out[vfd_width + 1];
+	int i, j, len;
+	evfd vfd;
+
+	get_procfs_scroll_params();
+	scroll_loop = true;
+	len = strlen((char *)g_str);
+
+// initial display is handled outside this thread
+//	memcpy(out, g_str, vfd_width);  // get 1st vfd_width characters
+//	vfd.vfd_write_string(out, true);  // initial display: write 1st vfd_width characters
+
+	// scroll ?
+	if (scroll_loop && (len > vfd_width))
+	{
+		for (i = 0; i < scroll_repeat; i++)
+		{
+			for (j = 1; j <= len; j++)
+			{
+				memset(out, ' ', vfd_width + 1);  // clear scroll buffer
+				memcpy(out, g_str + j, vfd_width);  // then put string in
+				vfd.vfd_write_string(out, true);  // print string on VFD
+				if (blocked)
+				{
+					usleep(scroll_delay * 1000);  // loop delay
+				}
+				else
+				{
+					scroll_loop = false;
+				}
+			}
+		}
+		// final display
+		memcpy(out, g_str, vfd_width); // put string in
+		vfd.vfd_write_string(out, true);  // print string on VFD
+		if (VFD_SCROLL != 2 || !blocked)
+		{
+			scroll_loop = false;
+		}
+		else
+		{
+			usleep(final_scroll_delay * 1000);  // final delay
+		}
+	}
+#else
+static void *vfd_write_string_scrollText1(void *arg)
+{
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	char out[vfd_width + 1];
+	int i, len;
+	evfd vfd;
+
+	#if defined (ENABLE_SPARK) \
+	 || defined (ENABLE_SPARK7162)
+	set_display_width();
+	#endif
+	scroll_loop = true;
+	len = strlen((char *)g_str);
+	memset(out, ' ', vfd_width + 1);
+
+	while (scroll_loop && (len > vfd_width))
+	{
+		if (blocked)
+		{
+			usleep(750000);  // 0.75s pause between scroll loops
+		}
+		else
+		{
+			scroll_loop = false;
+		}
+		for (i = 0; i < len; i++)
+		{
+			if (blocked)
+			{
+				memset(out, ' ', vfd_width);  // fill buffer with spaces
+				memcpy(out, g_str + i, (len - i > vfd_width ? vfd_width : len - i));  // copy string shifted i character(s)
+				out[vfd_width] = 0;  // terminate string
+				vfd.vfd_write_string(out, true);
+				usleep(750000);  // 0.75 sec character delay
+			}
+			else
+			{
+				scroll_loop = false;
+				i = vfd_width;
+			}
+		}
+		memcpy(out, g_str, vfd_width);
+		out[vfd_width] = 0;  // terminate string
+		vfd.vfd_write_string(out, true);  // final display: write 1st vfd_width characters
+		if (VFD_SCROLL != 2 || !blocked)
+		{
+			scroll_loop = false;
+		}
+		else
+		{
+			sleep(1);  // 1 sec delay between loops
+		}
+	}
+#endif
+	blocked = false;
+	return NULL;
+}
+
+void evfd::vfd_write_string(char * str)
+{
+	int i = strlen(str);
+
+	if (i > 63)  // display 63
+	{
+		i = 63;  // characters maximum
+	}
+	if (blocked)  // if display running
+	{
+		pthread_cancel(thread_start_loop);  // stop it
+		pthread_join(thread_start_loop, NULL);
+		blocked = false;
+	}
+	memset(g_str, ' ', 64);  // clear scroll buffer
+	strcpy(g_str, str);  // and set display string in it
+	vfd_write_string(str, false);  // initial display: 1st vfd_width characters
+	if (i > vfd_width && VFD_SCROLL)  // if string longer than display and scroll mode
+	{
+//		usleep(initial_scroll_delay * 1000);  // wait initial delay
+		blocked = true;  // flag scrolling
+		pthread_create(&thread_start_loop, NULL, vfd_write_string_scrollText1, (void *)str);
+		pthread_detach(thread_start_loop);
+	}
+}
+
+void evfd::vfd_write_string(char *str, bool force)
+{
+	int ws = 0;
+	int i = strlen(str);
+	struct vfd_ioctl_data data;
+
+	if (VFD_CENTER == true)
+	{
+		if (i < vfd_width)
+		{
+			ws = (vfd_width - i) / 2;
+		}
+		else
+		{
+			ws = 0;
+		}
+	}
+
+	if (i > vfd_width)
+	{
+		i = vfd_width;
+	}
+	memset(data.data, ' ', vfd_width);
+	if (VFD_CENTER == true)
+	{
+		memcpy(data.data + ws, str, vfd_width - ws);
+	}
+	else
+	{
+		memcpy(data.data, str, i);
+	}
+	data.start = 0;
+	if (VFD_CENTER == true)
+	{
+		data.length = i + ws <= vfd_width ? i + ws : vfd_width;
+	}
+	else
+	{
+		data.length = i;
+	}
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	write(file_vfd,data.data,data.length);
+	close (file_vfd);
+}
+#else  // non-thread scrolling
+
+void evfd::vfd_write_string(char *str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char *str, bool force)
+{
+	int i = strlen(str);
+
+	if (i > 63)
+	{
+		i = 63;
+	}
+	memset (chars, ' ', 63);
+	memcpy (chars, str, i);
+#if defined (ENABLE_TF7700)
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked)
+	{
+		usleep(200000);
+	}
+#else
+	if (!blocked || force)
+#endif
+	{
+		struct vfd_ioctl_data data;
+		memset (data.data, ' ', 63);
+		memcpy (data.data, str, i);
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl (file_vfd, VFDDISPLAYCHARS, &data);
+		close (file_vfd);
+	}
+}
+
+void evfd::vfd_write_string_scrollText(char *text)
+{  // not used?
+//	get_procfs_scroll_params();
+
+	if (!blocked)
+	{
+		int i, len = strlen(text);
+		char *out = (char *)malloc(63);
+
+		for (i = 0; i <= (len - 63); i++)
+		{  // scroll text until end
+			memset(out, ' ', 63);
+			memcpy(out, text + i, 63);
+			vfd_write_string(out);
+			usleep(750000);
+		}
+		for (i = 1; i < 63; i++)
+		{  // scroll text with whitespaces from right
+			memset(out, ' ', 63);
+			memcpy(out, text + len + i - 63, 63 - i);
+			vfd_write_string(out);
+			usleep(750000);
+		}
+		memcpy(out, text, vfd_width);  // final: display first vfd_width chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+}
+#endif
+
+void evfd::vfd_clear_string()
+{
+	char out[vfd_width + 1];
+	memset(out, 0, vfd_width + 1);
+	memset(out, ' ', vfd_width);
+	vfd_write_string(out, true);
+}
+
+void evfd::vfd_set_icon(int id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+}
+
+void evfd::vfd_set_icon(int id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+	if (!blocked || force)
+	{
+		struct vfd_ioctl_data data;
+		if (!startloop_running)
+		{
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+			data.data[0] = id;
+			data.data[4] = onoff;
+			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+}
+
+void evfd::vfd_set_led(tvfd_led id, int onoff)
+{
+	led_onoff[id] = onoff;
+	struct vfd_ioctl_data data;
+	if (!startloop_running)
+	{
+		memset(&data, 0, sizeof(struct vfd_ioctl_data));
+		data.start = 0x00;
+		data.data[0] = id;
+		data.data[4] = onoff;
+		data.length = 5;
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl(file_vfd, VFDSETLED, &data);
+		close (file_vfd);
+	}
+}
+
+void evfd::vfd_clear_icons()
+{
+	int id;
+
+	if (ICON_MAX != -1)
+	{
+		for (id = 1; id <= ICON_MAX; id++)
+		{
+			vfd_set_icon(id, false);
+		}
+	}
+	else
+	{
+		for (id = 0x10; id < 0x20; id++)
+		{
+			vfd_set_icon(id, false);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_set_brightness(unsigned int setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open(VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDBRIGHTNESS, &data);
+	close(file_vfd);
+}
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+	{
+		data.start = 0x01;
+	}
+	else
+	{
+		data.start = 0x00;
+	}
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+}
+
+void evfd::vfd_set_fan(int speed)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+#if defined (ENABLE_CUBEREVO) \
+ || defined (ENABLE_CUBEREVO_9500HD) \
+ || defined (ENABLE_ADB_BOX)
+	if (speed)
+	{
+		data.start = 0x01;
+	}
+	else
+	{
+		data.start = 0x00;
+	}
+#else
+	data.start = speed;
+#endif
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDSETFAN, &data);
+
+	close (file_vfd);
+//#endif
+}
+
+void evfd::vfd_set_SCROLL(int id)
+{
+	if (id > 2)  // if more than 2, set 2 (scroll continously)
+	{
+		id = 2;
+	}
+	if (id < 0)  // if less than zero, set zero (no scroll)
+	{
+		id = 0;
+	}
+	VFD_SCROLL = id;
+}
+
+void evfd::vfd_set_CENTER(bool id)
+{
+	VFD_CENTER = id;
+}
+// vim:ts=4
--- enigma2.org/lib/driver/vfd.h
+++ enigma2/lib/driver/vfd.h
@@ -0,0 +1,148 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+// define display width
+#if defined ENABLE_TF7700
+	#define MAX_CHARS 8
+	#define VFDLENGTH 8
+#elif defined (ENABLE_HS7810A) \
+   || defined (ENABLE_HS7819) \
+   || defined (ENABLE_HS7119) \
+   || defined (ENABLE_SPARK) \
+   || defined (ENABLE_CUBEREVO_MINI_FTA) \
+   || defined (ENABLE_CUBEREVO_250HD) \
+   || defined (ENABLE_OPT9600MINI) \
+   || defined (ENABLE_ATEMIO520)
+	#define VFDLENGTH 4
+#elif defined (ENABLE_HS9510) \
+   || defined (ENABLE_HS7420) \
+   || defined (ENABLE_HS7429) \
+   || defined (ENABLE_SPARK7162) \
+   || defined (ENABLE_HL101) \
+   || defined (ENABLE_VIP1_V1) \
+   || defined (ENABLE_VIP1_V2) \
+   || defined (ENABLE_VIP2) \
+   || defined (ENABLE_OPT9600) \
+   || defined (ENABLE_OPT9600PRIMA)
+	#define VFDLENGTH 8
+#elif defined (ENABLE_VITAMIN_HD5000)
+	#define VFDLENGTH 11
+#elif defined (ENABLE_FS9000) \
+   || defined (ENABLE_HS8200) \
+   || defined (ENABLE_CUBEREVO) \
+   || defined (ENABLE_HCHS8100)
+	#define VFDLENGTH 12
+#elif defined (ENABLE_CUBEREVO_9500HD)
+	#define VFDLENGTH 13
+#elif defined (ENABLE_CUBEREVO_MINI) \
+   || defined (ENABLE_CUBEREVO_MINI2) \
+   || defined (ENABLE_CUBEREVO_2000HD) \
+   || defined (ENABLE_CUBEREVO_3000HD)
+	#define VFDLENGTH 14
+#else
+	#define VFDLENGTH 16
+#endif
+
+// define number of icons
+#if defined (ENABLE_SPARK7162) \
+ || defined (ENABLE_HL101) \
+ || defined (ENABLE_VIP1_V1) \
+ || defined (ENABLE_VIP1_V2) \
+ || defined (ENABLE_VIP2)
+#define ICON_MAX 45
+#elif defined (ENABLE_FS9000)
+#define ICON_MAX 39
+#elif defined (ENABLE_HS9510)
+#define ICON_MAX 28
+#elif defined (ENABLE_HS8200)
+#define ICON_MAX 22
+#elif defined (ENABLE_UFS910) \
+ ||   defined (ENABLE_UFS912) \
+ ||   defined (ENABLE_UFS913) \
+ ||   defined (ENABLE_UFS922)
+#define ICON_MAX 16
+#elif defined (ENABLE_CUBEREVO)
+#define ICON_MAX 27
+#elif defined (ENABLE_CUBEREVO_MINI) \
+ ||   defined (ENABLE_CUBEREVO_MINI2) \
+ ||   defined (ENABLE_CUBEREVO_2000HD) \
+ ||   defined (ENABLE_CUBEREVO_3000HD)
+#define ICON_MAX 6
+#elif defined (ENABLE_VITAMIN_HD5000)
+#define ICON_MAX 16
+#elif defined (ENABLE_ADB_BOX) \
+ ||   defined (ENABLE_PACE7241)
+#define ICON_MAX 20
+#elif defined (ENABLE_HCHS8100)
+#define ICON_MAX 34
+#else
+#define ICON_MAX -1
+#endif
+
+// IOCTL definitions
+#define VFD_DEVICE            "/dev/vfd"
+#define VFDDISPLAYCHARS       0xc0425a00
+#define VFDBRIGHTNESS         0xc0425a03
+#define VFDDISPLAYWRITEONOFF  0xc0425a05
+#define VFDICONDISPLAYONOFF   0xc0425a0a
+#define VFDSETFAN             0xc0425af8
+#define VFDSETLED             0xc0425afe
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+#if 0 //!defined (ENABLE_FS9000)
+typedef enum { USB = 1, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+typedef enum { RED_LED = 0, GREEN_LED } tvfd_led;
+//#else
+//typedef enum { USB = 1, I_STANDBY, I_SAT, I_REC, I_TIMESHIFT, I_TIMER, I_HD, I_LOCK, I_DD, I_MUTE, I_TUNER1, I_TUNER2, I_MP3, I_REPEAT,
+//               I_PLAY, I_PAUSE, I_TER, I_FILE_, I_480i, I_480p, I_576i, I_576p, I_720p, I_1080i, I_1080p } tvfd_icon;
+//typedef enum { RED_LED = 0, BLUE_LED, CROSS_UP, CROSS_LEFT, CROSS_RIGHT, CROSS_DOWN } tvfd_led;
+#endif
+typedef enum { RED_LED = 0, GREEN_LED } tvfd_led;
+
+struct vfd_ioctl_data
+{
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+class evfd
+{
+protected:
+		static evfd *instance;
+		int file_vfd;
+		int vfd_type;
+#ifdef SWIG
+		evfd();
+		~evfd();
+#endif
+	public:
+#ifndef SWIG
+		evfd();
+		~evfd();
+#endif
+		void init();
+		static evfd* getInstance();
+
+		int getVfdType() { return vfd_type; }
+		void vfd_set_SCROLL(int id);
+		void vfd_set_CENTER(bool id);
+		void vfd_set_icon(int id, bool onoff);
+		void vfd_set_icon(int id, bool onoff, bool force);
+		void vfd_set_led(tvfd_led id, int onoff);
+		void vfd_clear_icons();
+
+		void vfd_write_string(char *string);
+		void vfd_write_string(char *str, bool force);
+		void vfd_write_string_scrollText(char *text);
+		void vfd_clear_string();
+
+		void vfd_set_brightness(unsigned int setting);
+		void vfd_set_light(bool onoff);
+		void vfd_set_fan(int speed);
+};
+
+#endif // VFD_H_
+// vim:ts=4
--- enigma2.org/lib/dvb/decoder.cpp
+++ enigma2/lib/dvb/decoder.cpp
@@ -52,12 +52,10 @@
 		m_fd_demux = -1;
 	}
 
-#ifndef DREAMBOX
 	if (m_fd >= 0)
 	{
 		::ioctl(m_fd, AUDIO_SELECT_SOURCE, demux ? AUDIO_SOURCE_DEMUX : AUDIO_SOURCE_HDMI);
 	}
-#endif
 }
 
 int eDVBAudio::startPid(int pid, int type)
@@ -84,21 +82,16 @@
 			pes.pes_type = DMX_PES_AUDIO3;
 			break;
 		}
-		pes.flags    = 0;
-		eDebugNoNewLineStart("[eDVBAudio%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
+// increases zapping speed
+		pes.flags    = DMX_IMMEDIATE_START;
+//		eDebugNoNewLineStart("[eDVBAudio%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
 			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
-		eDebugNoNewLineStart("[eDVBAudio%d] DEMUX_START ", m_dev);
-		if (::ioctl(m_fd_demux, DMX_START) < 0)
-		{
-			eDebugNoNewLine("failed: %m\n");
-			return -errno;
-		}
-		eDebugNoNewLine("ok\n");
+// already started because of DMX_IMMEDIATE_START
 	}
 
 	if (m_fd >= 0)
@@ -133,11 +126,7 @@
 			bypass = 0x40;
 			break;
 		case aDDP:
-#ifdef DREAMBOX
-		bypass = 7;
-#else
 		bypass = 0x22;
-#endif
 		break;
 		}
 
@@ -146,7 +135,6 @@
 			eDebugNoNewLine("failed: %m\n");
 		else
 			eDebugNoNewLine("ok\n");
-		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
 		eDebugNoNewLineStart("[eDVBAudio%d] AUDIO_PLAY ", m_dev);
 		if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 			eDebugNoNewLine("failed: %m\n");
@@ -243,7 +231,7 @@
 
 eDVBAudio::~eDVBAudio()
 {
-	unfreeze();  // why unfreeze here... but not unfreeze video in ~eDVBVideo ?!?
+	//unfreeze();  // why unfreeze here... but not unfreeze video in ~eDVBVideo ?!?
 	if (m_fd >= 0)
 		::close(m_fd);
 	if (m_fd_demux >= 0)
@@ -284,12 +272,10 @@
 		m_fd_demux = -1;
 	}
 
-#ifndef DREAMBOX
 	if (m_fd >= 0)
 	{
 		::ioctl(m_fd, VIDEO_SELECT_SOURCE, demux ? VIDEO_SOURCE_DEMUX : VIDEO_SOURCE_HDMI);
 	}
-#endif
 	if (m_close_invalidates_attributes < 0)
 	{
 		/*
@@ -389,7 +375,8 @@
 			pes.pes_type = DMX_PES_VIDEO3;
 			break;
 		}
-		pes.flags    = 0;
+// increases zapping speed
+		pes.flags    = DMX_IMMEDIATE_START;
 		eDebugNoNewLineStart("[eDVBVideo%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
@@ -397,18 +384,11 @@
 			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
-		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_START ", m_dev);
-		if (::ioctl(m_fd_demux, DMX_START) < 0)
-		{
-			eDebugNoNewLine("failed: %m\n");
-			return -errno;
-		}
-		eDebugNoNewLine("ok\n");
-	}
-
-	if (m_fd >= 0)
-	{
-		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+// already started because of DMX_IMMEDIATE_START
+	}
+
+	if (m_fd >= 0)
+	{
 		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_PLAY ", m_dev);
 		if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 			eDebugNoNewLine("failed: %m\n");
@@ -729,7 +709,8 @@
 		pes.pes_type = DMX_PES_PCR3;
 		break;
 	}
-	pes.flags    = 0;
+// increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
 	eDebugNoNewLineStart("[eDVBPCR%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -737,13 +718,7 @@
 		return -errno;
 	}
 	eDebugNoNewLine("ok\n");
-	eDebugNoNewLineStart("[eDVBPCR%d] DEMUX_START ", m_dev);
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebugNoNewLine("failed: %m\n");
-		return -errno;
-	}
-	eDebugNoNewLine("ok\n");
+// already started because of DMX_IMMEDIATE_START
 	return 0;
 }
 
@@ -799,7 +776,8 @@
 		pes.pes_type = DMX_PES_TELETEXT3;
 		break;
 	}
-	pes.flags    = 0;
+// increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
 
 	eDebugNoNewLineStart("[eDVBText%d] DMX_SET_PES_FILTER pid=0x%04x ", m_dev, pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -808,13 +784,7 @@
 		return -errno;
 	}
 	eDebugNoNewLine("ok\n");
-	eDebugNoNewLineStart("[eDVBText%d] DEMUX_START ", m_dev);
-	if (::ioctl(m_fd_demux, DMX_START) < 0)
-	{
-		eDebugNoNewLine("failed: %m\n");
-		return -errno;
-	}
-	eDebugNoNewLine("ok\n");
+// already started because of DMX_IMMEDIATE_START
 	return 0;
 }
 
@@ -951,12 +921,23 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
-			m_video->setSlowMotion(s[1]);
-			m_video->setFastForward(s[2]);
+// see comment below
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+// the VIDEO_CONTINUE would reset the FASTFORWARD command so we
+// execute the FASTFORWARD after the VIDEO_CONTINUE
+			if (s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1260,6 +1241,9 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+// our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)
+				finishShowSinglePic();
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1273,36 +1257,56 @@
 				int streamtype;
 				memset(stuffing, 0, sizeof(stuffing));
 				ssize_t ret = read(f, iframe, s.st_size);
-				if (ret < 0) eDebug("[eTSMPEGDecoder] read failed: %m");
+				if (ret < 0)
+				{
+					eDebug("[eTSMPEGDecoder] read failed: %m");
+				}
 				if (iframe[0] == 0x00 && iframe[1] == 0x00 && iframe[2] == 0x00 && iframe[3] == 0x01 && (iframe[4] & 0x0f) == 0x07)
+				{
 					streamtype = VIDEO_STREAMTYPE_MPEG4_H264;
+				}
 				else
+				{
 					streamtype = VIDEO_STREAMTYPE_MPEG2;
-
+				}
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
+				{
 					eDebug("[eTSMPEGDecoder] VIDEO_SELECT_SOURCE MEMORY failed: %m");
-				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
-					eDebug("[eTSMPEGDecoder] VIDEO_SET_STREAMTYPE failed: %m");
+				}
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
+				{
 					eDebug("[eTSMPEGDecoder] VIDEO_PLAY failed: %m");
+				}
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
+				{
 					eDebug("[eTSMPEGDecoder] VIDEO_CONTINUE: %m");
+				}
 				if (ioctl(m_video_clip_fd, VIDEO_CLEAR_BUFFER) < 0)
+				{
 					eDebug("[eTSMPEGDecoder] VIDEO_CLEAR_BUFFER: %m");
+				}
 				while(pos <= static_cast<size_t>(s.st_size-4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos+1] && iframe[pos+2] == 1 && iframe[pos+3] == 0xB7)))
+				{
 					++pos;
+				}
 				if ((iframe[3] >> 4) != 0xE) // no pes header
+				{
 					writeAll(m_video_clip_fd, pes_header, sizeof(pes_header));
+				}
 				else
+				{
 					iframe[4] = iframe[5] = 0x00;
+				}
 				writeAll(m_video_clip_fd, iframe, s.st_size);
 				if (!seq_end_avail)
 				{
 					ret = write(m_video_clip_fd, seq_end, sizeof(seq_end));
-					if (ret < 0) eDebug("[eTSMPEGDecoder] write failed: %m");
+					if (ret < 0)
+					{
+						eDebug("[eTSMPEGDecoder] write failed: %m");
+					}
 				}
-				writeAll(m_video_clip_fd, stuffing, 8192);
-				m_showSinglePicTimer->start(150, true);
+				writeAll(m_video_clip_fd, stuffing, sizeof(stuffing));
 			}
 			close(f);
 		}
--- enigma2.org/lib/dvb/demux.cpp
+++ enigma2/lib/dvb/demux.cpp
@@ -260,6 +260,7 @@
 	notifier->start();
 
 	dmx_sct_filter_params sct;
+	memset(&sct, 0, sizeof(sct));
 	sct.pid     = mask.pid;
 	sct.timeout = 0;
 	sct.flags   = DMX_IMMEDIATE_START;
@@ -372,6 +373,7 @@
 	m_notifier->start();
 
 	dmx_pes_filter_params flt;
+	memset(&flt, 0, sizeof(flt));
 	flt.pes_type = DMX_PES_OTHER;
 	flt.pid     = pid;
 	flt.input   = DMX_IN_FRONTEND;
@@ -806,6 +808,7 @@
 	setBufferSize(1024*1024);
 
 	dmx_pes_filter_params flt;
+	memset(&flt, 0, sizeof(flt));
 	flt.pes_type = DMX_PES_OTHER;
 	flt.output  = DMX_OUT_TSDEMUX_TAP;
 	flt.pid     = i->first;
--- enigma2.org/lib/dvb/dvb.cpp
+++ enigma2/lib/dvb/dvb.cpp
@@ -118,7 +118,38 @@
 
 	m_fbcmng = new eFBCTunerManager(instance);
 
+	/*
+	 * this is a strange hack: the drivers seem to only work correctly after
+	 * demux0 has been used once. After that, we can use demux1,2,...
+	 */
+	initDemux(0);
+	/* for pip demux1 also be used once */
+	initDemux(1);
+
 	CONNECT(m_releaseCachedChannelTimer->timeout, eDVBResourceManager::releaseCachedChannel);
+}
+
+void eDVBResourceManager::initDemux(int num_demux)
+{
+	char filename[32];
+	sprintf(filename, "/dev/dvb/adapter0/demux%d", num_demux);
+	int dmx = open(filename, O_RDWR | O_CLOEXEC);
+	if (dmx < 0)
+	{
+		eDebug("cannot open %s (%m)", filename);
+	}
+	else
+	{
+		struct dmx_pes_filter_params filter;
+		memset(&filter, 0, sizeof(filter));
+		filter.output = DMX_OUT_DECODER;
+		filter.input  = DMX_IN_FRONTEND;
+		filter.flags  = DMX_IMMEDIATE_START;
+		filter.pes_type = DMX_PES_VIDEO;
+		ioctl(dmx, DMX_SET_PES_FILTER, &filter);
+		ioctl(dmx, DMX_STOP);
+		close(dmx);
+	}
 }
 
 void eDVBResourceManager::feStateChanged()
@@ -321,19 +352,6 @@
 		frontend = -1;
 		goto error;
 	}
-
-	struct dtv_properties props;
-	struct dtv_property prop[1];
-
-	prop[0].cmd = DTV_ENUM_DELSYS;
-	memset(prop[0].u.buffer.data, 0, sizeof(prop[0].u.buffer.data));
-	prop[0].u.buffer.len = 0;
-	props.num = 1;
-	props.props = prop;
-
-	if (ioctl(frontend, FE_GET_PROPERTY, &props) < 0)
-		eDebug("[eDVBUsbAdapter] FE_GET_PROPERTY DTV_ENUM_DELSYS failed %m");
-
 	::close(frontend);
 	frontend = -1;
 
@@ -433,8 +451,6 @@
 	ioctl(vtunerFd, VTUNER_SET_NAME, name);
 	ioctl(vtunerFd, VTUNER_SET_TYPE, type);
 	ioctl(vtunerFd, VTUNER_SET_FE_INFO, &fe_info);
-	if (prop[0].u.buffer.len > 0)
-		ioctl(vtunerFd, VTUNER_SET_DELSYS, prop[0].u.buffer.data);
 	ioctl(vtunerFd, VTUNER_SET_HAS_OUTPUTS, "no");
 	ioctl(vtunerFd, VTUNER_SET_ADAPTER, nr);
 
@@ -1071,6 +1087,7 @@
 	ePtr<eDVBRegisteredDemux> unused;
 	uint8_t d, a;
 
+#if 1
 	/*
 	 * For pvr playback, start with the last demux.
 	 * On some hardware, there are less ca devices than demuxes, so try to leave
@@ -1118,15 +1135,61 @@
 			--i;
 		}
 	}
-
+#else
+// we use our own algo for demux detection
+	int n = 0;
+	for (; i != m_demux.end(); ++i, ++n)
+	{
+		if (fe)
+ 		{
+ 			if (!i->m_inuse)
+ 			{
+ 				if (!unused)
+				{
+					// take the first unused
+					//eDebug("\nallocate demux b = %d\n",n);
+ 					unused = i;
+				}
+			}
+			else if (i->m_adapter == fe->m_adapter && i->m_demux->getSource() == fe->m_frontend->getDVBID())
+			{
+				// take the demux allocated to the same
+				// frontend, just create a new reference
+				demux = new eDVBAllocatedDemux(i);
+				//eDebug("\nallocate demux b = %d\n",n);
+				return 0;
+			}
+		}
+		else if (n == ((int)m_demux.size() - 1))
+		{
+			// Always use the last demux for PVR
+			// it is assumed that the last demux is not
+			// attached to a frontend. That is, there
+			// should be one instance of dvr & demux
+			// devices more than of frontend devices.
+			// Otherwise, playback and timeshift might
+			// interfere recording.
+			if (i->m_inuse)
+			{
+				// just create a new reference
+				demux = new eDVBAllocatedDemux(i);
+				//eDebug("\nallocate demux c = %d\n",n);
+				return 0;
+			}
+			unused = i;
+			//eDebug("\nallocate demux d = %d\n", n);
+			break;
+		}
+	}
+#endif
 	if (unused)
 	{
 		unused->m_demux->getCAAdapterID(a);
 		unused->m_demux->getCADemuxID(d);
-		eDebug("[eDVBResourceManager] allocating demux adapter=%d, demux=%d, source=%d fesource=%d", a, d, unused->m_demux->getSource(), fesource);
+		eDebug("[eDVBResourceManager] allocating demux adapter=%d, demux=%d, source=%d fesource=%d", a, d, unused->m_demux->getSource(), fe ? fe->m_frontend->getDVBID() : -1);
 		demux = new eDVBAllocatedDemux(unused);
 		if (fe)
-			demux->get().setSourceFrontend(fesource);
+			demux->get().setSourceFrontend(fe->m_frontend->getDVBID());
 		else
 			demux->get().setSourcePVR(0);
 		return 0;
@@ -2310,21 +2373,11 @@
 
 	if (m_pvr_fd_dst < 0)
 	{
-		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
-		if (demux)
-		{
-			m_pvr_fd_dst = demux->get().openDVR(O_WRONLY);
-			if (m_pvr_fd_dst < 0)
-			{
-				eDebug("[eDVBChannel] can't open /dev/dvb/adapterX/dvrX: %m");
-				return -ENODEV;
-			}
-		}
-		else
-		{
-			eDebug("[eDVBChannel] no demux allocated yet.. so its not possible to open the dvr device!!");
-			return -ENODEV;
-		}
+// our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
--- enigma2.org/lib/dvb/dvb.h
+++ enigma2/lib/dvb/dvb.h
@@ -244,6 +244,8 @@
 	bool frontendIsMultistream(int index);
 	std::string getFrontendCapabilities(int index);
 	void setFrontendType(int index, const char *types);
+protected:
+	void initDemux(int num_demux);
 };
 SWIG_TEMPLATE_TYPEDEF(ePtr<eDVBResourceManager>, eDVBResourceManager);
 SWIG_EXTEND(ePtr<eDVBResourceManager>,
@@ -271,6 +273,8 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+//see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
 
 	RESULT connectStateChange(const sigc::slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const sigc::slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
--- enigma2.org/lib/dvb/dvbtime.cpp
+++ enigma2/lib/dvb/dvbtime.cpp
@@ -178,6 +178,7 @@
 void TDT::start()
 {
 	eDVBTableSpec spec;
+	memset(&spec, 0, sizeof(spec));
 	spec.pid = TimeAndDateSection::PID;
 	spec.tid = TimeAndDateSection::TID;
 	spec.tid_mask = 0xFC;
--- enigma2.org/lib/dvb/filepush.cpp
+++ enigma2/lib/dvb/filepush.cpp
@@ -6,6 +6,16 @@
 #include <poll.h>
 #include <time.h>
 
+
+// this allows filesystem tasks to be prioritised
+#include <sys/vfs.h>
+#define USBDEVICE_SUPER_MAGIC 0x9fa2
+#define EXT2_SUPER_MAGIC      0xEF53
+#define EXT3_SUPER_MAGIC      0xEF53
+#define SMB_SUPER_MAGIC       0x517B
+#define NFS_SUPER_MAGIC       0x6969
+#define MSDOS_SUPER_MAGIC     0x4d44 /* MD */
+
 //#define SHOW_WRITE_TIME
 
 DEFINE_REF(eFilePushThread);
@@ -29,7 +39,10 @@
 eFilePushThread::~eFilePushThread()
 {
 	stop(); /* eThread is borked, always call stop() from d'tor */
-	free(m_buffer);
+	if (m_buffer)
+	{
+		free(m_buffer);
+	}
 }
 
 static void signal_handler(int x)
@@ -63,10 +76,27 @@
 		size_t current_span_remaining = 0;
 		m_sof = 0;
 
+// opens video device for the reverse playback workaround
+// Changes in this file are because E2 does not tell the player to play reverse
+		int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+// Fix to ensure that event evtEOF is called at end of playback part 1/3
+		bool already_empty = false;
+
 		while (!m_stop)
 		{
 			if (m_sg && !current_span_remaining)
 			{
+// tells the player to play in reverse
+#define VIDEO_DISCONTINUITY                   _IO('o', 84)
+#define DVB_DISCONTINUITY_SKIP                0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+				if ((m_sg->getSkipMode() != 0))
+				{
+// inform the player about the jump in the stream data
+// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+					int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+					int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+				}
 				m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining, m_blocksize, m_sof);
 				ASSERT(!(current_span_remaining % m_blocksize));
 				m_current_position = current_span_offset;
@@ -132,7 +162,16 @@
 					{
 						case 0:
 							eDebug("[eFilePushThread] wait for driver eof timeout");
-							continue;
+// Fix to ensure that event evtEOF is called at end of playback part 2/3
+							if (already_empty)
+							{
+								break;
+							}
+							else
+							{
+								already_empty = true;
+								continue;
+							}
 						case 1:
 							eDebug("[eFilePushThread] wait for driver eof ok");
 							break;
@@ -177,6 +216,13 @@
 				filterRecordData(m_buffer, buf_end);
 				while ((buf_start != buf_end) && !m_stop)
 				{
+					struct pollfd pfd;
+					pfd.fd = m_fd_dest;
+					pfd.events = POLLOUT;
+					if (0 == poll(&pfd, 1, 250))
+					{
+						continue;
+					}
 					int w = write(m_fd_dest, m_buffer + buf_start, buf_end - buf_start);
 
 					if (w <= 0)
@@ -199,12 +245,18 @@
 				}
 
 				eofcount = 0;
+// Fix to ensure that event evtEOF is called at end of playbackl part 3/3
+				already_empty = false;
 				m_current_position += buf_end;
 				bytes_read += buf_end;
 				if (m_sg)
+				{
 					current_span_remaining -= buf_end;
+				}
 			}
 		}
+// closes video device for the reverse playback workaround
+		close(fd_video);
 		sendEvent(evtStopped);
 
 		{ /* mutex lock scope */
--- enigma2.org/lib/dvb/filepush.h
+++ enigma2/lib/dvb/filepush.h
@@ -13,6 +13,8 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size, int blocksize, int &sof)=0;
 	virtual ~iFilePushScatterGather() {}
+	//Changes in this file are because E2 does not tell the player to play reverse
+	virtual int getSkipMode() = 0;
 };
 
 class eFilePushThread: public eThread, public sigc::trackable, public iObject
@@ -23,6 +25,8 @@
 	~eFilePushThread();
 	void thread();
 	void stop();
+// our own thread to prioritise and split the files
+	void start(int sourcefd, int destfd, const char *filename);
 	void start(ePtr<iTsSource> &source, int destfd);
 
 	void pause();
--- enigma2.org/lib/dvb/frontend.cpp
+++ enigma2/lib/dvb/frontend.cpp
@@ -17,6 +17,10 @@
 
 #ifndef I2C_SLAVE_FORCE
 #define I2C_SLAVE_FORCE	0x0706
+#endif
+
+#ifndef SYS_DVBC_ANNEX_A
+#define SYS_DVBC_ANNEX_A SYS_DVBC_ANNEX_AC
 #endif
 
 #define eDebugNoSimulate(x...) \
@@ -727,7 +731,11 @@
 		}
 	}
 
+#if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 6
 	m_multitype = m_delsys[SYS_DVBS] && (m_delsys[SYS_DVBT] || m_delsys[SYS_DVBC_ANNEX_A]);
+#else
+	m_multitype = m_delsys[SYS_DVBS] && (m_delsys[SYS_DVBT] || m_delsys[SYS_DVBC_ANNEX_AC]);
+#endif
 
 	if (!m_multitype)
 		m_type = feSatellite;
@@ -946,12 +954,16 @@
 	int cab_max = 4200;
 	int atsc_max = 4200;
 
-	if (!strcmp(m_description, "AVL2108")) // ET9000
+	if (strstr(m_description, "STV090x Multistandard"))
+	{
+		ret = (int)(snr / 32.768);
+	}
+	else if (!strcmp(m_description, "AVL2108"))
 	{
 		ret = (int)(snr / 40.5);
 		sat_max = 1618;
 	}
-	if (!strcmp(m_description, "AVL6211")) // ET10000
+	else if (!strcmp(m_description, "AVL6211"))
 	{
 		ret = (int)(snr / 37.5);
 		sat_max = 1700;
@@ -3095,7 +3107,11 @@
 	}
 	else if (!strcmp(type, "DVB-C"))
 	{
+#if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 6
 		p[0].u.data = SYS_DVBC_ANNEX_A;
+#else
+		p[0].u.data = SYS_DVBC_ANNEX_AC;
+#endif
 		fetype = feCable;
 	}
 	else if (!strcmp(type, "ATSC"))
@@ -3227,11 +3243,16 @@
 		case SYS_ISDBS:		ss << " ISDBS"; break;
 		case SYS_ISDBT:		ss << " ISDBT"; break;
 		case SYS_UNDEFINED:	ss << " UNDEFINED"; break;
+#if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 6
 		case SYS_DVBC_ANNEX_A:	ss << " DVBC_ANNEX_A"; break;
 		case SYS_DVBC_ANNEX_C:	ss << " DVBC_ANNEX_C"; break;
-		case SYS_DVBT2:		ss << " DVBT2"; break;
 		case SYS_TURBO:		ss << " TURBO"; break;
 		case SYS_DTMB:		ss << " DTMB"; break;
+#else
+		case SYS_DVBC_ANNEX_AC:	ss << " DVBC_ANNEX_AC"; break;
+		case SYS_DMBTH:         ss << " DMBTH"; break;
+#endif
+		case SYS_DVBT2:		ss << " DVBT2"; break;
 		}
 	}
 
--- enigma2.org/lib/dvb/pmt.cpp
+++ enigma2/lib/dvb/pmt.cpp
@@ -921,6 +921,11 @@
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
+		if (m_service_type == streamclient)
+		{
+			eDebug("force setServiceID(1)");
+			m_reference.setServiceID(1);
+		}
 		if (!ref.getServiceID().get() /* incorrect sid in meta file or recordings.epl*/ )
 		{
 			eDVBTSTools tstools;
--- enigma2.org/lib/dvb/pmt.h
+++ enigma2/lib/dvb/pmt.h
@@ -32,7 +32,10 @@
 		: LongCrcSection(buffer)
 		{
 			data = malloc(getSectionLength());
-			memcpy(data, buffer, getSectionLength());
+			if (data != NULL)
+			{
+				memcpy(data, buffer, getSectionLength());
+			}
 		}
 		~OCSection()
 		{
--- enigma2.org/lib/dvb/scan.cpp
+++ enigma2/lib/dvb/scan.cpp
@@ -1049,9 +1049,9 @@
 			if( m_chid_current )
 				tsonid = ( m_chid_current.transport_stream_id.get() << 16 )
 					| m_chid_current.original_network_id.get();
-			service->m_service_name = strip_non_graph(convertDVBUTF8(sname,-1,tsonid,0));
+			service->m_service_name = convertDVBUTF8(sname,-1,tsonid,0);
 			service->genSortName();
-			service->m_provider_name = strip_non_graph(convertDVBUTF8(pname,-1,tsonid,0));
+			service->m_provider_name = convertDVBUTF8(pname,-1,tsonid,0);
 		}
 
 		if (!(m_flags & scanOnlyFree) || !m_pmt_in_progress->second.scrambled) {
@@ -1487,10 +1487,10 @@
 
 					ref.setServiceType(servicetype);
 					int tsonid=(sdt.getTransportStreamId() << 16) | sdt.getOriginalNetworkId();
-					service->m_service_name = strip_non_graph(convertDVBUTF8(d.getServiceName(),-1,tsonid,0));
+					service->m_service_name = convertDVBUTF8(d.getServiceName(),-1,tsonid,0);
 					service->genSortName();
 
-					service->m_provider_name = strip_non_graph(convertDVBUTF8(d.getServiceProviderName(),-1,tsonid,0));
+					service->m_provider_name = convertDVBUTF8(d.getServiceProviderName(),-1,tsonid,0);
 					SCAN_eDebug("[eDVBScan]   name '%s', provider_name '%s'", service->m_service_name.c_str(), service->m_provider_name.c_str());
 					break;
 				}
--- enigma2.org/lib/dvb/streamserver.h
+++ enigma2/lib/dvb/streamserver.h
@@ -4,6 +4,8 @@
 #include <lib/network/serversocket.h>
 #include <lib/service/servicedvbstream.h>
 #include <lib/nav/core.h>
+
+#define TCP_USER_TIMEOUT        18  
 
 #ifndef SWIG
 class eStreamServer;
--- enigma2.org/lib/dvb/volume.cpp
+++ enigma2/lib/dvb/volume.cpp
@@ -45,7 +45,9 @@
 	openMixer();
 #endif
 	volumeUnMute();
+#if not defined(__sh__) // do not reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
--- enigma2.org/lib/dvb_ci/descrambler.cpp
+++ enigma2/lib/dvb_ci/descrambler.cpp
@@ -20,6 +20,7 @@
 #define CA_SET_PID _IOW('o', 135, struct ca_pid)
 #endif
 
+#if 0
 enum ca_descr_data_type {
 	CA_DATA_IV,
 	CA_DATA_KEY,
@@ -37,9 +38,11 @@
 	unsigned int length;
 	unsigned char *data;
 };
+#endif
 
-
+#ifndef CA_SET_PID
 #define CA_SET_DESCR_DATA _IOW('o', 137, struct ca_descr_data)
+#endif
 
 int descrambler_set_key(int desc_fd, int index, int parity, unsigned char *data)
 {
--- enigma2.org/lib/dvb_ci/dvbci_appmgr.cpp
+++ enigma2/lib/dvb_ci/dvbci_appmgr.cpp
@@ -96,6 +96,7 @@
 	eDebug("[CI AM] in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+	slot->mmiOpened();
 	return 0;
 }
 
--- enigma2.org/lib/dvb_ci/dvbci.cpp
+++ enigma2/lib/dvb_ci/dvbci.cpp
@@ -26,11 +26,265 @@
 
 #include <dvbsi++/ca_program_map_section.h>
 
+#include <linux/dvb/ca.h>
+//#define x_debug
+
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
 pthread_mutex_t eDVBCIInterfaces::m_pmt_handler_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
 pthread_mutex_t eDVBCIInterfaces::m_slot_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+}
+
+/* from dvb-apps */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+	{
+		return -1;
+	}
+		length_field = asn_1_array[0];
+
+	if (length_field < 0x80)
+	{
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	}
+	else if (length_field == 0x81)
+	{
+		if (asn_1_array_len < 2)
+		{
+			return -1;
+		}
+		*length = asn_1_array[1];
+		return 2;
+	}
+	else if (length_field == 0x82)
+	{
+		if (asn_1_array_len < 3)
+		{
+			return -1;
+		}
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug
+	printf("%s: %p, %d\n", __func__, data, len);
+#endif
+
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+
+	/* should we send a data last ? */
+	if (data != NULL)
+	{
+		if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		{
+			memcpy(d, data, len);
+		}
+		else
+		{
+			//send data_last and data
+			memcpy(d + 5, data, len);
+			d[0] = getSlotID();
+			d[1] = connection_id;
+			d[2] = T_DATA_LAST;
+			if (len > 127)
+			{
+				d[3] = 4;	/* pointer to next length */
+			}
+			else
+			{
+				d[3] = len + 1;	/* len */
+			}
+			d[4] = connection_id; 	/* transport connection identifier*/
+			len += 5;
+		}
+	}
+	else
+	{
+		//send a data last only
+		d[0] = getSlotID();
+		d[1] = connection_id;
+		d[2] = T_DATA_LAST;
+		d[3] = len + 1;		/* len */
+		d[4] = connection_id;	/* transport connection identifier*/
+		len = 5;
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for (int i = 0; i < len; i++)
+	{
+		printf("%02x ",d[i]);
+	}
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len);
+
+	free(d);
+	if (res < 0 || res != len)
+	{
+		printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+		return eDataError;
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+	//printf("%s:%s >\n", FILENAME, __FUNCTION__);
+	unsigned char *data = (unsigned char *)malloc(sizeof(char) * 5);
+	tx_time.tv_sec = 0;
+	data[0] = getSlotID();
+	data[1] = getSlotID() + 1; 	/* conid */
+	data[2] = T_CREATE_T_C;
+	data[3] = 1;
+	data[4] = getSlotID() + 1 	/*conid*/;
+	write(fd, data, 5);
+	//printf("%s:%s <\n", FILENAME, __FUNCTION__);
+	return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8 *data, int asn_data_length, int con_id)
+{
+	switch (tpdu_tag)
+	{
+		case T_C_T_C_REPLY:
+		{
+			printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+			tx_time.tv_sec = 0;
+
+			state = stateInserted;
+
+			//answer with data last (and if we have with data)
+			sendData(NULL, 0);
+
+			break;
+		}
+		case T_DELETE_T_C:
+		{
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+			printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+			break;
+		}
+		case T_D_T_C_REPLY:
+		{
+			printf("Got \"Delete Transport Connection Replay\" from module!\n");
+			break;
+		}
+		case T_REQUEST_T_C:
+		{
+			printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+			break;
+		}
+		case T_DATA_MORE:
+		{
+			int new_data_length = receivedLen + asn_data_length;
+			printf("Got \"Data More\" from Module\n");
+			__u8 *new_data_buffer = (__u8 *)realloc(receivedData, new_data_length);
+			receivedData = new_data_buffer;
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+			receivedLen = new_data_length;
+			tx_time.tv_sec = 0;
+			break;
+		}
+		case T_DATA_LAST:
+		{
+#ifdef x_debug
+			printf("Got \"Data Last\" from Module\n");
+#endif
+			tx_time.tv_sec = 0;
+			/* single package */
+			if (receivedData == NULL)
+			{
+				printf("->single package\n");
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < asn_data_length; i++)
+				{
+					printf("%02x ", data[i]);
+				}
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, data, asn_data_length);
+				eDVBCISession::pollAll();
+			}
+			else
+			{
+				/* chained package */
+				int new_data_length = receivedLen + asn_data_length;
+				printf("->chained data\n");
+				__u8 *new_data_buffer = (__u8 *)realloc(receivedData, new_data_length);
+				receivedData = new_data_buffer;
+				memcpy(receivedData + receivedLen, data, asn_data_length);
+				receivedLen = new_data_length;
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0; i < receivedLen; i++)
+				{
+					printf("%02x ", receivedData[i]);
+				}
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, receivedData, receivedLen);
+				eDVBCISession::pollAll();
+//fixme: must also be moved in e2 behind the data processing ;)
+				free(receivedData);
+				receivedData = NULL;
+				receivedLen = 0;
+			}
+			break;
+		}
+		case T_SB:
+		{
+#ifdef x_debug
+			printf("Got \"SB\" from Module\n");
+#endif
+			if (data[0] & 0x80)
+			{
+				printf("->data ready (%d)\n", getSlotID());
+				// send the RCV and ask for the data
+				unsigned char send_data[5];
+				send_data[0] = getSlotID();
+				send_data[1] = connection_id;
+				send_data[2] = T_RCV;
+				send_data[3] = 1;
+				send_data[4] = connection_id;
+				write(fd, send_data, 5);
+				gettimeofday(&tx_time, 0);
+			}
+			else
+			{
+				tx_time.tv_sec = 0;
+			}
+			break;
+		}
+		default:
+			printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+	}
+}
 
 eDVBCIInterfaces::eDVBCIInterfaces()
  : m_messagepump_thread(this,1), m_messagepump_main(eApp,1), m_runTimer(eTimer::create(this))
@@ -54,7 +308,7 @@
 	{
 		path.str("");
 		path.clear();
-		path << "/dev/ci" << num_ci;
+		path << "/dev/dvb/adapter0/ci" << num_ci;
 
 		if(::access(path.str().c_str(), R_OK) < 0)
 			break;
@@ -1168,7 +1422,7 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
-		sendqueue.push( queueData(d, len) );
+		sendData(d, len);
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 	}
 
@@ -1179,61 +1433,168 @@
 {
 	singleLock s(eDVBCIInterfaces::m_slot_lock);
 	eTrace("[CI] Slot %d what %d\n", getSlotID(), what);
-	if(what == eSocketNotifier::Priority) {
-		if(state != stateRemoved) {
-			state = stateRemoved;
-			while(sendqueue.size())
-			{
-				delete [] sendqueue.top().data;
-				sendqueue.pop();
-			}
-			eDVBCISession::deleteSessions(this);
-			eDVBCIInterfaces::getInstance()->ciRemoved(this);
-			notifier->setRequested(eSocketNotifier::Read);
-			/* emit */ eDVBCI_UI::getInstance()->m_messagepump.send(eDVBCIInterfaces::Message(eDVBCIInterfaces::Message::slotStateChanged, getSlotID(), 0));
-		}
-		return;
-	}
-
-	if (state == stateInvalid)
-		reset();
-
-	if(state != stateInserted) {
-		eDebug("[CI] ci inserted in slot %d", getSlotID());
-		state = stateInserted;
-		/* emit */ eDVBCI_UI::getInstance()->m_messagepump.send(eDVBCIInterfaces::Message(eDVBCIInterfaces::Message::slotStateChanged, getSlotID(), 1));
-		notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
-		/* enable PRI to detect removal or errors */
-	}
-
-	if (what & eSocketNotifier::Read) {
-		uint8_t data[4096];
-		int r;
-		r = ::read(fd, data, 4096);
-		if(r > 0) {
-			int i;
-			eTraceNoNewLineStart("> ");
-			for(i=0;i<r;i++)
-				eTraceNoNewLine("%02x ",data[i]);
-			eTraceNoNewLine("\n");
-			eDVBCISession::receiveData(this, data, r);
-			eDVBCISession::pollAll();
-			return;
-		}
-	}
-	else if (what & eSocketNotifier::Write) {
-		if (!sendqueue.empty()) {
-			const queueData &qe = sendqueue.top();
-			int res = ::write(fd, qe.data, qe.len);
-			if (res >= 0 && (unsigned int)res == qe.len)
-			{
-				delete [] qe.data;
-				sendqueue.pop();
-			}
-		}
-		else
-			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
-	}
+	unsigned char data[1024];
+	int len = 1024;
+	unsigned char* d;
+	eData status;
+	ca_slot_info_t info;
+
+	if (what & eSocketNotifier::Read)
+	{
+		eTrace("eSocketNotifier::Read\n");
+		status = eDataReady;
+		len = ::read(fd, data, len);
+	}
+	else if (what & eSocketNotifier::Write)
+	{
+		eTrace("eSocketNotifier::Write\n");
+		status = eDataWrite;
+	}
+	else if (what & eSocketNotifier::Priority)
+	{
+		eTrace("eSocketNotifier::Priority\n");
+		status = eDataStatusChanged;
+	}
+	else
+	{
+		status = eDataError;
+	}
+
+	switch (getState())
+	{
+		case stateInvalid:
+		{
+			if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("1. cam status changed ->cam now present\n");
+					state = stateInserted;
+					mmi_active = false;
+					tx_time.tv_sec = 0;
+					application_manager = 0;
+					ca_manager = 0;
+					sendCreateTC();
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+				}
+			}
+			else
+			{
+				usleep(100000);
+			}
+		}
+		break;
+		case stateInserted:
+		{
+			if (status == eDataReady)
+			{
+				eTrace("received data - len %d\n", len);
+				//int s_id = data[0];
+				//int c_id = data[1];
+				//printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+				d = data;
+				/* taken from the dvb-apps */
+				int data_length = len - 2;
+				d += 2; /* remove leading slot and connection id */
+				while (data_length > 0)
+				{
+					unsigned char tpdu_tag = d[0];
+					unsigned short asn_data_length;
+					int length_field_len;
+					if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0)
+					{
+						printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+						break;
+					}
+
+					if ((asn_data_length < 1) || (asn_data_length > (data_length - (1 + length_field_len))))
+					{
+						printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+						break;
+					}
+					connection_id = d[1 + length_field_len];
+					//printf("Setting connection_id from received data to %d\n", slot->connection_id);
+					d += 1 + length_field_len + 1;
+					data_length -= (1 + length_field_len + 1);
+					asn_data_length--;
+					process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+					// skip over the consumed data
+					d += asn_data_length;
+					data_length -= asn_data_length;
+				} // while (data_length)
+			} /* data ready */
+			else if (status == eDataWrite)
+			{
+				if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+				{
+					const queueData &qe = sendqueue.top();
+					int res = write(fd, qe.data, qe.len);
+					if (res >= 0 && (unsigned int)res == qe.len)
+					{
+						delete [] qe.data;
+						sendqueue.pop();
+						gettimeofday(&tx_time, 0);
+					}
+					else
+					{
+						printf("r = %d, %m\n", res);
+					}
+				}
+				/* the spec say's that we _must_ poll the connection
+				 * if the transport connection is in active state
+				 */
+				if ((tx_time.tv_sec == 0) && (!checkQueueSize()) && (time_after(last_poll_time, 1000)))
+				{
+					sendData(NULL, 0);
+					clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+				}
+			}
+			else if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("2. cam status changed ->cam now present\n");
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+				}
+				else if (!(info.flags & CA_CI_MODULE_READY))
+				{
+					printf("cam status changed ->cam now _not_ present\n");
+					eDVBCISession::deleteSessions(this);
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCIInterfaces::getInstance()->ciRemoved(this);
+					eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+					while (sendqueue.size())
+					{
+						delete [] sendqueue.top().data;
+						sendqueue.pop();
+					}
+				}
+			}
+		}
+		break;
+		default:
+			printf("unknown state %d\n", state);
+		break;
+	}
+	notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1266,7 +1627,7 @@
 	plugged = true;
 	m_ci_version = versionUnknown;
 
-	sprintf(filename, "/dev/ci%d", slotid);
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", slotid);
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1277,10 +1638,18 @@
 	eTrace("[CI] Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+	receivedLen = 0;
+	receivedData = NULL;
 	if (fd >= 0)
 	{
+		connection_id = slotid + 1;
+		tx_time.tv_sec = 0;
+		tx_time.tv_usec = 0;
+		last_poll_time.tv_sec = 0;
+		last_poll_time.tv_nsec = 0;
 		notifier = eSocketNotifier::create(m_context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+		reset();
 	} else
 	{
 		perror(filename);
@@ -1412,13 +1773,11 @@
 {
 	eDebug("[CI] Slot %d: reset requested", getSlotID());
 
-	if (state == stateInvalid)
-	{
-		unsigned char buf[256];
-		eDebug("[CI] flush");
-		while(::read(fd, buf, 256)>0);
-		state = stateResetted;
-	}
+	state = stateInvalid;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+	eDVBCIInterfaces::getInstance()->ciRemoved(this);
 
 	while(sendqueue.size())
 	{
@@ -1426,7 +1785,8 @@
 		sendqueue.pop();
 	}
 
-	ioctl(fd, 0);
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
 
 	return 0;
 }
--- enigma2.org/lib/dvb_ci/dvbci.h
+++ enigma2/lib/dvb_ci/dvbci.h
@@ -7,6 +7,7 @@
 #include <lib/base/message.h>
 #include <lib/base/thread.h>
 #include <lib/service/iservice.h>
+#include <lib/base/thread.h>
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -40,6 +41,40 @@
 typedef std::set<providerPair> providerSet;
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
+
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+                                	// layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+                                	// layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
 
 class eDVBCISlot: public iObject, public sigc::trackable
 {
@@ -67,6 +101,11 @@
 	void data(int);
 	bool plugged;
 	eMainloop *m_context;
+	//dagobert
+	char connection_id;
+	bool mmi_active;
+	int receivedLen;
+	unsigned char* receivedData;
 
 	eDVBCIApplicationManagerSession *getAppManager() { return application_manager; }
 	eDVBCIMMISession *getMMIManager() { return mmi_session; }
@@ -74,7 +113,6 @@
 	eDVBCICcSession *getCCManager() { return cc_manager; }
 
 	int getState() { return state; }
-	int reset();
 	int startMMI();
 	int stopMMI();
 	int answerText(int answer);
@@ -105,7 +144,17 @@
 
 	int getSlotID();
 	int getNumOfServices();
+	int reset();
 	int getVersion();
+	bool checkQueueSize();
+	void thread();
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+	void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+	bool sendCreateTC();
+	eData sendData(unsigned char* data, int len);
+	struct timeval tx_time;
+	struct timespec last_poll_time;
 };
 
 struct CIPmtHandler
--- enigma2.org/lib/dvb_ci/dvbci_session.cpp
+++ enigma2/lib/dvb_ci/dvbci_session.cpp
@@ -296,6 +296,10 @@
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eWarning("[CI SESS] PROTOCOL: illegal session number %x", session_nb);
+			//Dagobert during start-up we seem to have some problems
+			//on some modules which "lose" the connection. So reset it
+			deleteSessions(slot);
+			slot->reset();
 			return;
 		}
 
--- enigma2.org/lib/gdi/accel.cpp
+++ enigma2/lib/gdi/accel.cpp
@@ -15,25 +15,19 @@
 // #define ACCEL_DEBUG
 
 gAccel *gAccel::instance;
-#define BCM_ACCEL
-
-#ifdef BCM_ACCEL
-extern int bcm_accel_init(void);
-extern void bcm_accel_close(void);
-extern void bcm_accel_blit(
+#define STMFB_ACCEL
+
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
 		int src_addr, int src_width, int src_height, int src_stride, int src_format,
 		int dst_addr, int dst_width, int dst_height, int dst_stride,
 		int src_x, int src_y, int width, int height,
-		int dst_x, int dst_y, int dwidth, int dheight,
-		int pal_addr, int flags);
-extern void bcm_accel_fill(
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
 		int dst_addr, int dst_width, int dst_height, int dst_stride,
 		int x, int y, int width, int height,
 		unsigned long color);
-extern bool bcm_accel_has_alphablending();
-extern int bcm_accel_accumulate();
-extern int bcm_accel_sync();
-#endif
 
 gAccel::gAccel():
 	m_accel_addr(0),
@@ -41,17 +35,12 @@
 	m_accel_size(0)
 {
 	instance = this;
-
-#ifdef BCM_ACCEL
-	m_bcm_accel_state = bcm_accel_init();
-#endif
+	stmfb_accel_init();
 }
 
 gAccel::~gAccel()
 {
-#ifdef BCM_ACCEL
-	bcm_accel_close();
-#endif
+	stmfb_accel_close();
 	instance = 0;
 }
 
@@ -120,52 +109,88 @@
 
 bool gAccel::hasAlphaBlendingSupport()
 {
-#ifdef BCM_ACCEL
-	return bcm_accel_has_alphablending();
-#else
 	return false;
-#endif
 }
 
 int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p, const eRect &area, int flags)
 {
-#ifdef BCM_ACCEL
-	if (!m_bcm_accel_state)
-	{
-		unsigned int pal_addr = 0;
-		int src_format = 0;
-		if (src->bpp == 32)
-			src_format = 0;
-		else if ((src->bpp == 8) && src->clut.data)
-		{
-			src_format = 1;
-			/* sync pal */
-			if (src->clut.data_phys == 0)
-			{
-				/* sync pal */
-				pal_addr = src->stride * src->y;
-				unsigned int *pal = (unsigned int*)(((unsigned char*)src->data) + pal_addr);
-				pal_addr += src->data_phys;
-				for (int i = 0; i < src->clut.colors; ++i)
-					*pal++ = src->clut.data[i].argb() ^ 0xFF000000;
-				src->clut.data_phys = pal_addr;
+	int src_format = 0;
+	gUnmanagedSurface *surfaceTmp = new gUnmanagedSurface(area.width(), area.height(), dst->bpp);
+
+	if (src->bpp == 32)
+	{
+		src_format = 0;
+	}
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+		if (accelAlloc(surfaceTmp))
+		{
+			return -1;
+		}
+		__u8 *srcptr = (__u8*)src->data;
+		__u8 *dstptr = (__u8*)surfaceTmp->data;
+		__u32 pal[256];
+
+		for (int i = 0; i < 256; ++i)
+		{
+			if (src->clut.data && (i < src->clut.colors))
+			{
+				pal[i] = (src->clut.data[i].a << 24)|(src->clut.data[i].r << 16)|(src->clut.data[i].g << 8)|(src->clut.data[i].b);
 			}
 			else
 			{
-				pal_addr = src->clut.data_phys;
-			}
-		} else
-			return -1; /* unsupported source format */
-
-		bcm_accel_blit(
+				pal[i] = 0x010101 * i;
+			}
+			if ((pal[i]&0xFF000000) >= 0xE0000000)
+			{
+				pal[i] = 0xFF000000;
+			}
+			pal[i] ^= 0xFF000000;
+		}
+		srcptr += area.left() * src->bypp + area.top() * src->stride;
+
+		for (int y = 0; y < area.height(); y++)
+		{
+			int width = area.width();
+			unsigned char *psrc = (unsigned char*)srcptr;
+			__u32 *pdst = (__u32*)dstptr;
+
+			while (width--)
+			{
+				*pdst ++= pal[*psrc++];
+			}
+			srcptr += src->stride;
+			dstptr += area.width() * 4;
+		}
+	}
+	else
+	{
+		if (surfaceTmp->data_phys)
+		{
+			accelFree(surfaceTmp);
+		}
+		return -1;
+	}
+
+	if (surfaceTmp->data_phys)
+	{
+		stmfb_accel_blit(
+			surfaceTmp->data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(surfaceTmp);
+	}
+	else
+	{
+		stmfb_accel_blit(
 			src->data_phys, src->x, src->y, src->stride, src_format,
 			dst->data_phys, dst->x, dst->y, dst->stride,
 			area.left(), area.top(), area.width(), area.height(),
-			p.x(), p.y(), p.width(), p.height(),
-			pal_addr, flags);
-		return 0;
-	}
-#endif
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
 	return -1;
 }
 
@@ -174,37 +199,16 @@
 #ifdef FORCE_NO_FILL_ACCELERATION
 	return -1;
 #endif
-#ifdef BCM_ACCEL
-	if (!m_bcm_accel_state) {
-		bcm_accel_fill(
-			dst->data_phys, dst->x, dst->y, dst->stride,
-			area.left(), area.top(), area.width(), area.height(),
-			col);
-		return 0;
-	}
-#endif
 	return -1;
 }
 
 int gAccel::accumulate()
 {
-#ifdef BCM_ACCEL
-	if (!m_bcm_accel_state)
-	{
-		return bcm_accel_accumulate();
-	}
-#endif
 	return -1;
 }
 
 int gAccel::sync()
 {
-#ifdef BCM_ACCEL
-	if (!m_bcm_accel_state)
-	{
-		return bcm_accel_sync();
-	}
-#endif
 	return -1;
 }
 
@@ -264,9 +268,9 @@
 
 void gAccel::accelFree(gUnmanagedSurface* surface)
 {
-	int phys_addr = surface->data_phys;
-	if (phys_addr != 0)
-	{
+	if (surface != 0 && surface->data_phys != 0)
+	{
+		int phys_addr = surface->data_phys;
 #ifdef ACCEL_DEBUG
 		eDebug("[gAccel] [%s] %p->%x %dx%d:%d", __func__, surface, surface->data_phys, surface->x, surface->y, surface->bpp);
 #endif
--- enigma2.org/lib/gdi/accel.h
+++ enigma2/lib/gdi/accel.h
@@ -48,7 +48,6 @@
 	int m_accel_phys_addr;
 	int m_accel_size; // in blocks
 	MemoryBlockList m_accel_allocation;
-	int m_bcm_accel_state;
 
 	static gAccel *instance;
 };
--- enigma2.org/lib/gdi/epng.cpp
+++ enigma2/lib/gdi/epng.cpp
@@ -9,6 +9,9 @@
 #include <unistd.h>
 
 extern "C" {
+#if defined HAVE_STDLIB_H
+#undef HAVE_STDLIB_H
+#endif
 #include <jpeglib.h>
 }
 
--- enigma2.org/lib/gdi/fb.cpp
+++ enigma2/lib/gdi/fb.cpp
@@ -8,6 +8,7 @@
 #include <linux/kd.h>
 
 #include <lib/gdi/fb.h>
+#include <linux/stmfb.h>
 
 #ifndef FBIO_WAITFORVSYNC
 #define FBIO_WAITFORVSYNC _IOW('F', 0x20, uint32_t)
@@ -47,12 +48,6 @@
 	}
 
 
-	if (ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo)<0)
-	{
-		eDebug("[fb] FBIOGET_VSCREENINFO: %m");
-		goto nolfb;
-	}
-
 	fb_fix_screeninfo fix;
 	if (ioctl(fbFd, FBIOGET_FSCREENINFO, &fix)<0)
 	{
@@ -62,17 +57,17 @@
 
 	available=fix.smem_len;
 	m_phys_mem = fix.smem_start;
-	eDebug("[fb] %s: %dk video mem", fb, available/1024);
-	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 0);
+	eDebug("[fb] %dk total video memory", available / 1024);
+	// The first 1920x1080x4 bytes are reserved
+	// After that we can take 1280x720x4 bytes for our virtual framebuffer
+	available -= 1920 * 1080 * 4;
+	eDebug("%dk usable video memory", available / 1024);
+	lfb = (unsigned char *)mmap(0, available, PROT_WRITE | PROT_READ, MAP_SHARED, fbFd, 1920 * 1080 * 4);
 	if (!lfb)
 	{
 		eDebug("[fb] mmap: %m");
 		goto nolfb;
 	}
-
-	showConsole(0);
-
-	enableManualBlit();
 	return;
 nolfb:
 	if (fbFd >= 0)
@@ -84,99 +79,27 @@
 	return;
 }
 
-int fbClass::showConsole(int state)
-{
-	int fd=open("/dev/tty0", O_RDWR);
-	if(fd>=0)
-	{
-		if(ioctl(fd, KDSETMODE, state?KD_TEXT:KD_GRAPHICS)<0)
-		{
-			eDebug("[fb] setting /dev/tty0 status failed.");
-		}
-		close(fd);
-	}
-	return 0;
-}
-
 int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 {
-	if (fbFd < 0) return -1;
-	screeninfo.xres_virtual=screeninfo.xres=nxRes;
-	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
-	screeninfo.height=0;
-	screeninfo.width=0;
-	screeninfo.xoffset=screeninfo.yoffset=0;
-	screeninfo.bits_per_pixel=nbpp;
-
-	switch (nbpp) {
-	case 16:
-		// ARGB 1555
-		screeninfo.transp.offset = 15;
-		screeninfo.transp.length = 1;
-		screeninfo.red.offset = 10;
-		screeninfo.red.length = 5;
-		screeninfo.green.offset = 5;
-		screeninfo.green.length = 5;
-		screeninfo.blue.offset = 0;
-		screeninfo.blue.length = 5;
-		break;
-	case 32:
-		// ARGB 8888
-		screeninfo.transp.offset = 24;
-		screeninfo.transp.length = 8;
-		screeninfo.red.offset = 16;
-		screeninfo.red.length = 8;
-		screeninfo.green.offset = 8;
-		screeninfo.green.length = 8;
-		screeninfo.blue.offset = 0;
-		screeninfo.blue.length = 8;
-		break;
-	}
-
-	if (ioctl(fbFd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
-	{
-		// try single buffering
-		screeninfo.yres_virtual=screeninfo.yres=nyRes;
-
-		if (ioctl(fbFd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
-		{
-			eDebug("[fb] FBIOPUT_VSCREENINFO: %m");
-			return -1;
-		}
-		eDebug("[fb] double buffering not available.");
-	} else
-		eDebug("[fb] double buffering available!");
-
-	m_number_of_pages = screeninfo.yres_virtual / nyRes;
-
+	xRes = nxRes;
+	yRes = nyRes;
+	bpp = 32;
+	m_number_of_pages = 1;
+	topDiff = bottomDiff = leftDiff = rightDiff = 0;
 	ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo);
 
-	if ((screeninfo.xres != (unsigned int)nxRes) || (screeninfo.yres != (unsigned int)nyRes) ||
-		(screeninfo.bits_per_pixel != (unsigned int)nbpp))
-	{
-		eDebug("[fb] SetMode failed: wanted: %dx%dx%d, got %dx%dx%d",
-			nxRes, nyRes, nbpp,
-			screeninfo.xres, screeninfo.yres, screeninfo.bits_per_pixel);
-	}
-	xRes=screeninfo.xres;
-	yRes=screeninfo.yres;
-	bpp=screeninfo.bits_per_pixel;
-	fb_fix_screeninfo fix;
-	if (ioctl(fbFd, FBIOGET_FSCREENINFO, &fix)<0)
-	{
-		eDebug("[fb] FBIOGET_FSCREENINFO: %m");
-	}
-	stride=fix.line_length;
-	memset(lfb, 0, stride*yRes);
+	xResSc = screeninfo.xres;
+	yResSc = screeninfo.yres;
+	stride = xRes*4;
 	blit();
 	return 0;
 }
 
 void fbClass::getMode(int &xres, int &yres, int &bpp)
 {
-	xres = screeninfo.xres;
-	yres = screeninfo.yres;
-	bpp = screeninfo.bits_per_pixel;
+	xres = xRes;
+	yres = yRes;
+	bpp = 32;
 }
 
 int fbClass::setOffset(int off)
@@ -196,10 +119,85 @@
 
 void fbClass::blit()
 {
-	if (fbFd < 0) return;
-	if (m_manual_blit == 1) {
-		if (ioctl(fbFd, FBIO_BLIT) < 0)
-			eDebug("[fb] FBIO_BLIT: %m");
+	int modefd = open("/proc/stb/video/3d_mode", O_RDWR);
+	char buf[16] = "off";
+	if (modefd > 0)
+	{
+		read(modefd, buf, 15);
+		buf[15]='\0';
+		close(modefd);
+	}
+
+	STMFBIO_BLT_DATA     bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = 1920 * 1080 * 4;
+	bltData.srcPitch   = xRes * 4;
+	bltData.dstOffset  = 0;
+	bltData.dstPitch   = xResSc * 4;
+	bltData.src_top    = 0;
+	bltData.src_left   = 0;
+	bltData.src_right  = xRes;
+	bltData.src_bottom = yRes;
+	bltData.srcFormat  = SURF_BGRA8888;
+	bltData.dstFormat  = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER;
+	bltData.dstMemBase = STMFBGP_FRAMEBUFFER;
+
+	if (strncmp(buf, "sbs", 3) == 0)
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff / 2;
+		bltData.dst_right  = xResSc / 2 + rightDiff / 2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = xResSc / 2 + leftDiff / 2;
+		bltData.dst_right  = xResSc + rightDiff / 2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else if (strncmp(buf, "tab", 3) == 0)
+	{
+		bltData.dst_top    = 0 + topDiff / 2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc / 2 + bottomDiff / 2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = yResSc / 2 + topDiff / 2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff / 2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	
+	}
+
+	if (ioctl(fbFd, STMFBIO_SYNC_BLITTER) < 0)
+	{
+		perror("STMFBIO_SYNC_BLITTER");
 	}
 }
 
@@ -210,8 +208,6 @@
 		msync(lfb, available, MS_SYNC);
 		munmap(lfb, available);
 	}
-	showConsole(1);
-	disableManualBlit();
 	if (fbFd >= 0)
 	{
 		::close(fbFd);
@@ -229,13 +225,24 @@
 {
 	if (locked)
 		return -1;
-	if (m_manual_blit == 1)
-	{
-		locked = 2;
-		disableManualBlit();
-	}
-	else
-		locked = 1;
+	locked = 1;
+	outcfg.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl(fbFd, STMFBIO_GET_OUTPUT_CONFIG, &outcfg) < 0)
+		perror("STMFBIO_GET_OUTPUT_CONFIG\n");
+
+	outinfo.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl(fbFd, STMFBIO_GET_OUTPUTINFO, &outinfo) < 0)
+		perror("STMFBIO_GET_OUTPUTINFO\n");
+
+	//if (ioctl(fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex) < 0)
+	//	printf("ERROR\n");
+
+	planemode.layerid = 0;
+	if (ioctl(fbFd, STMFBIO_GET_PLANEMODE, &planemode) < 0)
+		perror("STMFBIO_GET_PLANEMODE\n");
+
+	if (ioctl(fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex) < 0)
+		perror("STMFBIO_GET_VAR_SCREENINFO_EX\n");
 	return fbFd;
 }
 
@@ -243,30 +250,62 @@
 {
 	if (!locked)
 		return;
-	if (locked == 2)  // re-enable manualBlit
-		enableManualBlit();
 	locked=0;
+
+	if (ioctl(fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl(fbFd, STMFBIO_SET_PLANEMODE, &planemode) < 0)
+		perror("STMFBIO_SET_PLANEMODE\n");
+
+	if (ioctl(fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl(fbFd, STMFBIO_SET_OUTPUTINFO, &outinfo) < 0)
+		perror("STMFBIO_SET_OUTPUTINFO\n");
+
+	if (ioctl(fbFd, STMFBIO_SET_OUTPUT_CONFIG, &outcfg) < 0)
+		perror("STMFBIO_SET_OUTPUT_CONFIG\n");
+
+	memset(lfb, 0, stride * yRes);
+
 	SetMode(xRes, yRes, bpp);
 	PutCMAP();
 }
 
-void fbClass::enableManualBlit()
-{
-	unsigned char tmp = 1;
-	if (fbFd < 0) return;
-	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
-		eDebug("[fb] enable FBIO_SET_MANUAL_BLIT: %m");
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+//	memset(lfb, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if (ret == 0)
+		return topDiff;
+	else if (ret == 1)
+		return leftDiff;
+	else if (ret == 2)
+		return rightDiff;
+	else if (ret == 3)
+		return bottomDiff;
 	else
-		m_manual_blit = 1;
-}
-
-void fbClass::disableManualBlit()
-{
-	unsigned char tmp = 0;
-	if (fbFd < 0) return;
-	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
-		eDebug("[fb] disable FBIO_SET_MANUAL_BLIT: %m");
-	else
-		m_manual_blit = 0;
-}
-
+		return -1;
+}
+
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
--- enigma2.org/lib/gdi/fb.h
+++ enigma2/lib/gdi/fb.h
@@ -3,6 +3,7 @@
 
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
+#include <linux/stmfb.h>
 
 #ifndef FB_DEV
 # define FB_DEV "/dev/fb0"
@@ -12,6 +13,13 @@
 {
 	int fbFd;
 	int xRes, yRes, stride, bpp;
+	struct stmfbio_output_configuration outcfg;
+	struct stmfbio_outputinfo outinfo;
+	struct stmfbio_planeinfo planemode;
+	struct stmfbio_var_screeninfo_ex infoex;
+
+	int xResSc, yResSc;
+	int topDiff, leftDiff, rightDiff, bottomDiff;
 	int available;
 	struct fb_var_screeninfo screeninfo;
 	fb_cmap cmap;
@@ -29,9 +37,6 @@
 #else
 public:
 	unsigned char *lfb;
-	void enableManualBlit();
-	void disableManualBlit();
-	int showConsole(int state);
 	int SetMode(int xRes, int yRes, int bpp);
 	void getMode(int &xres, int &yres, int &bpp);
 	int Available() { return available; }
@@ -53,6 +58,16 @@
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+//#if defined ENABLE_LIBEPLAYER3
+//	"hack" for libeplayer3 fb access
+	int getFD() { return fbFd; }
+	unsigned char * getLFB_Direct() { return lfb; }
+	int getScreenResX() { return xRes; }
+	int getScreenResY() { return yRes; }
+//#endif
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
 
 	int lock();
 	void unlock();
--- enigma2.org/lib/gdi/font.cpp
+++ enigma2/lib/gdi/font.cpp
@@ -26,6 +26,11 @@
 #include <lib/base/init.h>
 #include <lib/base/init_num.h>
 
+// undefine macro to fix build
+// against fribidi 0.19.7+
+#if defined HAVE_CONFIG_H
+#undef HAVE_CONFIG_H
+#endif
 #include <fribidi/fribidi.h>
 
 #include <map>
--- enigma2.org/lib/gdi/gfbdc.cpp
+++ enigma2/lib/gdi/gfbdc.cpp
@@ -25,8 +25,8 @@
 		|| (xres == 1920 && yres == 1080)))
 	{
 		/* fallback to a decent default */
-		xres = 720;
-		yres = 576;
+		xres = 1280; //j00zek let us make HD our default for OpenPLi
+		yres = 720;
 	}
 
 	surface.clut.data = 0;
@@ -177,14 +177,30 @@
 
 void gFBDC::setResolution(int xres, int yres, int bpp)
 {
-	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp))
+	/* if xres and yres are negative call SetMode with the latest xres and yres
+	 * we need that to read the new screen dimensions after a resolution change
+	 * without changing the framebuffer dimensions
+	 */
+	int m_xres;
+	int m_yres;
+	int m_bpp;
+	fb->getMode(m_xres, m_yres, m_bpp);
+
+	if (xres < 0 && yres < 0)
+	{
+		fb->SetMode(m_xres, m_yres, bpp);
 		return;
+	}
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->releaseAccelMemorySpace();
 
 	fb->SetMode(xres, yres, bpp);
 
+	for (int y = 0; y < yres; y++)
+	{ // make whole screen transparent
+		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
+	}
 	surface.x = xres;
 	surface.y = yres;
 	surface.bpp = bpp;
--- enigma2.org/lib/gdi/glcddc.cpp
+++ enigma2/lib/gdi/glcddc.cpp
@@ -1,19 +1,40 @@
 #include <lib/gdi/glcddc.h>
 #include <lib/gdi/lcd.h>
+#ifndef NO_LCD
 #include <lib/gdi/fblcd.h>
+#endif
 #include <lib/base/init.h>
 #include <lib/base/init_num.h>
 
 gLCDDC *gLCDDC::instance;
 
+#ifdef HAVE_GRAPHLCD
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 gLCDDC::gLCDDC()
 {
+#ifndef NO_LCD
 	lcd = new eFbLCD();
 	if (!lcd->detected())
 	{
 		delete lcd;
 		lcd = new eDBoxLCD();
 	}
+#else
+	lcd = new eDBoxLCD();
+#endif
 	instance = this;
 
 	update = 1;
@@ -39,11 +60,18 @@
 	eDebug("[gLCDDC] resolution: %dx%dx%d stride=%d", surface.x, surface.y, surface.bpp, surface.stride);
 
 	m_pixmap = new gPixmap(&surface);
+#ifdef HAVE_GRAPHLCD
+	clock_gettime(CLOCK_MONOTONIC, &last_update);
+#endif
 }
 
 gLCDDC::~gLCDDC()
 {
+#ifndef HAVE_GRAPHLCD
+//konfetti: not sure why, but calling the destructor if external lcd (pearl) is selected
+//e2 crashes. this is also true if the destructor does not contain any code !!!
 	delete lcd;
+#endif
 	if (surface.clut.data)
 		delete[] surface.clut.data;
 	instance = 0;
@@ -53,6 +81,7 @@
 {
 	switch (o->opcode)
 	{
+#ifndef NO_LCD
 	case gOpcode::setPalette:
 	{
 		gDC::exec(o);
@@ -69,8 +98,26 @@
 		delete o->parm.renderText;
 		break;
 #endif
+#else
+	case gOpcode::renderText:
+		if (o->parm.renderText->text)
+		{
+			lcd->renderText(o->parm.renderText->text);
+			free(o->parm.renderText->text);
+		}
+		delete o->parm.renderText;
+		break;
+#endif
 	case gOpcode::flush:
+#ifdef HAVE_GRAPHLCD
+		if (update)
+		{
+			lcd->update();
+			clock_gettime(CLOCK_MONOTONIC, &last_update);
+		}
+#else
 		lcd->update();
+#endif
 		[[fallthrough]];
 	default:
 		gDC::exec(o);
--- enigma2.org/lib/gdi/glcddc.h
+++ enigma2/lib/gdi/glcddc.h
@@ -11,6 +11,9 @@
 	int update;
 	void exec(const gOpcode *opcode);
 	gUnmanagedSurface surface;
+#ifdef HAVE_GRAPHLCD
+	struct timespec last_update;
+#endif
 public:
 	gLCDDC();
 	~gLCDDC();
--- enigma2.org/lib/gdi/gpixmap.cpp
+++ enigma2/lib/gdi/gpixmap.cpp
@@ -195,14 +195,20 @@
 static bool is_a_candidate_for_accel(const gUnmanagedSurface* surface)
 {
 	if (surface->stride < 48)
+	{
 		return false;
+	}
 	switch (surface->bpp)
 	{
 		case 8:
 		case 32:
+		{
 			return (surface->y * surface->stride) >= GFX_SURFACE_ACCELERATION_THRESHOLD;
+		}
 		default:
+		{
 			return false;
+		}
 	}
 }
 
@@ -228,11 +234,13 @@
 	if (data)
 	{
 		delete [] (unsigned char*)data;
+		data = 0;
 		removed_pixmap(y * stride);
 	}
 	if (clut.data)
 	{
 		delete [] clut.data;
+		clut.data = 0;
 	}
 }
 
@@ -248,8 +256,9 @@
 		if (surface->bpp == 8)
 		{
 			for (int y=area.top(); y<area.bottom(); y++)
-		 		memset(((__u8*)surface->data)+y*surface->stride+area.left(), color.color, area.width());
-		} else if (surface->bpp == 16)
+		 		memset(((__u8 *)surface->data) + y * surface->stride + area.left(), color.color, area.width());
+		}
+	 else if (surface->bpp == 16)
 		{
 			uint32_t icol;
 
@@ -276,9 +285,14 @@
 			if (surface->clut.data && color < surface->clut.colors)
 				col = surface->clut.data[color].argb();
 			else
+			{
+				if ((col&0xFF000000) == 0xFF000000)
+				{
+					col = 0xFF000000;
+				}
 				col = 0x10101 * color;
-
-			col^=0xFF000000;
+			}
+			col ^= 0xFF000000;
 
 #ifdef GPIXMAP_DEBUG
 			Stopwatch s;
@@ -333,7 +347,11 @@
 			uint32_t col;
 
 			col = color.argb();
-			col^=0xFF000000;
+			if ((col & 0xFF000000) == 0xFF000000)
+			{
+				col = 0xFF000000;
+			}
+			col ^= 0xFF000000;
 
 #ifdef GPIXMAP_DEBUG
 			Stopwatch s;
@@ -621,7 +639,8 @@
 		Stopwatch s;
 #endif
 		if (accel) {
-			if (!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag)) {
+			if (!(src.surface->bpp==8 && surface->bpp==32) && 
+					(!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag))) {
 #ifdef GPIXMAP_DEBUG
 				s.stop();
 				eDebug("[gPixmap] [BLITBENCH] accel blit (%d bytes) took %u us", srcarea.surface() * src.surface->bypp, s.elapsed_us());
@@ -1010,6 +1029,7 @@
 	}
 
 	delete [] lookup;
+	lookup = 0;
 }
 
 static inline int sgn(int a)
--- enigma2.org/lib/gdi/lcd.cpp
+++ enigma2/lib/gdi/lcd.cpp
@@ -57,6 +57,7 @@
 	locked = 0;
 }
 
+#ifndef NO_LCD
 #ifdef HAVE_TEXTLCD
 void eLCD::renderText(ePoint start, const char *text)
 {
@@ -71,10 +72,18 @@
 	}
 }
 #endif
-
+#else
+void eLCD::renderText(const char *text)
+{
+	//eDebug("[LCD] text: %s", text);
+	vfd->vfd_write_string(text, true);
+}
+#endif
+
+#ifndef HAVE_GRAPHLCD
 eDBoxLCD::eDBoxLCD()
 {
-	int xres = 132, yres = 64, bpp = 8;
+	int xres = 32, yres = 32, bpp = 8;
 	flipped = false;
 	inverted = 0;
 	lcd_type = 0;
@@ -133,6 +142,12 @@
 		setSize(xres, yres, bpp);
 	}
 #endif
+	instance = this;
+
+	setSize(xres, yres, bpp);
+#ifdef NO_LCD
+	vfd = new evfd;
+#endif
 }
 
 void eDBoxLCD::setInverted(unsigned char inv)
@@ -210,15 +225,20 @@
 
 eDBoxLCD::~eDBoxLCD()
 {
+#ifndef NO_LCD
 	if (lcdfd >= 0)
 	{
 		close(lcdfd);
 		lcdfd = -1;
 	}
+#else
+	delete vfd;
+#endif
 }
 
 void eDBoxLCD::update()
 {
+#ifndef NO_LCD
 #ifndef HAVE_TEXTLCD
 	if (lcdfd < 0)
 		return;
@@ -298,9 +318,148 @@
 		write(lcdfd, raw, 64 * 64);
 	}
 #endif
+#endif
 }
 
 void eDBoxLCD::dumpLCD(bool png)
 {
 	return;
 }
+
+#else
+
+void eDBoxLCD::setFlipped(bool onoff)
+{
+	flipped = onoff;
+	update();
+}
+
+/* **************************************************************** */
+/* Pearl LCD */
+
+eDBoxLCD::eDBoxLCD()
+{
+	eDebug("eDBoxLCD::eDBoxLCD >");
+
+	displayNumber = 0;
+	lcd_type = 1;
+
+	instance = this;
+
+	if (GLCD::Config.Load("/etc/graphlcd.conf") == false)
+	{
+		eDebug("Error loading config file!\n");
+		return;
+	}
+	if (GLCD::Config.driverConfigs.size() <= 0)
+	{
+		eDebug("ERROR: No displays specified in config file!\n");
+	}
+
+	GLCD::Config.driverConfigs[displayNumber].upsideDown ^= 0;
+	GLCD::Config.driverConfigs[displayNumber].invert ^= 0;
+
+	lcd = GLCD::CreateDriver(GLCD::Config.driverConfigs[displayNumber].id, &GLCD::Config.driverConfigs[displayNumber]);
+
+	if (!lcd)
+	{
+		eDebug("ERROR: Failed creating display object\n");
+		return;
+	}
+	if (lcd->Init() != 0)
+	{
+#if 0
+	// Returning an error here will break the code at various other places
+		eDebug("ERROR: Failed initializing display\n");
+		delete lcd;
+		lcd = NULL;
+		return;
+#endif
+	}
+	lcd->SetBrightness(GLCD::Config.driverConfigs[displayNumber].brightness);
+
+	lcd->GetFeature((std::string) "depth", depth);
+	width = GLCD::Config.driverConfigs[displayNumber].width;
+	height = GLCD::Config.driverConfigs[displayNumber].height;
+
+	eDebug("config -> (w %d, h %d)", width, height);
+
+	bitmap = new GLCD::cBitmap(width, height);
+	bitmap->Clear();
+
+	lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+	lcd->Refresh(true);
+
+	lcdfd = 1; //needed for detected()
+	setSize(width, height, depth);
+
+	eDebug("eDBoxLCD::eDBoxLCD (w %d, h %d, depth %d)<", width, height, depth);
+}
+
+void eDBoxLCD::setInverted(unsigned char inv)
+{
+	eDebug("eDBoxLCD::setInverted");
+	inverted = inv;
+	update();
+}
+
+int eDBoxLCD::setLCDContrast(int contrast)
+{
+	eDebug("[LCD] setLCDContrast not supported");
+	return(0);
+}
+
+int eDBoxLCD::setLCDBrightness(int brightness)
+{
+	eDebug("eDBoxLCD::setLCDBrightness");
+/* fixme range check */
+	lcd->SetBrightness(brightness);
+	return(0);
+}
+
+eDBoxLCD::~eDBoxLCD()
+{
+	eDebug("eDBoxLCD::~eDBoxLCD");
+}
+
+eDBoxLCD *eDBoxLCD::getInstance()
+{
+	eDebug("eDBoxLCD::getInstance");
+	return instance;
+}
+
+void eDBoxLCD::update()
+{
+	if (lcdfd == 1)
+	{
+		bitmap->Clear();
+		for (int x = 0; x < width; x++)
+			for (int y = 0; y < height; y++)
+			{
+				__u16 *buf16  = (__u16 *) _buffer;
+#if BYTE_ORDER == LITTLE_ENDIAN
+				__u16 col16 = bswap_16(*((__u16 *)(((__u16*)buf16) + y * width + x)));
+#else
+				__u16 col16 = *((__u16*)(((__u16 *)buf16) + y * width + x));
+#endif
+				__u8 red, green, blue, alpha; 
+				__u32 color32;
+
+				/* BBBBB GGGGGG RRRRR */
+				blue  = ((col16 & 0xF800) >> 11) * ( 255 / 31);
+				green = ((col16 & 0x7E0) >> 5) * (255 / 63);
+				red   = (col16 & 0x1f) * (255 / 31);
+				alpha = 255;
+
+				color32 = alpha << 24 | red << 16 | green << 8 | blue;
+
+				if (inverted)
+					color32 = 0xFFFFFF - color32;
+
+				bitmap->DrawPixel(x, y, color32);
+			}
+		lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+		lcd->Refresh(false); /* partial update */
+	}
+}
+#endif
--- enigma2.org/lib/gdi/lcd.h
+++ enigma2/lib/gdi/lcd.h
@@ -5,6 +5,21 @@
 #include <lib/gdi/esize.h>
 #include <lib/gdi/erect.h>
 #include "gpixmap.h"
+
+#ifdef HAVE_GRAPHLCD
+#include <glcdgraphics/bitmap.h>
+#include <glcdgraphics/glcd.h>
+#include <glcdgraphics/image.h>
+#include <glcddrivers/config.h>
+#include <glcddrivers/driver.h>
+#include <glcddrivers/drivers.h>
+#include <glcdgraphics/extformats.h>
+#include <byteswap.h>
+#endif
+
+#ifdef NO_LCD
+#include <lib/driver/vfd.h>
+#endif
 
 #define LCD_CONTRAST_MIN 0
 #define LCD_CONTRAST_MAX 63
@@ -26,6 +41,9 @@
 	int locked;
 	static eLCD *instance;
 	void setSize(int xres, int yres, int bpp);
+#ifdef NO_LCD
+	evfd *vfd;
+#endif
 #endif
 public:
 	static eLCD *getInstance();
@@ -49,8 +67,12 @@
 	int stride() { return _stride; };
 	virtual eSize size() { return res; };
 	virtual void update()=0;
+#ifndef NO_LCD
 #ifdef HAVE_TEXTLCD
 	virtual void renderText(ePoint start, const char *text);
+#endif
+#else
+	virtual void renderText(const char *text);
 #endif
 #endif
 };
@@ -59,6 +81,13 @@
 {
 	unsigned char inverted;
 	bool flipped;
+#ifdef HAVE_GRAPHLCD
+	GLCD::cDriver * lcd;
+	GLCD::cBitmap * bitmap;
+	int displayNumber;
+	int depth;
+	int width, height;
+#endif
 #ifdef SWIG
 	eDBoxLCD();
 	~eDBoxLCD();
--- enigma2.org/lib/gdi/Makefile.inc
+++ enigma2/lib/gdi/Makefile.inc
@@ -4,7 +4,6 @@
 
 gdi_libenigma_gdi_a_SOURCES = \
 	gdi/accel.cpp \
-	gdi/bcm.cpp \
 	gdi/compositing.cpp \
 	gdi/epng.cpp \
 	gdi/erect.cpp \
@@ -21,7 +20,8 @@
 	gdi/picexif.cpp \
 	gdi/picload.cpp \
 	gdi/pixmapcache.cpp \
-	gdi/region.cpp
+	gdi/region.cpp \
+	gdi/stmfb.cpp
 
 gdiincludedir = $(pkgincludedir)/lib/gdi
 gdiinclude_HEADERS = \
--- enigma2.org/lib/gdi/picload.cpp
+++ enigma2/lib/gdi/picload.cpp
@@ -5,13 +5,19 @@
 #include <lib/base/cfile.h>
 #include <lib/base/wrappers.h>
 #include <lib/gdi/picload.h>
+#include <libmme_image/libmmeimage.h>
 
 extern "C" {
 #define HAVE_BOOLEAN
 #define boolean int
+#if defined HAVE_STDLIB_H
+#undef HAVE_STDLIB_H
+#endif
 #include <jpeglib.h>
 #include <gif_lib.h>
 }
+
+//#define HARDWARE_DECODING
 
 #define NANOSVG_ALL_COLOR_KEYWORDS
 #define NANOSVG_IMPLEMENTATION
@@ -26,9 +32,12 @@
 static std::string getSize(const char* file)
 {
 	struct stat64 s;
+	char tmp[20];
+
 	if (stat64(file, &s) < 0)
 		return "";
-	return std::to_string((long)(s.st_size / 1024)) + " kB";
+	snprintf(tmp, 20, "%ld kB", (long)s.st_size / 1024);
+	return tmp;
 }
 
 static unsigned char *color_resize(unsigned char * orgin, int ox, int oy, int dx, int dy)
@@ -40,7 +49,7 @@
 		return orgin;
 	}
 	const int stride = 3 * dx;
-	#pragma omp parallel for
+//	#pragma omp parallel for
 	for (int j = 0; j < dy; j++)
 	{
 		unsigned char* p = cr + (j * stride);
@@ -617,12 +626,9 @@
 	ColorMapObject *cmap;
 	int cmaps;
 	int extcode;
-
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	gft = DGifOpenFileName(filepara->file, &extcode);
-#else
-	gft = DGifOpenFileName(filepara->file);
-#endif
+	int GifLastError; 
+
+	gft = DGifOpenFileName(filepara->file, &GifLastError); 
 	if (gft == NULL)
 		return;
 	do
@@ -712,19 +718,11 @@
 	}
 	while (rt != TERMINATE_RECORD_TYPE);
 
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	DGifCloseFile(gft, &extcode);
-#else
-	DGifCloseFile(gft);
-#endif
+	DGifCloseFile(gft, &GifLastError);
 	return;
 ERROR_R:
 	eDebug("[ePicLoad] <Error gif>");
-#if GIFLIB_MAJOR > 5 || GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1
-	DGifCloseFile(gft, &extcode);
-#else
-	DGifCloseFile(gft);
-#endif
+	DGifCloseFile(gft, &GifLastError);
 }
 
 //---------------------------------------------------------------------------------------------
@@ -789,9 +787,10 @@
 
 void ePicLoad::decodePic()
 {
+	getExif(m_filepara->file, m_filepara->id);
+#ifndef HARDWARE_DECODING
 	eDebug("[ePicLoad] decode picture... %s", m_filepara->file);
 
-	getExif(m_filepara->file, m_filepara->id);
 	switch(m_filepara->id)
 	{
 		case F_PNG:	png_load(m_filepara, m_conf.background);
@@ -805,6 +804,37 @@
 		case F_SVG:	svg_load(m_filepara);
 				break;
 	}
+#else
+	if (m_filepara->id == F_JPEG)
+	{
+		eDebug("[ePicLoad] hardware decode picture... %s", m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+
+		if (get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			// to get the best picture quality even if it rotated later
+			float scale = (float)(m_filepara->max_x > m_filepara->max_y ? m_filepara->max_x : m_filepara->max_y) / (m_filepara->ox > m_filepara->oy ? m_filepara->ox : m_filepara->oy);
+			int imx = (int)(m_filepara->ox * scale);
+			int imy = (int)(m_filepara->oy * scale);
+
+			if (decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				return;
+			}
+		}
+		eDebug("[ePicLoad] hardware decode error");
+		fclose(fp);
+		m_filepara->pic_buffer = NULL;
+	}
+
+#endif
 }
 
 void ePicLoad::decodeThumb()
@@ -817,6 +847,7 @@
 	std::string cachedir = "/.Thumbnails";
 
 	getExif(m_filepara->file, m_filepara->id, 1);
+
 	if (m_exif && m_exif->m_exifinfo->IsExif)
 	{
 		if (m_exif->m_exifinfo->Thumnailstate == 2)
@@ -873,8 +904,53 @@
 		}
 	}
 
-	switch (m_filepara->id)
-	{
+#if defined HARDWARE_DECODING
+	int hw_decoded = 0;
+	if (m_filepara->id == F_JPEG)
+	{
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if (get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+			if (m_filepara->ox <= m_filepara->oy)
+			{
+				imy = m_conf.thumbnailsize;
+				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+			}
+			else
+			{
+				imx = m_conf.thumbnailsize;
+				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+			}
+			
+			if (decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				hw_decoded = 1;
+			}
+		}
+
+		if (!hw_decoded)
+		{
+			eDebug("hardware decode error");
+		
+			fclose(fp);
+		}
+	}
+
+	if (!hw_decoded)
+#endif
+	{
+		switch(m_filepara->id)
+		{
 		case F_PNG:	png_load(m_filepara, m_conf.background, true);
 				break;
 		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, m_filepara->max_x, m_filepara->max_y);
@@ -885,6 +961,7 @@
 				break;
 		case F_SVG:	svg_load(m_filepara, true);
 				break;
+		}
 	}
 	//eDebug("[ePicLoad] getThumb picture loaded %s", m_filepara->file);
 
@@ -900,25 +977,32 @@
 				::mkdir(cachedir.c_str(), 0755);
 
 			// Resize for Thumbnail
-			int imx, imy;
-			if (m_filepara->ox <= m_filepara->oy)
-			{
-				imy = m_conf.thumbnailsize;
-				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
-			}
-			else
-			{
-				imx = m_conf.thumbnailsize;
-				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
-			}
-
-			// eDebug("[ePicLoad] getThumb resize from %dx%d to %dx%d", m_filepara->ox, m_filepara->oy, imx, imy);
-			m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
-			m_filepara->ox = imx;
-			m_filepara->oy = imy;
+#if defined HARDWARE_DECODING
+			if (!hw_decoded)
+#endif
+			{
+				int imx, imy;
+				if (m_filepara->ox <= m_filepara->oy)
+				{
+					imy = m_conf.thumbnailsize;
+					imx = (int)((m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy));
+				}
+				else
+				{
+					imx = m_conf.thumbnailsize;
+					imy = (int)((m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox));
+				}
+
+				// eDebug("[ePicLoad] getThumb resize from %dx%d to %dx%d", m_filepara->ox, m_filepara->oy, imx, imy);
+				m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy);
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+			}
 
 			if (jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
+			{
 				eDebug("[ePicLoad] getThumb: error saving cachefile");
+			}
 		}
 	}
 }
@@ -1029,7 +1113,7 @@
 {
 	ePyObject list;
 
-	// FIXME : m_filepara destroyed by getData. Need refactor this but plugins rely in it :(
+	// FIXME : m_filepara destroyed by getData. Need refactor this but plugins rely on it :(
 	getExif(filename, m_filepara ? m_filepara->id : -1);
 	if(m_exif && m_exif->m_exifinfo->IsExif)
 	{
@@ -1189,11 +1273,11 @@
 					*row_buffer++ = background;
 			}
 			int y;
-			#pragma omp parallel for
+//			#pragma omp parallel for
 			for (y = 1; y < yoff; ++y) // copy from first line
 				memcpy(tmp_buffer + y*surface->stride, tmp_buffer,
 					m_filepara->max_x * surface->bypp);
-			#pragma omp parallel for
+//			#pragma omp parallel for
 			for (y = yoff + scry; y < m_filepara->max_y; ++y)
 				memcpy(tmp_buffer + y * surface->stride, tmp_buffer,
 					m_filepara->max_x * surface->bypp);
@@ -1218,7 +1302,7 @@
 				for (x = xoff + scrx; x < m_filepara->max_x; ++x) // fill right side of first line
 					*row_buffer++ = background;
 			}
-			#pragma omp parallel for
+//			#pragma omp parallel for
 			for (int y = yoff + 1; y < scry; ++y) { // copy from first line
 				memcpy(tmp_buffer + y*surface->stride,
 					tmp_buffer + yoff * surface->stride,
@@ -1301,7 +1385,7 @@
 	// Fill surface with image data, resize and correct for orientation on the fly
 	if (m_filepara->bits == 8)
 	{
-		#pragma omp parallel for
+//		#pragma omp parallel for
 		for (int y = 0; y < scry; ++y) {
 			const unsigned char *irow, *irowy = origin + iyfac * (int)(y * yscale);
 			unsigned char *srow = tmp_buffer + surface->stride * y;
@@ -1315,7 +1399,7 @@
 	}
 	else // 24-bit images
 	{
-		#pragma omp parallel for
+//		#pragma omp parallel for
 		for (int y = 0; y < scry; ++y) {
 			const unsigned char *irow, *irowy = origin + iyfac * (int)(yscale * y);
 			unsigned char *srow = tmp_buffer + surface->stride * y;
--- enigma2.org/lib/gdi/stmfb.cpp
+++ enigma2/lib/gdi/stmfb.cpp
@@ -0,0 +1,73 @@
+/*
+  Interface to the STM Framebuffer proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+	bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+	bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+}
--- enigma2.org/lib/gui/ewidget.cpp
+++ enigma2/lib/gui/ewidget.cpp
@@ -106,7 +106,10 @@
 	res.moveBy(abspos);
 //	eDebug("[eWidget] region to invalidate:");
 //	dumpRegion(res);
-	root->m_desktop->invalidate(res, this, target_layer);
+	if (root && root->m_desktop)
+	{
+		root->m_desktop->invalidate(res, this, target_layer);
+	}
 }
 
 void eWidget::show()
@@ -140,11 +143,14 @@
 		abspos += root->position();
 	}
 
-	root->m_desktop->recalcClipRegions(root);
-
-	gRegion abs = m_visible_with_childs;
-	abs.moveBy(abspos);
-	root->m_desktop->invalidate(abs, this, target_layer);
+	if (root && root->m_desktop)
+	{
+		root->m_desktop->recalcClipRegions(root);
+
+		gRegion abs = m_visible_with_childs;
+		abs.moveBy(abspos);
+		root->m_desktop->invalidate(abs, this, target_layer);
+	}
 }
 
 void eWidget::hide()
@@ -174,11 +180,14 @@
 	}
 	ASSERT(root->m_desktop);
 
-	gRegion abs = m_visible_with_childs;
-	abs.moveBy(abspos);
-
-	root->m_desktop->recalcClipRegions(root);
-	root->m_desktop->invalidate(abs);
+        if (root && root->m_desktop)
+	{
+		gRegion abs = m_visible_with_childs;
+		abs.moveBy(abspos);
+
+		root->m_desktop->recalcClipRegions(root);
+		root->m_desktop->invalidate(abs);
+	}
 }
 
 void eWidget::raise()
--- enigma2.org/lib/gui/esubtitle.cpp
+++ enigma2/lib/gui/esubtitle.cpp
@@ -253,11 +253,20 @@
 	invalidate(m_visible_region); // invalidate new regions
 }
 
+void eSubtitleWidget::setPage(const eVobSubtitlePage &p)  // added for servicemp3epl
+{
+	eRect r = eRect(0, 0, 720, 576);
+	ePtr<gPixmap> pixmap = p.m_pixmap;
+	setPixmap(pixmap, r, r);
+	m_hide_subtitles_timer->start(p.m_timeout, true);
+}
+
 void eSubtitleWidget::clearPage()
 {
 	m_page_ok = 0;
 	m_dvb_page_ok = 0;
 	m_pango_page_ok = 0;
+	m_pixmap = 0;  // added for servicemp3epl
 	invalidate(m_visible_region);
 	m_visible_region.rects.clear();
 }
@@ -275,6 +284,7 @@
 		changed.scale(size().width(), pixmap->size().width(), size().height(), pixmap->size().height());
 
 	invalidate(changed);
+	m_visible_region = changed;  // added for servicemp3epl
 }
 
 int eSubtitleWidget::event(int event, void *data, void *data2)
--- enigma2.org/lib/gui/esubtitle.h
+++ enigma2/lib/gui/esubtitle.h
@@ -48,6 +48,7 @@
 	void setPage(const eDVBTeletextSubtitlePage &p);
 	void setPage(const eDVBSubtitlePage &p);
 	void setPage(const ePangoSubtitlePage &p);
+	void setPage(const eVobSubtitlePage &p);  // added for servicemp3epl
 	void clearPage();
 	void setPixmap(ePtr<gPixmap> &pixmap, gRegion changed, eRect dest = eRect(0, 0, 720, 576));
 	void destroy() { delete this; }
--- enigma2.org/lib/python/python_base.i
+++ enigma2/lib/python/python_base.i
@@ -140,7 +140,7 @@
 	{"get", (PyCFunction)eTimerPy_get_callback_list, METH_NOARGS,
 	 "get timeout callback list"
 	},
-	{}  /* Sentinel */
+	{NULL}  /* Sentinel */
 };
 
 static PyObject *
@@ -167,22 +167,48 @@
 	 (char*)"synonym for our self",
 	 NULL},
 
-	{} /* Sentinel */
+	{NULL} /* Sentinel */
 };
 
 static PyTypeObject eTimerPyType = {
 	PyVarObject_HEAD_INIT(NULL, 0)
 	"eBaseImpl.eTimer", /*tp_name*/
 	sizeof(eTimerPy), /*tp_basicsize*/
-	.tp_dealloc = (destructor)eTimerPy_dealloc,
-	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
-	.tp_doc = "eTimer objects",
-	.tp_traverse = (traverseproc)eTimerPy_traverse,
-	.tp_clear = (inquiry)eTimerPy_clear,
-	.tp_weaklistoffset = offsetof(eTimerPy, in_weakreflist),
-	.tp_methods = eTimerPy_methods,
-	.tp_getset = eTimerPy_getseters,
-	.tp_new = eTimerPy_new,
+	0, /*tp_itemsize*/
+	(destructor)eTimerPy_dealloc, /*tp_dealloc*/
+	0, /*tp_print*/
+	0, /*tp_getattr*/
+	0, /*tp_setattr*/
+	0, /*tp_compare*/
+	0, /*tp_repr*/
+	0, /*tp_as_number*/
+	0, /*tp_as_sequence*/
+	0, /*tp_as_mapping*/
+	0, /*tp_hash */
+	0, /*tp_call*/
+	0, /*tp_str*/
+	0, /*tp_getattro*/
+	0, /*tp_setattro*/
+	0, /*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+	"eTimer objects", /* tp_doc */
+	(traverseproc)eTimerPy_traverse, /* tp_traverse */
+	(inquiry)eTimerPy_clear, /* tp_clear */
+	0, /* tp_richcompare */
+	offsetof(eTimerPy, in_weakreflist), /* tp_weaklistoffset */
+	0, /* tp_iter */
+	0, /* tp_iternext */
+	eTimerPy_methods, /* tp_methods */
+	0, /* tp_members */
+	eTimerPy_getseters, /* tp_getset */
+	0, /* tp_base */
+	0, /* tp_dict */
+	0, /* tp_descr_get */
+	0, /* tp_descr_set */
+	0, /* tp_dictoffset */
+	0, /* tp_init */
+	0, /* tp_alloc */
+	eTimerPy_new, /* tp_new */
 };
 
 // eSocketNotifier replacement
@@ -311,7 +337,7 @@
 	{"setRequested", (PyCFunction)eSocketNotifierPy_set_requested, METH_VARARGS,
 	 "set requested"
 	},
-	{}  /* Sentinel */
+	{NULL}  /* Sentinel */
 };
 
 static PyObject *
@@ -325,26 +351,52 @@
 	 (getter)eSocketNotifierPy_get_cb_list, (setter)0,
 	 (char*)"returns the callback python list",
 	 NULL},
-	{} /* Sentinel */
+	{NULL} /* Sentinel */
 };
 
 static PyTypeObject eSocketNotifierPyType = {
 	PyVarObject_HEAD_INIT(NULL, 0)
 	"eBaseImpl.eSocketNotifier", /*tp_name*/
 	sizeof(eSocketNotifierPy), /*tp_basicsize*/
-	.tp_dealloc = (destructor)eSocketNotifierPy_dealloc,
-	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
-	.tp_doc = "eSocketNotifier objects",
-	.tp_traverse = (traverseproc)eSocketNotifierPy_traverse,
-	.tp_clear = (inquiry)eSocketNotifierPy_clear,
-	.tp_weaklistoffset = offsetof(eSocketNotifierPy, in_weakreflist),
-	.tp_methods = eSocketNotifierPy_methods,
-	.tp_getset = eSocketNotifierPy_getseters,
-	.tp_new = eSocketNotifierPy_new,
+	0, /*tp_itemsize*/
+	(destructor)eSocketNotifierPy_dealloc, /*tp_dealloc*/
+	0, /*tp_print*/
+	0, /*tp_getattr*/
+	0, /*tp_setattr*/
+	0, /*tp_compare*/
+	0, /*tp_repr*/
+	0, /*tp_as_number*/
+	0, /*tp_as_sequence*/
+	0, /*tp_as_mapping*/
+	0, /*tp_hash */
+	0, /*tp_call*/
+	0, /*tp_str*/
+	0, /*tp_getattro*/
+	0, /*tp_setattro*/
+	0, /*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+	"eTimer objects", /* tp_doc */
+	(traverseproc)eSocketNotifierPy_traverse, /* tp_traverse */
+	(inquiry)eSocketNotifierPy_clear, /* tp_clear */
+	0, /* tp_richcompare */
+	offsetof(eSocketNotifierPy, in_weakreflist), /* tp_weaklistoffset */
+	0, /* tp_iter */
+	0, /* tp_iternext */
+	eSocketNotifierPy_methods, /* tp_methods */
+	0, /* tp_members */
+	eSocketNotifierPy_getseters, /* tp_getset */
+	0, /* tp_base */
+	0, /* tp_dict */
+	0, /* tp_descr_get */
+	0, /* tp_descr_set */
+	0, /* tp_dictoffset */
+	0, /* tp_init */
+	0, /* tp_alloc */
+	eSocketNotifierPy_new, /* tp_new */
 };
 
 static PyMethodDef base_module_methods[] = {
-	{}  /* Sentinel */
+	{NULL}  /* Sentinel */
 };
 
 void eBaseInit(void)
--- enigma2.org/lib/python/python_console.i
+++ enigma2/lib/python/python_console.i
@@ -62,7 +62,7 @@
 	 (getter)eConsolePy_appClosed, (setter)0,
 	 (char*)"appClosed callback list",
 	 NULL},
-	{} /* Sentinel */
+	{NULL} /* Sentinel */
 };
 
 static int
@@ -331,26 +331,52 @@
 	{(char*)"running", (PyCFunction)eConsolePy_running, METH_NOARGS,
 	 (char*)"returns the running state"
 	},
-	{}  /* Sentinel */
+	{NULL}  /* Sentinel */
 };
 
 static PyTypeObject eConsolePyType = {
 	PyVarObject_HEAD_INIT(NULL, 0)
-	"eConsoleImpl.eConsoleAppContainer", /*tp_name*/
-	sizeof(eConsolePy), /*tp_basicsize*/
-	.tp_dealloc = (destructor)eConsolePy_dealloc,
-	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
-	.tp_doc = "eConsoleAppContainer objects",
-	.tp_traverse = (traverseproc)eConsolePy_traverse,
-	.tp_clear = (inquiry)eConsolePy_clear,
-	.tp_weaklistoffset = offsetof(eConsolePy, in_weakreflist),
-	.tp_methods = eConsolePy_methods,
-	.tp_getset = eConsolePy_getseters,
-	.tp_new = eConsolePy_new,
+	"eConsoleImpl.eConsoleAppContainer",     /*tp_name*/
+	sizeof(eConsolePy),                      /*tp_basicsize*/
+	0,                                       /*tp_itemsize*/
+	(destructor)eConsolePy_dealloc,          /*tp_dealloc*/
+	0,                                       /*tp_print*/
+	0,                                       /*tp_getattr*/
+	0,                                       /*tp_setattr*/
+	0,                                       /*tp_compare*/
+	0,                                       /*tp_repr*/
+	0,                                       /*tp_as_number*/
+	0,                                       /*tp_as_sequence*/
+	0,                                       /*tp_as_mapping*/
+	0,                                       /*tp_hash */
+	0,                                       /*tp_call*/
+	0,                                       /*tp_str*/
+	0,                                       /*tp_getattro*/
+	0,                                       /*tp_setattro*/
+	0,                                       /*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+	"eConsoleAppContainer objects",          /* tp_doc */
+	(traverseproc)eConsolePy_traverse,       /* tp_traverse */
+	(inquiry)eConsolePy_clear,               /* tp_clear */
+	0,                                       /* tp_richcompare */
+	offsetof(eConsolePy, in_weakreflist),    /* tp_weaklistoffset */
+	0,                                       /* tp_iter */
+	0,                                       /* tp_iternext */
+	eConsolePy_methods,                      /* tp_methods */
+	0,                                       /* tp_members */
+	eConsolePy_getseters,                    /* tp_getset */
+	0,                                       /* tp_base */
+	0,                                       /* tp_dict */
+	0,                                       /* tp_descr_get */
+	0,                                       /* tp_descr_set */
+	0,                                       /* tp_dictoffset */
+	0,                                       /* tp_init */
+	0,                                       /* tp_alloc */
+	eConsolePy_new,                          /* tp_new */
 };
 
 static PyMethodDef console_module_methods[] = {
-	{}  /* Sentinel */
+	{NULL}  /* Sentinel */
 };
 
 void eConsoleInit(void)
--- enigma2.org/lib/python/Components/About.py
+++ enigma2/lib/python/Components/About.py
@@ -58,13 +58,15 @@
 
 
 def getGStreamerVersionString():
-	try:
-		from glob import glob
-		gst = [x.split("Version: ") for x in open(glob("/var/lib/opkg/info/gstreamer[0-9].[0-9].control")[0], "r") if x.startswith("Version:")][0]
-		return "%s" % gst[1].split("+")[0].replace("\n", "")
-	except:
-		return ""
-
+	from glob import glob
+	if os.path.isfile('/usr/lib/pkgconfig/gstreamer-1.0.pc'):
+		gstversion = [x.split("Version:") for x in open(glob("/usr/lib/pkgconfig/gstreamer-1.0.pc")[0], "r") if x.startswith("Version:")][0]
+		if os.path.isfile('/usr/lib/libeplayer3.so'):
+			return "Gstreamer " + ("%s" % gstversion[1].replace("\n","")) + " + eplayer3"
+		else:
+			return "Gstreamer " + ("%s" % gstversion[1].replace("\n",""))
+	else:
+		return _("eplayer3")
 
 def getffmpegVersionString():
 	try:
@@ -83,7 +85,7 @@
 
 
 def getHardwareTypeString():
-	return HardwareInfo().get_device_string()
+	return HardwareInfo().get_device_string().upper()
 
 
 def getImageTypeString():
@@ -97,29 +99,19 @@
 def getCPUInfoString():
 	try:
 		cpu_count = 0
-		cpu_speed = 0
+		cpu_speed = "unknown"
 		processor = ""
 		for line in open("/proc/cpuinfo").readlines():
 			line = [x.strip() for x in line.strip().split(":")]
-			if not processor and line[0] in ("system type", "model name", "Processor"):
+			if not processor and line[0] == "cpu type":
 				processor = line[1].split()[0]
-			elif not cpu_speed and line[0] == "cpu MHz":
+			elif cpu_speed == "unknown" and line[0] == "cpu MHz":
 				cpu_speed = "%1.0f" % float(line[1])
 			elif line[0] == "processor":
 				cpu_count += 1
 
 		if processor.startswith("ARM") and os.path.isfile("/proc/stb/info/chipset"):
 			processor = "%s (%s)" % (open("/proc/stb/info/chipset").readline().strip().upper(), processor)
-
-		if not cpu_speed:
-			try:
-				cpu_speed = int(open("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq").read()) / 1000
-			except:
-				try:
-					import binascii
-					cpu_speed = int(int(binascii.hexlify(open('/sys/firmware/devicetree/base/cpus/cpu@0/clock-frequency', 'rb').read()), 16) / 100000000) * 100
-				except:
-					cpu_speed = "-"
 
 		temperature = None
 		freq = _("MHz")
#--- enigma2.org/lib/python/Components/FanControl.py
#+++ enigma2/lib/python/Components/FanControl.py
#@@ -6,6 +6,14 @@
# import NavigationInstance
# from enigma import iRecordableService
# 
#+
#+def fanSpeedChanged(configElement=None):
#+	from Screens.Standby import inStandby
#+	print "[FanControl]: fanSpeedChanged"
#+	if inStandby is False:
#+		self.setVoltage_PWM()
#+	else:
#+		self.setVoltage_PWM_Standby()
# 
# class FanControl:
# 	# ATM there's only support for one fan
#@@ -54,22 +62,38 @@
# 		if not recordings:
# 			self.setVoltage_PWM_Standby()
# 
#+#	def fanSpeedChanged(configElement=None):
#+#		from Screens.Standby import inStandby
#+#		print "[FanControl]: fanSpeedChanged"
#+#		if inStandby is False:
#+#			self.setVoltage_PWM()
#+#		else:
#+#			self.setVoltage_PWM_Standby()
#+
# 	def createConfig(self):
#-		def setVlt(fancontrol, fanid, configElement):
#-			fancontrol.setVoltage(fanid, configElement.value)
#+		if os.path.exists("/proc/stb/fp/fan_vlt"):
#+			def setVlt(fancontrol, fanid, configElement):
#+				fancontrol.setVoltage(fanid, configElement.value)
# 
#-		def setPWM(fancontrol, fanid, configElement):
#-			fancontrol.setPWM(fanid, configElement.value)
#+		if os.path.exists("/proc/stb/fp/fan_pwm"):
#+			def setPWM(fancontrol, fanid, configElement):
#+				fancontrol.setPWM(fanid, configElement.value)
# 
# 		config.fans = ConfigSubList()
# 		for fanid in range(self.getFanCount()):
# 			fan = ConfigSubsection()
#-			fan.vlt = ConfigSlider(default=15, increment=5, limits=(0, 255))
#-			fan.pwm = ConfigSlider(default=0, increment=5, limits=(0, 255))
#-			fan.vlt_standby = ConfigSlider(default=5, increment=5, limits=(0, 255))
#-			fan.pwm_standby = ConfigSlider(default=0, increment=5, limits=(0, 255))
#-			fan.vlt.addNotifier(boundFunction(setVlt, self, fanid))
#-			fan.pwm.addNotifier(boundFunction(setPWM, self, fanid))
#+			if os.path.exists("/proc/stb/fp/fan_vlt"):
#+				fan.vlt = ConfigSlider(default=127, increment=8, limits=(0, 255))
#+			if os.path.exists("/proc/stb/fp/fan_pwm"):
#+				fan.pwm = ConfigSlider(default=127, increment=8, limits=(0, 255))
#+			if os.path.exists("/proc/stb/fp/fan_vlt"):
#+				fan.vlt_standby = ConfigSlider(default=63, increment=8, limits=(0, 255))
#+			if os.path.exists("/proc/stb/fp/fan_pwm"):
#+				fan.pwm_standby = ConfigSlider(default=63, increment=8, limits=(0, 255))
#+			if os.path.exists("/proc/stb/fp/fan_vlt"):
#+				fan.vlt.addNotifier(boundFunction(setVlt, self, fanid))
#+			if os.path.exists("/proc/stb/fp/fan_pwm"):
#+				fan.pwm.addNotifier(boundFunction(setPWM, self, fanid))
# 			config.fans.append(fan)
# 
# 	def getConfig(self, fanid):
#@@ -79,29 +103,43 @@
# 		return self.fancount
# 
# 	def hasRPMSensor(self, fanid):
#-		return os.path.exists("/proc/stb/fp/fan_speed")
#+		if os.path.exists("/proc/stb/fp/fan_speed"):
#+			return 1
#+		return 0
# 
# 	def hasFanControl(self, fanid):
#-		return os.path.exists("/proc/stb/fp/fan_vlt") or os.path.exists("/proc/stb/fp/fan_pwm")
#+		if os.path.exists("/proc/stb/fp/fan_vlt"):
#+			return 1
#+		if os.path.exists("/proc/stb/fp/fan_pwm"):
#+			return 1
#+		return 0
# 
# 	def getFanSpeed(self, fanid):
#-		return int(open("/proc/stb/fp/fan_speed", "r").readline().strip()[:-4])
#+		if os.path.exists("/proc/stb/fp/fan_speed"):
#+			return int(open("/proc/stb/fp/fan_speed", "r").readline().strip()[:-4])
#+		return 0
# 
# 	def getVoltage(self, fanid):
#-		return int(open("/proc/stb/fp/fan_vlt", "r").readline().strip(), 16)
#+		if os.path.exists("/proc/stb/fp/fan_vlt"):
#+			return int(open("/proc/stb/fp/fan_vlt", "r").readline().strip(), 16)
#+		return 0;
# 
# 	def setVoltage(self, fanid, value):
# 		if value > 255:
# 			return
#-		open("/proc/stb/fp/fan_vlt", "w").write("%x" % value)
#+		if os.path.exists("/proc/stb/fp/fan_vlt"):
#+			open("/proc/stb/fp/fan_vlt", "w").write("%x" % value)
# 
# 	def getPWM(self, fanid):
#-		return int(open("/proc/stb/fp/fan_pwm", "r").readline().strip(), 16)
#+		if os.path.exists("/proc/stb/fp/fan_pwm"):
#+			return int(open("/proc/stb/fp/fan_pwm", "r").readline().strip(), 16)
#+		return 0
# 
# 	def setPWM(self, fanid, value):
# 		if value > 255:
# 			return
#-		open("/proc/stb/fp/fan_pwm", "w").write("%x" % value)
#+		if os.path.exists("/proc/stb/fp/fan_pwm"):
#+			open("/proc/stb/fp/fan_pwm", "w").write("%x" % value)
# 
# 
# fancontrol = FanControl()
--- enigma2.org/lib/python/Components/Converter/RemainingToText.py
+++ enigma2/lib/python/Components/Converter/RemainingToText.py
@@ -10,6 +10,9 @@
 	PROGRESS = 4
 	WITH_SECONDSPROGRESS = 5
 	ONLY_MINUTES = 6
+#+++>
+	FOLLOW = 7
+#+++<
 
 	def __init__(self, type):
 		Converter.__init__(self, type)
@@ -25,6 +28,10 @@
 			self.type = self.WITH_SECONDSPROGRESS
 		elif type == "OnlyMinutes":
 			self.type = self.ONLY_MINUTES
+#+++>
+		elif type == "FOLLOW":
+			self.type = self.FOLLOW
+#+++<
 		else:
 			self.type = self.DEFAULT
 
@@ -57,6 +64,13 @@
 					return "%s%d:%02d" % (prefix, hours, minutes)
 				elif self.type == self.IN_SECONDS:
 					return prefix + str(tsecs)
+#+++>
+				elif self.type == self.FOLLOW:
+					if remaining is not None:
+						return "in %d min" % (remaining / 60)
+					else:
+						return "%d min" % (duration / 60)
+#+++<
 				elif self.type == self.DEFAULT or self.type == self.ONLY_MINUTES:
 					if remaining <= duration:
 						prefix = "+"
--- enigma2.org/lib/python/Components/Harddisk.py
+++ enigma2/lib/python/Components/Harddisk.py
@@ -51,6 +51,7 @@
 class Harddisk:
 	def __init__(self, device, removable=False):
 		self.device = device
+		self.card = False
 
 		if os.access("/dev/.udev", 0):
 			self.type = DEVTYPE_UDEV
@@ -61,7 +62,6 @@
 		else:
 			print "[Harddisk] Unable to determine structure of /dev"
 			self.type = -1
-			self.card = False
 
 		self.max_idle_time = 0
 		self.idle_running = False
@@ -90,25 +90,30 @@
 			self.card = "sdhci" in self.phys_path or "mmc" in self.device
 
 		elif self.type == DEVTYPE_DEVFS:
-			tmp = readFile(self.sysfsPath('dev')).split(':')
-			s_major = int(tmp[0])
-			s_minor = int(tmp[1])
-			for disc in os.listdir("/dev/discs"):
-				dev_path = os.path.realpath('/dev/discs/' + disc)
-				disk_path = dev_path + '/disc'
-				try:
-					rdev = os.stat(disk_path).st_rdev
-				except OSError:
-					continue
-				if s_major == os.major(rdev) and s_minor == os.minor(rdev):
-					self.dev_path = dev_path
-					self.disk_path = disk_path
-					break
-			self.card = self.device[:2] == "hd" and "host0" not in self.dev_path
+#			tmp = readFile(self.sysfsPath('dev')).split(':')
+#			s_major = int(tmp[0])
+#			s_minor = int(tmp[1])
+#			for disc in os.listdir("/dev/discs"):
+#				dev_path = os.path.realpath('/dev/discs/' + disc)
+#				disk_path = dev_path + '/disc'
+#				try:
+#					rdev = os.stat(disk_path).st_rdev
+#				except OSError:
+#					continue
+#				if s_major == os.major(rdev) and s_minor == os.minor(rdev):
+#					self.dev_path = dev_path
+#					self.disk_path = disk_path
+#					break
+#			self.card = self.device[:2] == "hd" and "host0" not in self.dev_path
+			self.dev_path = '/dev/' + self.device
+			self.disk_path = self.dev_path
+		else:
+			print "[Harddisk] self.type =", self.type
 
 		print "[Harddisk] new device=%s dev_path=%s disk_path=%s removable=%s internal=%s rotational=%s card=%s" % (self.device, self.dev_path, self.disk_path, removable, self.internal, self.rotational, self.card)
 		if (self.internal or not removable) and not self.card:
 			self.startIdle()
+		Console().ePopen(("mount", "mount", "-a"))
 
 	def __lt__(self, ob):
 		return self.device < ob.device
@@ -252,7 +257,9 @@
 
 	def createPartition(self):
 		cmd = 'printf "8,\n;0,0\n;0,0\n;0,0\ny\n" | sfdisk -f -uS ' + self.disk_path
+		print "[Harddisk] Creating partition with ", cmd
 		res = os.system(cmd)
+		print "[Harddisk] Creating partition completed with result ", res
 		return (res >> 8)
 
 	def mkfs(self):
@@ -295,6 +302,7 @@
 		return 1
 
 	def killPartitionTable(self):
+		print "[Harddisk] Delete partition table on ", self.dev_path
 		zero = 512 * '\0'
 		h = open(self.dev_path, 'wb')
 		# delete first 9 sectors, which will likely kill the first partition too
@@ -314,25 +322,30 @@
 		os.mkdir(os.path.join(self.mount_path, 'movie'))
 
 	def createInitializeJob(self):
-		job = Task.Job(_("Initializing storage device..."))
+		job = Task.Job(_("Initialize hard disk"))
 		size = self.diskSize()
-		print "[HD] size: %s MB" % size
-
-		task = UnmountTask(job, self)
-
-		task = Task.PythonTask(job, _("Removing partition table"))
-		task.work = self.killPartitionTable
-		task.weighting = 1
-
-		task = Task.LoggingTask(job, _("Rereading partition table"))
-		task.weighting = 1
-		task.setTool('hdparm')
-		task.args.append('-z')
-		task.args.append(self.disk_path)
-
-		task = Task.ConditionTask(job, _("Waiting for partition"), timeoutCount=20)
-		task.check = lambda: not os.path.exists(self.partitionPath("1"))
-		task.weighting = 1
+		sectors = ((size * 1000 / 512) * 1000)
+		print "[Harddisk] Create initialize job, consisting of:"
+		print "[Harddisk init] Initializing device /dev/%s, size is: %s MB" % (self.device, size)
+#		print "                (Equals %s sectors)" % sectors
+
+		if self.disk_path:
+			print "[Harddisk init] Unmount", self.disk_path
+			task = UnmountTask(job, self)
+
+			print "[Harddisk init] Deleting partition table on ", self.disk_path
+			task = Task.PythonTask(job, _("Removing partition table"))
+			task.work = self.killPartitionTable
+			task.weighting = 1
+
+			print "[Harddisk init] Rereading partition table on", self.disk_path
+			task = Task.LoggingTask(job, _("Rereading partition table"))
+			task.weighting = 1
+			task.setTool('hdparm')
+			task.args.append('-z')
+			task.args.append(self.disk_path)
+
+			print "[Harddisk init] Wait for finish of deleting partition table on ", self.disk_path
 
 		if os.path.exists('/usr/sbin/parted'):
 			use_parted = True
@@ -343,7 +356,9 @@
 			else:
 				use_parted = False
 
-		task = Task.LoggingTask(job, _("Creating partition"))
+# create the RECORD partition. On disks larger than 20 GB,
+# create a second partition SWAPPART of 1 GB
+		task = Task.LoggingTask(job, _("Creating partition(s)"))
 		task.weighting = 5
 		if use_parted:
 			task.setTool('parted')
@@ -355,9 +370,17 @@
 				alignment = 'opt'
 			if size > 2097151:
 				parttype = 'gpt'
+				task.args = [self.disk_path, '-s', '-a', alignment, 'mktable', parttype, 'mkpart', 'primary', '0%', endsize, 'mkpart', 'primary', endsize, '100%']
+				print "[Harddisk init] Creating 2 partitions RECORD and SWAPPART with command ", task.args
 			else:
 				parttype = 'msdos'
-			task.args += ['-a', alignment, '-s', self.disk_path, 'mklabel', parttype, 'mkpart', 'primary', '0%', '100%']
+				if size > 20000: # create a second SWAPPART partition
+					endsize = str(size - 1024) + "MB"
+					task.args += [self.disk_path, '-s', '-a', alignment, 'mktable', parttype, 'mkpart', 'primary', 'ext3', '0%', endsize, 'mkpart', 'primary', endsize, str(size) + 'MB']
+					print "[Harddisk init] Creating 2 partitions RECORD and SWAPPART with command ", task.args
+				else:
+					task.args += [self.disk_path, '--s', '-a', alignment, 'mktable', parttype, 'mkpart', 'primary', 'ext3', '0%', '100%']
+					print "[Harddisk init] Creating RECORD partition with command ", task.args
 		else:
 			task.setTool('sfdisk')
 			task.args.append('-f')
@@ -365,52 +388,91 @@
 			task.args.append(self.disk_path)
 			if size > 128000:
 				# Start at sector 8 to better support 4k aligned disks
-				print "[HD] Detected >128GB disk, using 4k alignment"
-				task.initial_input = "8,,L\n;0,0\n;0,0\n;0,0\ny\n"
+				print "[Harddisk init] Note: Detected disk is >128GB, using 4k alignment"
+				start_sect = 8
 			else:
 				# Smaller disks (CF cards, sticks etc) don't need that
-				task.initial_input = ",,L\n;\n;\n;\ny\n"
-
-		task = Task.ConditionTask(job, _("Waiting for partition"))
-		task.check = lambda: os.path.exists(self.partitionPath("1"))
+				start_sect = 0
+			if size > 20000: # create a second SWAPPART partition
+				# 1GB is 1073741824 / 512 = 2097152 sectors (multiple of 4k)
+				#TODO: check for cylinder boundaries
+				end_sect1 = ((size * 1000 / 512) * 1000) - 2097152
+				start_sect2 = end_sect1 + 8 # stay on 4k boundary
+				task.initial_input = str(start_sect)+ "," + str(end_sect1) + "\n" + str(start_sect2) + "\n0,0\n0,0\ny\n"
+				print "[Harddisk init] Creating 2 partition RECORD and SWAPPART with command ", task.args
+			else:
+				task.initial_input = "0\n\n\n\ny\n"
+				print "[Harddisk init] Creating RECORD partition with command ", task.args
+			print "[Harddisk init] using input ", task.initial_input
+
+# execute a dummy fdisk -l to force read the harddisk's new content
+		task = Task.LoggingTask(job, _("Dummy command fdisk -l"))
 		task.weighting = 1
 
 		if self.type == DEVTYPE_UDEV:
 			task = UnmountTask(job, self)
-		task = MkfsTask(job, _("Creating filesystem"))
-		big_o_options = ["dir_index"]
-		if isFileSystemSupported("ext4"):
-			task.setTool("mkfs.ext4")
-			if size > 20000:
-				try:
-					version = map(int, open("/proc/version", "r").read().split(' ', 4)[2].split('.', 2)[:2])
-					if (version[0] > 3) or (version[0] > 2 and version[1] >= 2):
-						# Linux version 3.2 supports bigalloc and -C option, use 256k blocks
-						task.args += ["-C", "262144"]
-						big_o_options.append("bigalloc")
-				except Exception, ex:
-					print "Failed to detect Linux version:", ex
+		task.setTool('fdisk')
+		task.args.append('-l')
+		print "[Harddisk init] Dummy command fdisk -l"
+
+# used to hang here
+# fix1: added timeout so the job always finishes instead of never ending
+# fix2: dummy fdisk -l (previous step)
+		task = Task.ConditionTask(job, _("Waiting for creation of RECORD partition"), timeoutCount=5)
+		print "[Harddisk init] self.partitionPath(1) =", self.partitionPath("1")
+		task.check = lambda: not os.path.exists(self.partitionPath("1"))
+		task.weighting = 1
+		print "[Harddisk init] Wait for ", self.partitionPath("1"), " to exist"
+
+		task = MkfsTask(job, _("Creating filesystem on RECORD partition"))
+		if not use_parted:
+			if isFileSystemSupported("ext4"):
+				task.setTool("mkfs.ext4")
 		else:
 			task.setTool("mkfs.ext3")
-		if size > 250000:
+		if size > 250000:  # 250GB
 			# No more than 256k i-nodes (prevent problems with fsck memory requirements)
-			task.args += ["-T", "largefile", "-N", "262144"]
-			big_o_options.append("sparse_super")
+			task.args += ["-T", "largefile", "-O", "sparse_super", "-N", "262144"]
 		elif size > 16384:
 			# between 16GB and 250GB: 1 i-node per megabyte
-			task.args += ["-T", "largefile"]
-			big_o_options.append("sparse_super")
+			task.args += ["-T", "largefile", "-O", "sparse_super"]
 		elif size > 2048:
 			# Over 2GB: 32 i-nodes per megabyte
 			task.args += ["-T", "largefile", "-N", str(size * 32)]
-		task.args += ["-m0", "-O", ",".join(big_o_options), self.partitionPath("1")]
-
-		task = MountTask(job, self)
+		task.args += ["-L", "RECORD", "-m0", "-O", "dir_index", self.disk_path+"1"]
+		print "[Harddisk init] Make fs on RECORD partition using ", task.args
+
+		if size > 20000:
+			task = MkfsTask(job, _("Creating filesystem on SWAPPART partition"))
+			task.setTool("mkswap")
+			task.args += ["-L", "SWAPPART", self.disk_path + "2"]
+			print "[Harddisk init] Make swapfs on partition 2 using ", task.args
+
+			task = MkfsTask(job, _("Switch swap on"))
+			task.setTool("swapon")
+			task.args += [self.disk_path + "2"]
+			print "[Harddisk init] Switching swap on using ", task.args
+
+# in the previous process /media/hdd is destroyed, so recreate it
+		task = Task.LoggingTask(job, _("Re-create /media/hdd"))
+		task.weighting = 1
+		task.setTool('mkdir')
+		task.args.append('-p')
+		task.args.append('/media/hdd')
+		print "[Harddisk init] Re-create /media/hdd directory"
+
+		task = Task.LoggingTask(job, _("Re-mount %s") % (self.disk_path + "1"))
 		task.weighting = 3
+		task.setTool('mount')
+		task.args.append(self.disk_path + "1")
+		task.args.append('/hdd')
+		print "[Harddisk init] Re-mounting %s" % (self.disk_path + "1")
 
 		task = Task.ConditionTask(job, _("Waiting for mount"), timeoutCount=20)
 		task.check = self.mountDevice
 		task.weighting = 1
+
+		print "[Harddisk init] Waiting for mount to succeed"
 
 		task = Task.PythonTask(job, _("Create directory") + ": movie")
 		task.work = self.createMovieDir
@@ -681,16 +743,19 @@
 				self.devices_scanned_on_init.append((blockdev, removable, is_cdrom, medium_found))
 
 	def getAutofsMountpoint(self, device):
-		r = self.getMountpoint(device)
-		if r is None:
-			return "/media/" + device
-		return r
+		return "/autofs/%s" % (device)
 
 	def getMountpoint(self, device):
 		dev = "/dev/%s" % device
 		for item in getProcMounts():
 			if item[0] == dev:
 				return item[1]
+#+++>
+		#Check if has autofs mountpoint
+		mount = self.getAutofsMountpoint(device)
+		if mount:
+			return mount
+#+++<
 		return None
 
 	def addHotplugPartition(self, device, physdev=None):
@@ -706,6 +771,10 @@
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		if not blacklisted and medium_found:
 			description = self.getUserfriendlyDeviceName(device, physdev)
+#+++>
+			if description.startswith("External Storage"):
+				return False, False, False, False, [], False
+#+++<
 			p = Partition(mountpoint=self.getMountpoint(device), description=description, force_mounted=True, device=device)
 			self.partitions.append(p)
 			if p.mountpoint: # Plugins won't expect unmounted devices
@@ -727,7 +796,7 @@
 				physdev = os.path.realpath('/sys/block/' + dev + '/device')[4:]
 			except OSError:
 				physdev = dev
-				print "couldn't determine blockdev physdev for device", device
+				print "Could not determine blockdev physdev for device", device
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		if not blacklisted and medium_found:
 			description = self.getUserfriendlyDeviceName(device, physdev)
@@ -798,7 +867,7 @@
 		try:
 			description = readFile("/sys" + phys + "/model")
 		except IOError, s:
-			print "couldn't read model: ", s
+			print "Could not read model: ", s
 		# not wholedisk and not partition 1
 		if part and part != 1:
 			description += _(" (Partition %d)") % part
@@ -841,7 +910,7 @@
 			dev = self.hdd.disk_path.split('/')[-1]
 			open('/dev/nomount.%s' % dev, "wb").close()
 		except Exception, e:
-			print "ERROR: Failed to create /dev/nomount file:", e
+			print "[Harddisk] ERROR: Failed to create /dev/nomount file:", e
 		self.setTool('umount')
 		self.args.append('-f')
 		for dev in self.hdd.enumMountDevices():
@@ -849,7 +918,7 @@
 			self.postconditions.append(Task.ReturncodePostcondition())
 			self.mountpoints.append(dev)
 		if not self.mountpoints:
-			print "UnmountTask: No mountpoints found?"
+			print "[Harddisk] UnmountTask: No mountpoints found?"
 			self.cmd = 'true'
 			self.args = [self.cmd]
 
@@ -858,7 +927,7 @@
 			try:
 				os.rmdir(path)
 			except Exception, ex:
-				print "Failed to remove path '%s':" % path, ex
+				print "[Harddisk] Failed to remove path '%s':" % path, ex
 
 
 class MountTask(Task.LoggingTask):
@@ -871,7 +940,7 @@
 			dev = self.hdd.disk_path.split('/')[-1]
 			os.unlink('/dev/nomount.%s' % dev)
 		except Exception, e:
-			print "ERROR: Failed to remove /dev/nomount file:", e
+			print "[Harddisk] ERROR: Failed to remove /dev/nomount file:", e
 		# try mounting through fstab first
 		if self.hdd.mount_device is None:
 			dev = self.hdd.partitionPath("1")
@@ -901,7 +970,7 @@
 		self.fsck_state = None
 
 	def processOutput(self, data):
-		print "[Mkfs]", data
+		print "[Harddisk] Mkfs", data
 		if 'Writing inode tables:' in data:
 			self.fsck_state = 'inode'
 		elif 'Creating journal' in data:
--- enigma2.org/lib/python/Components/Network.py
+++ enigma2/lib/python/Components/Network.py
@@ -537,16 +537,18 @@
 			return True
 
 		# r871x_usb_drv on kernel 2.6.12 is not identifiable over /sys/class/net/'ifacename'/wireless so look also inside /proc/net/wireless
-		device = re.compile('[a-z]{2,}[0-9]*:')
-		ifnames = []
-		fp = open('/proc/net/wireless', 'r')
-		for line in fp:
-			try:
-				ifnames.append(device.search(line).group()[:-1])
-			except AttributeError:
-				pass
-		if iface in ifnames:
-			return True
+		if os.path.exists('/proc/net/wireless'):
+			device = re.compile('[a-z]{2,}[0-9]*:')
+			ifnames = []
+			fp = open('/proc/net/wireless', 'r')
+			for line in fp:
+				try:
+					ifnames.append(device.search(line).group()[:-1])
+				except AttributeError:
+					pass
+			fp.close()
+			if iface in ifnames:
+				return True
 
 		return False
 
--- enigma2.org/lib/python/Components/NimManager.py
+++ enigma2/lib/python/Components/NimManager.py
@@ -17,6 +17,10 @@
 
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
--- enigma2-nightly.org/lib/python/Components/SystemInfo.py
+++ enigma2-nightly/lib/python/Components/SystemInfo.py
@@ -55,13 +55,13 @@
 SystemInfo["12V_Output"] = Misc_Options.getInstance().detected_12V_output()
 SystemInfo["ZapMode"] = fileCheck("/proc/stb/video/zapmode") or fileCheck("/proc/stb/video/zapping_mode")
 SystemInfo["NumFrontpanelLEDs"] = countFrontpanelLEDs()
-SystemInfo["FrontpanelDisplay"] = fileExists("/dev/dbox/oled0") or fileExists("/dev/dbox/lcd0")
-SystemInfo["LCDsymbol_circle_recording"] = fileCheck("/proc/stb/lcd/symbol_circle") or model in ("hd51", "vs1500") and fileCheck("/proc/stb/lcd/symbol_recording")
+SystemInfo["FrontpanelDisplay"] = fileCheck("/proc/stb/lcd/scroll_repeats") or fileCheck("/proc/stb/lcd/scroll_delay") or fileCheck("/proc/stb/lcd/initial_scroll_delay") or fileCheck("/proc/stb/lcd/final_scroll_delay")
+SystemInfo["LCDsymbol_circle_recording"] = fileCheck("/proc/stb/lcd/symbol_circle")
 SystemInfo["LCDsymbol_timeshift"] = fileCheck("/proc/stb/lcd/symbol_timeshift")
 SystemInfo["LCDshow_symbols"] = (model.startswith("et9") or model in ("hd51", "vs1500")) and fileCheck("/proc/stb/lcd/show_symbols")
-SystemInfo["LCDsymbol_hdd"] = model in ("hd51", "vs1500") and fileCheck("/proc/stb/lcd/symbol_hdd")
+SystemInfo["LCDsymbol_hdd"] = fileCheck("/proc/stb/lcd/symbol_hdd")
 SystemInfo["FrontpanelDisplayGrayscale"] = fileExists("/dev/dbox/oled0")
-SystemInfo["DeepstandbySupport"] = HardwareInfo().get_device_name() != "dm800"
+SystemInfo["DeepstandbySupport"] = HardwareInfo().get_device_model() not in ("adb_box", "hl101", "vip1_v1")
 SystemInfo["Fan"] = fileCheck("/proc/stb/fp/fan")
 SystemInfo["FanPWM"] = SystemInfo["Fan"] and fileCheck("/proc/stb/fp/fan_pwm")
 SystemInfo["PowerLED"] = fileCheck("/proc/stb/power/powerled") or model in ("gbue4k", "gbquad4k") and fileCheck("/proc/stb/fp/led1_pattern")
@@ -74,16 +74,16 @@
 SystemInfo["Power4x7On"] = fileCheck("/proc/stb/fp/power4x7on")
 SystemInfo["Power4x7Standby"] = fileCheck("/proc/stb/fp/power4x7standby")
 SystemInfo["Power4x7Suspend"] = fileCheck("/proc/stb/fp/power4x7suspend")
-SystemInfo["PowerOffDisplay"] = model not in "formuler1" and fileCheck("/proc/stb/power/vfd") or fileCheck("/proc/stb/lcd/vfd")
+SystemInfo["PowerOffDisplay"] = fileCheck("/proc/stb/power/vfd") or fileCheck("/proc/stb/lcd/vfd")
 SystemInfo["WakeOnLAN"] = not model.startswith("et8000") and fileCheck("/proc/stb/power/wol") or fileCheck("/proc/stb/fp/wol")
 SystemInfo["HasExternalPIP"] = not (model.startswith("et9") or model in ("e4hd",)) and fileCheck("/proc/stb/vmpeg/1/external")
 SystemInfo["VideoDestinationConfigurable"] = fileExists("/proc/stb/vmpeg/0/dst_left")
 SystemInfo["hasPIPVisibleProc"] = fileCheck("/proc/stb/vmpeg/1/visible")
-SystemInfo["MaxPIPSize"] = model in ("hd51", "h7", "vs1500", "e4hd") and (360, 288) or (540, 432)
-SystemInfo["VFD_scroll_repeats"] = not model.startswith("et8500") and fileCheck("/proc/stb/lcd/scroll_repeats")
-SystemInfo["VFD_scroll_delay"] = not model.startswith("et8500") and fileCheck("/proc/stb/lcd/scroll_delay")
-SystemInfo["VFD_initial_scroll_delay"] = not model.startswith("et8500") and fileCheck("/proc/stb/lcd/initial_scroll_delay")
-SystemInfo["VFD_final_scroll_delay"] = not model.startswith("et8500") and fileCheck("/proc/stb/lcd/final_scroll_delay")
+SystemInfo["MaxPIPSize"] = (540, 432)
+SystemInfo["VFD_scroll_repeats"] = fileCheck("/proc/stb/lcd/scroll_repeats")
+SystemInfo["VFD_scroll_delay"] = fileCheck("/proc/stb/lcd/scroll_delay")
+SystemInfo["VFD_initial_scroll_delay"] = fileCheck("/proc/stb/lcd/initial_scroll_delay")
+SystemInfo["VFD_final_scroll_delay"] = fileCheck("/proc/stb/lcd/final_scroll_delay")
 SystemInfo["LcdLiveTV"] = fileCheck("/proc/stb/fb/sd_detach") or fileCheck("/proc/stb/lcd/live_enable")
 SystemInfo["LcdLiveTVMode"] = fileCheck("/proc/stb/lcd/mode")
 SystemInfo["LcdLiveDecoder"] = fileCheck("/proc/stb/lcd/live_decoder")
@@ -98,29 +98,29 @@
 SystemInfo["HasColorspace"] = fileCheck("/proc/stb/video/hdmi_colorspace")
 SystemInfo["HasColorspaceSimple"] = SystemInfo["HasColorspace"] and SystemInfo["HasMMC"] and SystemInfo["Blindscan_t2_available"]
 SystemInfo["HasTranscoding"] = pathExists("/proc/stb/encoder/0") or fileCheck("/dev/bcm_enc0")
-SystemInfo["HasH265Encoder"] = fileHas("/proc/stb/encoder/0/vcodec_choices", "h265")
+SystemInfo["HasH265Encoder"] = False
 SystemInfo["CanNotDoSimultaneousTranscodeAndPIP"] = model in ("vusolo4k", "gbquad4k", "gbue4k")
 SystemInfo["HasColordepth"] = fileCheck("/proc/stb/video/hdmi_colordepth")
-SystemInfo["HasFrontDisplayPicon"] = model in ("et8500", "vusolo4k", "vuuno4kse", "vuduo4k", "vuduo4kse", "vuultimo4k", "gbquad4k", "gbue4k")
+SystemInfo["HasFrontDisplayPicon"] = False
 SystemInfo["Has24hz"] = fileCheck("/proc/stb/video/videomode_24hz")
-SystemInfo["Has2160p"] = fileHas("/proc/stb/video/videomode_preferred", "2160p50")
+SystemInfo["Has2160p"] = False
 SystemInfo["HasHDMIpreemphasis"] = fileCheck("/proc/stb/hdmi/preemphasis")
 SystemInfo["HasColorimetry"] = fileCheck("/proc/stb/video/hdmi_colorimetry")
 SystemInfo["HasHdrType"] = fileCheck("/proc/stb/video/hdmi_hdrtype")
 SystemInfo["HasScaler_sharpness"] = pathExists("/proc/stb/vmpeg/0/pep_scaler_sharpness")
 SystemInfo["HasHDMIin"] = model in ("vuduo4k", "vuduo4kse", "vuultimo4k", "vuuno4kse", "gbquad4k", "hd2400", "et10000")
 SystemInfo["HasHDMI-CEC"] = HardwareInfo().has_hdmi() and fileExists(resolveFilename(SCOPE_PLUGINS, "SystemPlugins/HdmiCEC/plugin.pyo")) and (fileExists("/dev/cec0") or fileExists("/dev/hdmi_cec") or fileExists("/dev/misc/hdmi_cec0"))
-SystemInfo["HasYPbPr"] = model in ("dm8000", "et5000", "et6000", "et6500", "et9000", "et9200", "et9500", "et10000", "formuler1", "mbtwinplus", "spycat", "vusolo", "vuduo", "vuduo2", "vuultimo")
-SystemInfo["HasScart"] = model in ("dm8000", "et4000", "et6500", "et8000", "et9000", "et9200", "et9500", "et10000", "formuler1", "hd1100", "hd1200", "hd1265", "hd2400", "vusolo", "vusolo2", "vuduo", "vuduo2", "vuultimo", "vuuno", "xp1000")
-SystemInfo["HasSVideo"] = model in ("dm8000")
-SystemInfo["HasComposite"] = model not in ("i55", "gbquad4k", "gbue4k", "hd1500", "osnino", "osninoplus", "purehd", "purehdse", "revo4k", "vusolo4k", "vuzero4k", "vuduo4k", "vuduo4kse", "vuuno4k", "vuuno4kse", "vuultimo4k")
+SystemInfo["HasYPbPr"] = model in ("adb_box", "hs8200", "cuberevo", "cuberevo-mini-fta", "cuberevo-250hd", "cuberevo-mini", "cuberevo-mini2", "cuberevo-2000hd", "cuberevo-3000hd", "cuberevo-9500hd", "fs9000", "hs9510", "hs7420", "hs7429", "hchs8100", "hl101", "tf7700hdpvr", "ufs910", "ufs912", "ufs913", "ufs922", "vip1_v1", "vip1_v2", "vip2", "vitamin_hd5000", "opt9600", "opt9600prima")
+SystemInfo["HasScart"] = model not in ("hs7110", "hs7119", "opt9600mini", "atemio520")
+SystemInfo["HasSVideo"] = model in  ("cuberevo")
+SystemInfo["HasComposite"] = model not in ("cuberevo_mini_fta", "cuberevo_250hd")
 SystemInfo["hasXcoreVFD"] = model in ("osmega", "spycat4k", "spycat4kmini", "spycat4kcombo") and fileCheck("/sys/module/brcmstb_%s/parameters/pt6302_cgram" % model)
-SystemInfo["HasOfflineDecoding"] = model not in ("osmini", "osminiplus", "et7000mini", "et11000", "mbmicro", "mbtwinplus", "mbmicrov2", "et7000", "et8500")
+SystemInfo["HasOfflineDecoding"] = False
 SystemInfo["MultibootStartupDevice"] = getMultibootStartupDevice()
-SystemInfo["canMode12"] = "%s_4.boxmode" % model in cmdline and cmdline["%s_4.boxmode" % model] in ("1", "12") and "192M"
+SystemInfo["canMode12"] = False
 SystemInfo["canMultiBoot"] = getMultibootslots()
 SystemInfo["canDualBoot"] = fileExists("/dev/block/by-name/flag")
-SystemInfo["canFlashWithOfgwrite"] = not(model.startswith("dm"))
+SystemInfo["canFlashWithOfgwrite"] = False
 SystemInfo["HDRSupport"] = fileExists("/proc/stb/hdmi/hlg_support_choices") and fileCheck("/proc/stb/hdmi/hlg_support")
 SystemInfo["CanProc"] = SystemInfo["HasMMC"] and not SystemInfo["Blindscan_t2_available"]
 SystemInfo["HasMultichannelPCM"] = fileCheck("/proc/stb/audio/multichannel_pcm")
@@ -134,7 +134,7 @@
 SystemInfo["CanDownmixDTS"] = fileHas("/proc/stb/audio/dts_choices", "downmix")
 SystemInfo["CanDownmixAAC"] = fileHas("/proc/stb/audio/aac_choices", "downmix")
 SystemInfo["HDMIAudioSource"] = fileCheck("/proc/stb/hdmi/audio_source")
-SystemInfo["CanAC3Transcode"] = fileHas("/proc/stb/audio/ac3plus_choices", "force_ac3")
+SystemInfo["CanAC3Transcode"] = False
 SystemInfo["CanDTSHD"] = fileHas("/proc/stb/audio/dtshd_choices", "downmix")
 SystemInfo["CanDownmixAACPlus"] = fileHas("/proc/stb/audio/aacplus_choices", "downmix")
 SystemInfo["CanAACTranscode"] = fileHas("/proc/stb/audio/aac_transcode_choices", "off")
@@ -142,8 +142,8 @@
 SystemInfo["CanBTAudio"] = fileHas("/proc/stb/audio/btaudio_choices", "off")
 SystemInfo["CanBTAudioDelay"] = fileCheck("/proc/stb/audio/btaudio_delay") or fileCheck("/proc/stb/audio/btaudio_delay_pcm")
 SystemInfo["BootDevice"] = getBootdevice()
-SystemInfo["FbcTunerPowerAlwaysOn"] = model in ("vusolo4k", "vuduo4k", "vuduo4kse", "vuultimo4k", "vuuno4k", "vuuno4kse")
-SystemInfo["HasPhysicalLoopthrough"] = ["Vuplus DVB-S NIM(AVL2108)", "GIGA DVB-S2 NIM (Internal)"]
-SystemInfo["HasFBCtuner"] = ["Vuplus DVB-C NIM(BCM3158)", "Vuplus DVB-C NIM(BCM3148)", "Vuplus DVB-S NIM(7376 FBC)", "Vuplus DVB-S NIM(45308X FBC)", "Vuplus DVB-S NIM(45208 FBC)", "DVB-S2 NIM(45208 FBC)", "DVB-S2X NIM(45308X FBC)", "DVB-S2 NIM(45308 FBC)", "DVB-C NIM(3128 FBC)", "BCM45208", "BCM45308X", "BCM3158"]
+SystemInfo["FbcTunerPowerAlwaysOn"] = False
+SystemInfo["HasPhysicalLoopthrough"] = [""]
+SystemInfo["HasFBCtuner"] = [""]
 SystemInfo["HasHiSi"] = pathExists("/proc/hisi")
 SystemInfo["FCCactive"] = False
--- enigma2.org/lib/python/Components/Renderer/Makefile.am
+++ enigma2/lib/python/Components/Renderer/Makefile.am
@@ -3,4 +3,4 @@
 install_PYTHON = \
 	__init__.py Label.py Progress.py Listbox.py Renderer.py Pixmap.py \
 	FixedLabel.py PositionGauge.py Canvas.py CiModuleControl.py Picon.py Pig.py \
-	FrontpanelLed.py ChannelNumber.py VideoSize.py NextEpgInfo.py GaugeRender.py
+	FrontpanelLed.py ChannelNumber.py VideoSize.py NextEpgInfo.py GaugeRender.py SingleEpgList.py
--- enigma2.org/lib/python/Components/Renderer/Progress.py
+++ enigma2/lib/python/Components/Renderer/Progress.py
@@ -14,23 +14,38 @@
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
 
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def getRange(self):
 		return (self.__start, self.__end)
--- enigma2.org/lib/python/Components/Renderer/SingleEpgList.py
+++ enigma2/lib/python/Components/Renderer/SingleEpgList.py
@@ -0,0 +1,39 @@
+from Components.VariableText import VariableText
+from enigma import eLabel, eEPGCache
+from Renderer import Renderer
+from time import localtime
+
+class SingleEpgList(Renderer, VariableText):
+	def __init__(self):
+		Renderer.__init__(self)
+		VariableText.__init__(self)
+		self.epgcache = eEPGCache.getInstance()
+
+	GUI_WIDGET = eLabel
+
+	def changed(self, what):
+		event = self.source.event
+
+		if event is None:
+			self.text = ""
+			return
+		service = self.source.service
+		text = ""
+		evt = None
+
+		if self.epgcache is not None:
+			evt = self.epgcache.lookupEvent(['IBDCT', (service.toString(), 0, -1, -1)])
+
+		if evt:
+			maxx = 0
+			for x in evt:
+				if maxx > 0:
+					if x[4]:
+						t = localtime(x[1])
+						text = text + "%02d:%02d %s\n" % (t[3], t[4], x[4])
+					else:
+						text = text + "n/a\n"
+				maxx += 1
+				if maxx > 4:
+					break
+		self.text = text
--- enigma2.org/lib/python/Components/UsageConfig.py
+++ enigma2/lib/python/Components/UsageConfig.py
@@ -7,6 +7,7 @@
 from Components.NimManager import nimmanager
 from Components.Renderer.FrontpanelLed import ledPatterns, PATTERN_ON, PATTERN_OFF, PATTERN_BLINK
 from Components.ServiceList import refreshServiceList
+#from Components.FanControl import fanSpeedChanged
 from SystemInfo import SystemInfo
 import os
 import time
@@ -282,7 +283,7 @@
 
 	config.misc.disable_background_scan = ConfigYesNo(default=False)
 	config.misc.use_ci_assignment = ConfigYesNo(default=False)
-	config.usage.show_event_progress_in_servicelist = ConfigSelection(default='barright', choices=[
+	config.usage.show_event_progress_in_servicelist = ConfigSelection(default='barleft', choices=[
 		('barleft', _("Progress bar left")),
 		('barright', _("Progress bar right")),
 		('percleft', _("Percentage left")),
--- enigma2.org/lib/python/Components/VolumeControl.py
+++ enigma2/lib/python/Components/VolumeControl.py
@@ -74,15 +74,27 @@
 
 	def volMute(self, showMuteSymbol=True, force=False):
 		vol = self.volctrl.getVolume()
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
 			if self.volctrl.isMuted():
 				if showMuteSymbol:
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<
 
 	def volMuteLong(self):
 		self.muteDialog.hide()
--- enigma2.org/lib/python/enigma_python.i
+++ enigma2/lib/python/enigma_python.i
@@ -113,6 +113,7 @@
 #include <lib/python/python_helpers.h>
 #include <lib/gdi/picload.h>
 #include <lib/dvb/fcc.h>
+#include <lib/driver/vfd.h>
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -262,6 +263,7 @@
 %include <lib/gdi/picload.h>
 %include <lib/dvb/fcc.h>
 %include <lib/dvb/streamserver.h>
+%include <lib/driver/vfd.h>
 /**************  eptr  **************/
 
 /**************  signals  **************/
--- enigma2.org/lib/python/Makefile.inc
+++ enigma2/lib/python/Makefile.inc
@@ -29,7 +29,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python/enigma_python.Pcpp@am__quote@
 
 .i.cpp:
-	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -O -nortti -nothreads -o $@ $<
+	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -D__sh__ -O -nortti -nothreads -o $@ $<
 	$(AM_V_at)mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Pcpp
 	$(AM_V_at)sed -i 's/_ENUMS\([(),]\)/\1/g' python/enigma.py
 # more details about why the sed transform is needed can be found in lib/service/iservice.h
--- enigma2.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
+++ enigma2/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
@@ -0,0 +1,2 @@
+
+
--- enigma2.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
+++ enigma2/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
--- enigma2.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
+++ enigma2/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
@@ -0,0 +1,339 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import *
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+
+import os
+#Version 191204.1
+
+try:
+	DisplayType = evfd.getInstance().getVfdType()
+	if DisplayType < 13 or DisplayType > 16:
+		DisplayType = None
+except:
+	DisplayType = None
+DisplayTypevfd = DisplayType
+
+if DisplayTypevfd is None:
+	if stb.lower() == 'cuberevo': # 12 character VFD
+		DisplayType = 13
+	elif stb.lower() == 'cuberevo_mini_fta' or stb.lower() == 'cuberevo_250hd': # LED models
+		DisplayType = 14
+	elif stb.lower() == 'cuberevo_mini' or stb.lower() == 'cuberevo_mini2' or stb.lower() == 'cuberevo_2000hd' or stb.lower() == 'cuberevo_3000hd': # 14 character VFD
+		DisplayType = 15
+	elif stb.lower() == 'cuberevo_9500hd': # 13 character VFD
+		DisplayType = 16
+	else:
+		DisplayType = None
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+#config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+#config.plugins.CuberevoVFD.setDaylight = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.timeMode = ConfigSelection(default = "24h", choices = [("12h"),("24h")])
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+		self.list.append(getConfigListEntry(_("Time mode"), config.plugins.CuberevoVFD.timeMode))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+#		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+#		if config.plugins.CuberevoVFD.setDaylight.getValue():
+#			cubeVfd.enableDaylight()
+#		else:
+#			cubeVfd.disableDaylight()
+
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			cubeVfd.enableTimeMode()
+		else:
+			cubeVfd.disableTimeMode()
+
+		# enable/disable fan activity
+		if config.plugins.CuberevoVFD.setFan.getValue():
+			cubeVfd.enableFan()
+		else:
+			cubeVfd.disableFan()
+
+		# enable/disable led activity
+		if config.plugins.CuberevoVFD.setLed.getValue():
+			cubeVfd.enableLed()
+		else:
+			cubeVfd.disableLed()
+
+	# set the brightness
+		brightness = 3
+		if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+			brightness = 1
+		elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+			brightness = 7
+		evfd.getInstance().vfd_set_brightness(brightness)
+
+		configfile.save()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+		global showmenuorpanel
+		showmenuorpanel = False
+		self.showtimer = eTimer()
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		self.Console = Console()
+		self.tsEnabled = False
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			self.timeModeEnabled = 1
+		else:
+			self.timeModeEnabled = 0
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+
+	def handleTimer(self):
+		global showmenuorpanel
+#		try:
+#			from Plugins.Extensions.Aafpanel.plugin import inAAFPanel
+#			showPanel = inAAFPanel
+#		except:
+#			#print '[CuberevoVFD] Error showPanel'
+		showPanel = None
+		try:
+			from Screens.Menu import inMenu
+			showMenu = inMenu
+		except:
+			#print '[CuberevoVFD] Error showMenu'
+			showMenu = None
+		if showMenu or showPanel:
+			self.showtimer.start(4000, True)
+		self.showtimer.callback.append(self.setshowmenuorpanel)
+		if not showMenu and not showPanel and showmenuorpanel is True:
+			showmenuorpanel = False
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename =subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+				evfd.getInstance().vfd_write_string(servicename)
+
+	def setshowmenuorpanel(self):
+		global showmenuorpanel
+		showmenuorpanel = True
+		self.showtimer.stop()
+
+	def enableClock(self):
+		self.clockEnabled = True
+		try:
+			os.popen("/bin/fp_control -dt 1")
+		except OSError:
+			print "no memory"
+
+	def disableClock(self):
+		self.clockEnabled = False
+		try:
+			os.popen("/bin/fp_control -dt 0")
+		except OSError:
+			print "no memory"
+
+	def enableTimeMode(self):
+		self.timeModeEnabled = 1
+		try:
+			os.popen("/bin/fp_control -tm 1")
+		except OSError:
+			print "no memory"
+
+	def disableTimeMode(self):
+		self.timeModeEnabled = 0
+		try:
+			os.popen("/bin/fp_control -tm 0")
+		except OSError:
+			print "no memory"
+
+	def enableLed(self):
+		self.ledEnabled = True
+		try:
+			os.popen("/bin/fp_control -l 0 1")
+		except OSError:
+			print "no memory"
+
+	def disableLed(self):
+		self.ledEnabled = False
+		try:
+			os.popen("/bin/fp_control -l 0 0")
+		except OSError:
+			print "no memory"
+
+	def enableFan(self):
+		self.fanEnabled = True
+		try:
+			os.popen("/bin/fp_control -sf 1")
+		except OSError:
+			print "no memory"
+
+	def disableFan(self):
+		self.fanEnabled = False
+		try:
+			os.popen("/bin/fp_control -sf 0")
+		except OSError:
+			print "no memory"
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		if not os.path.exists('/proc/stb/lcd/symbol/timeshift'):
+			tmp = self.getTimeshiftState()
+			if tmp == self.tsEnabled:
+				return
+			if tmp:
+				print "[Timeshift enabled]"
+				evfd.getInstance().vfd_set_icon(0x1A,True)
+			else:
+				print "[Timeshift disabled]"
+				evfd.getInstance().vfd_set_icon(0x1A,False)
+			self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
--- enigma2.org/lib/python/Plugins/Extensions/Makefile.am
+++ enigma2/lib/python/Plugins/Extensions/Makefile.am
@@ -1,6 +1,42 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
 SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
+
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO_MINI_FTA
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO_250HD
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO_MINI
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO_MINI2
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO_2000HD
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO_3000HD
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO_9500HD
+SUBDIRS += CuberevoVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
--- enigma2.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
+++ enigma2/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
@@ -0,0 +1,2 @@
+
+
--- enigma2.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
+++ enigma2/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
@@ -0,0 +1,5 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
--- enigma2.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
+++ enigma2/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
@@ -0,0 +1,470 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+	getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+from Components.UsageConfig import defaultMoviePath
+import os
+import array
+
+my_global_session = None
+debug = False
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 10, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioBootReason = 0x40003a0b
+ioOffFlush = struct.pack('LLB', 0x2, 0x0, 0x6)
+ioRec1Flush = struct.pack('LLB', 0x1000, 0x0, 0x6)
+ioRec2Flush = struct.pack('LLB', 0x2000, 0x0, 0x6)
+ioRecBothFlush = struct.pack('LLB', 0x3000, 0x0, 0x6)
+ioClockFlush = struct.pack('LLB', 0x20, 0x0, 0x6)
+ioClockOff = struct.pack('LLB', 0x20, 0x0, 0x0)
+ioHddClear =    struct.pack('LLB', 0x0, 0xff8000,0x0)
+ioHddUsage = (  struct.pack('LLB', 0x0, 0x006000,0xf),  # HDD empty
+                struct.pack('LLB', 0x0, 0x00e000,0xf),
+                struct.pack('LLB', 0x0, 0x01e000,0xf),
+                struct.pack('LLB', 0x0, 0x03e000,0xf),
+                struct.pack('LLB', 0x0, 0x07e000,0xf),
+                struct.pack('LLB', 0x0, 0x0fe000,0xf),
+                struct.pack('LLB', 0x0, 0x1fe000,0xf),
+                struct.pack('LLB', 0x0, 0x3fe000,0xf),
+                struct.pack('LLB', 0x0, 0x7fe000,0xf))  # HDD full
+ioHddFull = struct.pack('LLB', 0x0, 0x800000,0x6)       # "HDD full" flashing
+hddCheckPeriod = 60 # check every 60 seconds
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+		self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+		self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+		self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+		self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+		self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+		self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+		self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+			}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+		tfVfd.setValues()
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+class TopfieldVFD:
+	def __init__(self, session):
+		#print "TopfieldVFD initializing"
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+		{
+			iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+			iPlayableService.evStart: self.__evStart,
+		})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.Console = Console()
+		self.tsEnabled = False
+		self.recNum = 0
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.txCount = 0
+		self.clock = 0
+		self.valuesSet = 0
+		self.hddUsed = 10 # initialize with an invalid value
+		self.hddCheckCounter = hddCheckPeriod
+		self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+		self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+		self.setValues()
+
+	def setValues(self):
+		#print "\nTopfiledVFD.setValues()\n"
+		if config.plugins.TopfieldVFD.showClock.value:
+			self.enableClock()
+		else:
+			self.disableClock()
+
+		# enable/disable displaying Ethernet activity
+		if config.plugins.TopfieldVFD.showEthernet.getValue():
+			self.enableEthernet()
+		else:
+			self.disableEthernet()
+
+		try:
+			fd = open("/dev/fpc")
+
+			# set the brightness
+			brightness = 3
+			if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+				brightness = 1
+			elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+				brightness = 5
+			fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+
+			# set the the scroll mode
+			if config.plugins.TopfieldVFD.scroll.value == "once":
+				scrollMode = 1
+			elif config.plugins.TopfieldVFD.scroll.value == "always":
+				scrollMode = 2
+			else: # set to never by default
+				scrollMode = 0
+			scrollOpts = struct.pack('BBB', scrollMode,
+						int(config.plugins.TopfieldVFD.scrollPause.value),
+						int(config.plugins.TopfieldVFD.scrollDelay.value))
+			fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+
+			# set the typematic values
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+
+			# set the IR filters
+			if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+			elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+			else: # enable both by default
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+			# set the allcaps parameter
+			if config.plugins.TopfieldVFD.allCaps.value:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+			else:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+			buf = array.array('h', [0])
+			fcntl.ioctl(fd.fileno(),ioBootReason,buf,1)
+			if buf[0] == 2:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioOffFlush)
+
+			fd.close()
+			self.valuesSet = 1
+		except IOError,e:
+			if debug:
+				print "[TopfieldVFD] setValues: error", e
+
+	def enableEthernet(self):
+		self.ethEnabled = True
+
+	def disableEthernet(self):
+		self.ethEnabled = False
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "[TopfieldVFD] disableEthernet: error", e
+
+	def enableClock(self):
+		self.clockEnabled = True
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "[TopfieldVFD] enableClock: error", e
+
+	def disableClock(self):
+		self.clockEnabled = False
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+			fd.close()
+			open("/dev/fpsmall", "w").write("     ")
+		except IOError,e:
+			if debug:
+				print "[TopfieldVFD] disableClock: error", e
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+
+	def displayHddUsed(self):
+		if debug:
+			print "[TopfieldVFD] determine HDD usage"
+
+		# determine the HDD usage
+		used = 0;
+		try:
+			f = statvfs(defaultMoviePath())
+			# there are 8 HDD segments in the VFD
+			used = (f.f_blocks - f.f_bavail) * 8 / f.f_blocks
+		except:
+			used = 0;
+
+		if self.hddUsed != used:
+			try:
+				fd = open("/dev/fpc")
+				if self.hddUsed > used:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddClear)
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddUsage[used])
+				if used == 8:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddFull)
+				fd.close();
+			except IOError,e:
+				self.hddUsed = used # dummy operation
+			self.hddUsed = used
+
+	def handleTimer(self):
+		#print "[ TopfieldVFD timer ]"
+		if self.valuesSet == 0:
+			self.setValues()
+
+		if self.clockEnabled:
+			clock = strftime("%k%M",localtime(time()))
+			if clock != self.clock:
+				self.clock = clock
+				try:
+					open("/dev/fpsmall", "w").write(clock + "\0")
+				except IOError,e:
+					if debug:
+						print "[TopfieldVFD] handleTimer (clock): error", e
+
+		# check HDD periodically
+		if self.hddCheckCounter < hddCheckPeriod:
+			self.hddCheckCounter += 1
+		else:
+			self.hddCheckCounter = 0
+			self.displayHddUsed()
+
+		if self.ethEnabled == False:
+			return
+
+		result = open("/proc/net/dev").readlines()
+		numRegExp = "[0-9]+"
+		numPattern = re_compile(numRegExp)
+		txPattern = re_compile("eth0:[ ]*" + numRegExp)
+		for item in result:
+			tmp = self.regExpMatch(txPattern, item)
+			if tmp != None:
+				tmp = tmp[5:].lstrip()
+				try:
+					fd = open("/dev/fpc")
+					if self.txCount != tmp:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+						self.txCount = tmp
+					else:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+					fd.close()
+				except IOError,e:
+					if debug:
+						print "[TopfieldVFD] handleTimer (Ethernet)", e
+					break
+
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		print "[TopfieldVFD] __evSeekableStatusChanged"
+		if not os.path.exists('/proc/stb/lcd/symbol_timeshift'):
+			tmp = self.getTimeshiftState()
+			if tmp == self.tsEnabled:
+				return
+			try:
+				fd = open("/dev/fpc")
+				if tmp:
+					print "[TopfieldVFD] Timeshift enabled"
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+				else:
+					print "[TopfieldVFD] Timeshift disabled"
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+				fd.close()
+			except IOError,e:
+				if debug:
+					print "[TopfieldVFD] __evSeekableStatusChanged: error", e
+				self.tsEnabled = tmp
+#		else:
+#			try:
+#				t_shift = open("/proc/stb/lcd/symbol_timeshift").read().strip()
+#				print "[TopfieldVFD] symbol_timeshift =", t_shift
+#				if t_shift:
+#					fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+#				else:
+#					fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+#			except:
+#				pass	
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs == self.recNum:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if config.usage.blinking_display_clock_during_recording.value:
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1Flush)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+			else:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+				if nrecs > 1: # set rec 1+2 symbols
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+				elif nrecs > 0: # set rec 1 symbol
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+				else:
+					fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "[TopfieldVFD] gotRecordEvent: error", e
+		self.recNum = nrecs
+
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "[TopfieldVFD] aborting"
+
+def main(session, **kwargs):
+	session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+	global tfVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and tfVfd == None:
+		print "[TopfieldVFD] starting"
+		tfVfd = TopfieldVFD(mySession)
+	elif gReason == 1 and tfVfd != None:
+		print "[TopfieldVFD] stopping"
+		tfVfd.disableClock()
+		tfVfd = None
+
+def autostart(reason, **kwargs):
+	global tfVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlTfVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
--- enigma2.org/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
@@ -125,14 +125,14 @@
 
 def startSetup(menuid):
 	# only show in the menu when set to intermediate or higher
-	if menuid == "video" and config.av.videoport.value == "DVI" and config.usage.setup_level.index >= 1:
+	if menuid == "video" and config.av.videoport.value == "HDMI"  and config.usage.setup_level.index >= 1:
 		return [(_("HDMI-CEC setup"), main, "hdmi_cec_setup", 0)]
 	return []
 
 
 def Plugins(**kwargs):
 	from os import path
-	if path.exists("/dev/hdmi_cec") or path.exists("/dev/misc/hdmi_cec0"):
+	if path.exists("/dev/hdmi_cec") and path.exists("/lib/modules/cec.ko"):
 		import Components.HdmiCec
 		from Plugins.Plugin import PluginDescriptor
 		return [PluginDescriptor(where=PluginDescriptor.WHERE_MENU, fnc=startSetup)]
--- enigma2.org/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
@@ -21,6 +21,8 @@
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
+	if physdevpath == "-":
+		physdevpath = None
 	media_state = v.get("X_E2_MEDIA_STATUS")
 	global audiocd
 

--- enigma2.org/lib/python/Plugins/SystemPlugins/Makefile.am
+++ enigma2/lib/python/Plugins/SystemPlugins/Makefile.am
@@ -2,9 +2,9 @@
 
 SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	DefaultServicesScanner DiseqcTester \
 	CableScan FastScan OSDPositionSetup OSD3DSetup HdmiCEC VideoClippingSetup \
-	VideoEnhancement WirelessLan NetworkWizard FastChannelChange
+	VideoEnhancement WirelessLan NetworkWizard FastChannelChange VFD-Icons
 
 if HAVE_TEMPFANCONTROL
 SUBDIRS += TempFanControl
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
@@ -0,0 +1,2 @@
+
+
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_vfd-icons.xml
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
@@ -0,0 +1,20 @@
+<default>
+	<prerequisites>
+		<hardware type="dm8000" />
+		<tag type="System" />
+	</prerequisites>
+	<info>
+		<author>Team Ducktales</author>
+		<name>VFD-Icons</name>
+		<packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		<packagetype>public</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+		<shortdescription>Displays text on VFD</shortdescription>
+		<description>Displays text on VFD.
+		</description>
+	</info>
+
+	<files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-vfd-icons" />
+	</files>
+
+</default>
--- enigma2.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
@@ -0,0 +1,152 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()
+
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '')
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '')
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+
+#		print "[VFD-Icons] vfd display text:", servicename
+		evfd.getInstance().vfd_write_string(servicename)
+		return 1
+
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,True)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,False)
+
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,False)
+
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,False)
+
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,True)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,False)
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,True)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,False)
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
@@ -64,6 +64,9 @@
 				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the screen resolution in PC output mode.")))
 			else:
 				self.list.append(getConfigListEntry(_("Refresh rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the refresh rate of the screen.")))
+#+++>
+		self.list.append(getConfigListEntry(_("3D Mode"), config.av.threedmode))
+#+++<
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
@@ -105,6 +108,15 @@
 					self.list.append(getConfigListEntry(_("HDR10 support"), config.av.hdr10_support, _("This option allows you to force the HDR10 modes for UHD")))
 					self.list.append(getConfigListEntry(_("Allow 12bit"), config.av.allow_12bit, _("This option allows you to enable or disable the 12 bit color mode")))
 					self.list.append(getConfigListEntry(_("Allow 10bit"), config.av.allow_10bit, _("This option allows you to enable or disable the 10 bit color mode")))
+
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
+++ enigma2/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
@@ -17,14 +17,10 @@
 
 	modes = {}  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] = {"50Hz": {50: "pal"},
-								"60Hz": {60: "pal60"},
-								"multi": {50: "pal", 60: "pal60"}}
+	rates["PAL"] = {"50Hz": {50: "pal"}}
 
 	rates["NTSC"] = {"60Hz": {60: "ntsc"}}
 
-	rates["Multi"] = {"multi": {50: "pal", 60: "ntsc"}}
-
 	rates["480i"] = {"60Hz": {60: "480i"}}
 
 	rates["576i"] = {"50Hz": {50: "576i"}}
@@ -34,57 +30,45 @@
 	rates["576p"] = {"50Hz": {50: "576p"}}
 
 	rates["720p"] = {"50Hz": {50: "720p50"},
-								"60Hz": {60: "720p"},
-								"multi": {50: "720p50", 60: "720p"},
-								"auto": {50: "720p50", 60: "720p", 24: "720p24"}}
+	                 "60Hz": {60: "720p"}}
 
 	rates["1080i"] = {"50Hz": {50: "1080i50"},
-								"60Hz": {60: "1080i"},
-								"multi": {50: "1080i50", 60: "1080i"},
-								"auto": {50: "1080i50", 60: "1080i", 24: "1080p24"}}
-
-	rates["1080p"] = {"50Hz": {50: "1080p50"},
-								"60Hz": {60: "1080p"},
-								"multi": {50: "1080p50", 60: "1080p"},
-								"auto": {50: "1080p50", 60: "1080p", 24: "1080p24"}}
-
-	rates["2160p30"] = {"25Hz": {50: "2160p25"},
-								"30Hz": {60: "2160p30"},
-								"multi": {50: "2160p25", 60: "2160p30"},
-								"auto": {50: "2160p25", 60: "2160p30", 24: "2160p24"}}
-
-	rates["2160p"] = {"50Hz": {50: "2160p50"},
-								"60Hz": {60: "2160p"},
-								"multi": {50: "2160p50", 60: "2160p"},
-								"auto": {50: "2160p50", 60: "2160p", 24: "2160p24"}}
-
-	rates["PC"] = {
-		"1024x768": {60: "1024x768"}, # not possible on DM7025
-		"800x600": {60: "800x600"},  # also not possible
-		"720x480": {60: "720x480"},
-		"720x576": {60: "720x576"},
-		"1280x720": {60: "1280x720"},
-		"1280x720 multi": {50: "1280x720_50", 60: "1280x720"},
-		"1920x1080": {60: "1920x1080"},
-		"1920x1080 multi": {50: "1920x1080", 60: "1920x1080_50"},
-		"1280x1024": {60: "1280x1024"},
-		"1366x768": {60: "1366x768"},
-		"1366x768 multi": {50: "1366x768", 60: "1366x768_50"},
-		"1280x768": {60: "1280x768"},
-		"640x480": {60: "640x480"}
-	}
+	                  "60Hz": {60: "1080i"}}
+
+	rates["1080p"] = {"23Hz": {50: "1080p23"},
+	                  "24Hz": {60: "1080p24"},
+	                  "25Hz": {60: "1080p25"},
+	                  "29Hz": {60: "1080p29"},
+	                  "30Hz": {60: "1080p30"},
+	                  "50Hz": {60: "1080p50"},
+	                  "60Hz": {60: "1080p60"}}
+
+	rates["PC"] = {"1024x768"  : {60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100"}, #43 60 70 72 75 90 100
+	               "1280x1024" : {60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75"}, #43 47 60 70 74 75
+	               "1600x1200" : {60: "1600x1200_60"}, #60 66 76
+	               "720x480"   : {60: "720x480"},
+	               "720x576"   : {60: "720x576"},
+	               "1280x720"  : {60: "1280x720"},
+	               "1280x720 multi": {50: "1280x720_50", 60: "1280x720"},
+	               "1920x1080" : {60: "1920x1080"},
+	               "1920x1080 multi": {50: "1920x1080_50", 60: "1920x1080"},
+	               "1280x1024" : {60: "1280x1024"},
+	               "1366x768"  : {60: "1366x768"},
+	               "1366x768 multi" : {50: "1366x768_50", 60: "1366x768"},
+	               "1280x768"  : {60: "1280x768"},
+	               "640x480"   : {60: "640x480"}}
 
 	if SystemInfo["HasScart"]:
-		modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	elif SystemInfo["HasComposite"]:
-		modes["RCA"] = ["576i", "PAL", "NTSC", "Multi"]
+		modes["Scart"] = ["PAL"]
+#	elif SystemInfo["HasComposite"]:
+#		modes["RCA"] = ["576i", "PAL", "NTSC", "Multi"]
 	if SystemInfo["HasYPbPr"]:
-		modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	if SystemInfo["Has2160p"]:
-		modes["DVI"] = ["720p", "1080p", "2160p", "1080i", "576p", "480p", "576i", "480i"]
-	else:
-		modes["DVI"] = ["720p", "1080p", "2160p", "2160p30", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
+		modes["Component"] = ["720p", "1080i", "1080p", "576p", "576i", "480i", "480p"]
+#	if SystemInfo["Has2160p"]:
+#		modes["DVI"] = ["720p", "1080p", "2160p", "1080i", "576p", "480p", "576i", "480i"]
+#	else:
+	modes["HDMI"] = ["720p", "1080p", "1080i", "576p", "576i", "480p", "480i"]
+	modes["HDMI-PC"] = ["PC"]
 
 	def getOutputAspect(self):
 		ret = (16, 9)
@@ -122,7 +106,7 @@
 
 		self.readAvailableModes()
 		self.readPreferredModes()
-		self.widescreen_modes = set(["720p", "1080i", "1080p", "2160p", "2160p30"]).intersection(*[self.modes_available])
+		self.widescreen_modes = set(["480i", "480p", "576i", "576p", "720p", "1080i", "1080p"]).intersection(*[self.modes_available])
 
 		if "DVI-PC" in self.modes and not self.getModeList("DVI-PC"):
 			print "[VideoHardware] remove DVI-PC because of not existing modes"
@@ -140,6 +124,16 @@
 		config.av.wss.notifiers = []
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
+#+++<
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -176,9 +170,8 @@
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
-			if port == "DVI":
-				if mode not in self.modes_preferred:
-					return False
+			if port == "HDMI-PC":
+				return True
 			else:
 				if mode not in self.modes_available:
 					return False
@@ -227,8 +220,12 @@
 				open("/proc/stb/video/videomode_24hz", "w").write(mode_24)
 			except IOError:
 				print "[VideoHardware] cannot open /proc/stb/video/videomode_24hz"
+		#call setResolution() with -1,-1 to read the new screen dimensions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
 
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "[VideoHardware] saveMode", port, mode, rate
@@ -246,7 +243,8 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -353,7 +351,7 @@
 				aspect = "16:9"
 			else:
 				aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-			policy_choices = {"pillarbox": "panscan", "panscan": "letterbox", "nonlinear": "nonlinear", "scale": "bestfit", "full": "full", "auto": "auto"}
+			policy_choices = {"pillarbox": "letterbox", "panscan": "panscan", "nonlinear": "nonlinear", "scale": "bestfit", "auto": "bestfit"}
 			policy = policy_choices[config.av.policy_43.value]
 			policy2_choices = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit", "full": "full", "auto": "auto"}
 			policy2 = policy2_choices[config.av.policy_169.value]
@@ -385,5 +383,30 @@
 			pass
 
 
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
--- enigma2.org/lib/python/Components/AVSwitch.py
+++ enigma2/lib/python/Components/AVSwitch.py
@@ -81,11 +81,11 @@
 	config.av.colorformat = ConfigSelection(choices=colorformat_choices, default="cvbs")
 	config.av.aspectratio = ConfigSelection(choices={
 			"4_3_letterbox": _("4:3 Letterbox"),
-			"4_3_panscan": _("4:3 PanScan"),
+			"4_3_panscan": _("4:3 Zoom"),
 			"16_9": "16:9",
 			"16_9_always": _("16:9 always"),
 			"16_10_letterbox": _("16:10 Letterbox"),
-			"16_10_panscan": _("16:10 PanScan"),
+			"16_10_panscan": _("16:10 Zoom"),
 			"16_9_letterbox": _("16:9 Letterbox")},
 			default="16_9")
 	config.av.aspect = ConfigSelection(choices={
@@ -97,10 +97,10 @@
 	policy2_choices = {
 	# TRANSLATORS: (aspect ratio policy: black bars on top/bottom) in doubt, keep english term.
 	"letterbox": _("Letterbox"),
-	# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
-	"panscan": _("Pan&scan"),
+	# TRANSLATORS: (aspect ratio policy: cropped content on top/bottom) in doubt, keep english term
+	"panscan": _("Zoom"),
 	# TRANSLATORS: (aspect ratio policy: scale as close to fullscreen as possible)
-	"scale": _("Just scale")}
+	"scale": _("Stretch")}
 	try:
 		if "full" in open("/proc/stb/video/policy2_choices").read():
 			# TRANSLATORS: (aspect ratio policy: display as fullscreen, even if the content aspect ratio does not match the screen ratio)
@@ -118,13 +118,13 @@
 	# TRANSLATORS: (aspect ratio policy: black bars on left/right) in doubt, keep english term.
 	"pillarbox": _("Pillarbox"),
 	# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
-	"panscan": _("Pan&scan"),
+	"panscan": _("Zoom"),
 	# TRANSLATORS: (aspect ratio policy: scale as close to fullscreen as possible)
-	"scale": _("Just scale")}
+	"nonlinear": _("Stretch")}
 	try:
 		if "nonlinear" in open("/proc/stb/video/policy_choices").read():
 			# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching the left/right)
-			policy_choices.update({"nonlinear": _("Nonlinear")})
+			policy_choices.update({"nonlinear": _("Panoramic")})
 	except:
 		pass
 	try:
@@ -140,8 +140,8 @@
 	except:
 		pass
 	config.av.policy_43 = ConfigSelection(choices=policy_choices, default="pillarbox")
-	config.av.tvsystem = ConfigSelection(choices={"pal": "PAL", "ntsc": "NTSC", "multinorm": "multinorm"}, default="pal")
-	config.av.wss = ConfigEnableDisable(default=True)
+	config.av.tvsystem = ConfigSelection(choices = {"pal": _("PAL"), "ntsc": _("NTSC"), "multinorm": _("Multinorm")}, default="multinorm")
+	config.av.wss = ConfigEnableDisable(default = False)
 	config.av.generalAC3delay = ConfigSelectionNumber(-1000, 1000, 5, default=0)
 	config.av.generalPCMdelay = ConfigSelectionNumber(-1000, 1000, 5, default=0)
 	config.av.vcrswitch = ConfigEnableDisable(default=False)
--- enigma2.org/lib/python/Components/InputDevice.py.org
+++ enigma2/lib/python/Components/InputDevice.py
@@ -48,7 +48,7 @@
 				self.Devices[evdev] = {'name': self.name, 'type': self.getInputDeviceType(self.name), 'enabled': False, 'configuredName': None}
 
 	def getInputDeviceType(self, name):
-		if "remote control" in str(name).lower():
+		if "remote control" in str(name).lower() or "tdt rc event diver" in str(name).lower():
 			return "remote"
 		elif "keyboard" in str(name).lower():
 			return "keyboard"
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
+++ enigma2.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
@@ -9,6 +9,7 @@
 
 from Tools.Directories import resolveFilename, SCOPE_PLUGINS
 from Tools.HardwareInfo import HardwareInfo
+from enigma import evfd
 
 config.misc.showtestcard = ConfigBoolean(default=False)
 
@@ -72,6 +73,7 @@
 		config.misc.videowizardenabled.value = 0
 		config.misc.videowizardenabled.save()
 		configfile.save()
+		evfd.getInstance().vfd_write_string("                ")
 
 	def listInputChannels(self):
 		hw_type = HardwareInfo().get_device_name()
--- enigma2.org/lib/python/Plugins/SystemPlugins/Videomode/videowizard.xml
+++ enigma2.patched/lib/python/Plugins/SystemPlugins/Videomode/videowizard.xml
@@ -1,6 +1,6 @@
 <wizard>
-	<step id="inputselection" nextstep="modeselection" timeout="20" timeoutaction="selectnext">
-		<text value="Video input selection\n\nPlease press OK if you can see this page on your TV (or select a different input port).\n\nThe next input port will be automatically probed in 20 seconds." />
+	<step id="inputselection" nextstep="modeselection" timeout="10" timeoutaction="selectnext">
+		<text value="Video input selection\n\nPlease press OK if you can see this page on your TV (or select a different input port).\n\nThe next input port will be automatically probed in 10 seconds." />
 		<displaytext value="Select video input with up/down buttons" />
 		<list type="dynamic" source="listInputChannels" evaluation="inputSelectionMade" onselect="inputSelectionMoved" />
 		<code>
@@ -9,7 +9,7 @@
 self.selectKey("OK")
 		</code>
 	</step>
-	<step id="modeselection" nextstep="rateselection" timeout="20" timeoutaction="selectnext">
+	<step id="modeselection" nextstep="rateselection" timeout="10" timeoutaction="selectnext">
 		<text value="Video mode selection." />
 		<displaytext value="Select video mode" />
 		<list type="dynamic" source="listModes" evaluation="modeSelectionMade" onselect="modeSelectionMoved" />
@@ -20,7 +20,7 @@
 self["portpic"].hide()
 		</code>
 	</step>
-	<step id="rateselection" timeout="20" timeoutaction="selectnext">
+	<step id="rateselection" timeout="10" timeoutaction="selectnext">
 		<condition>
 self.condition = (self.port != "DVI" and not self.port == "RCA" or self.mode == "PC")
 		</condition>
--- enigma2.org/lib/python/Plugins/SystemPlugins/OSDPositionSetup/overscanwizard.py
+++ enigma2/lib/python/Plugins/SystemPlugins/OSDPositionSetup/overscanwizard.py
@@ -152,7 +152,7 @@
 		if self.step == 1:
 			self.step = self.yes_no.value and 5 or 2
 		elif self.step == 2:
-			self.step = self.yes_no.value and 5 or os.path.exists("/proc/stb/fb/dst_left") and 3 or 4
+			self.step = self.yes_no.value and 5 or os.path.exists("/proc/stb/vmpeg/0/dst_left") and 3 or 4
 		elif self.step == 3:
 			self.save_new_position = True
 			self.step = 5
--- enigma2.org/lib/python/Plugins/SystemPlugins/TempFanControl/plugin.py
+++ enigma2/lib/python/Plugins/SystemPlugins/TempFanControl/plugin.py
@@ -127,9 +127,9 @@
 
 		self.list = []
 		for count in range(fancontrol.getFanCount()):
-			self.list.append(getConfigListEntry(_("Fan %d voltage") % (count + 1), fancontrol.getConfig(count).vlt))
+#			self.list.append(getConfigListEntry(_("Fan %d voltage") % (count + 1), fancontrol.getConfig(count).vlt))
 			self.list.append(getConfigListEntry(_("Fan %d PWM") % (count + 1), fancontrol.getConfig(count).pwm))
-			self.list.append(getConfigListEntry(_("Standby fan %d voltage") % (count + 1), fancontrol.getConfig(count).vlt_standby))
+#			self.list.append(getConfigListEntry(_("Standby fan %d voltage") % (count + 1), fancontrol.getConfig(count).vlt_standby))
 			self.list.append(getConfigListEntry(_("Standby fan %d PWM") % (count + 1), fancontrol.getConfig(count).pwm_standby))
 
 		ConfigListScreen.__init__(self, self.list, session=self.session)
@@ -149,17 +149,17 @@
 
 	def save(self):
 		for count in range(fancontrol.getFanCount()):
-			fancontrol.getConfig(count).vlt.save()
+#			fancontrol.getConfig(count).vlt.save()
 			fancontrol.getConfig(count).pwm.save()
-			fancontrol.getConfig(count).vlt_standby.save()
+#			fancontrol.getConfig(count).vlt_standby.save()
 			fancontrol.getConfig(count).pwm_standby.save()
 		self.close()
 
 	def revert(self):
 		for count in range(fancontrol.getFanCount()):
-			fancontrol.getConfig(count).vlt.load()
+#			fancontrol.getConfig(count).vlt.load()
 			fancontrol.getConfig(count).pwm.load()
-			fancontrol.getConfig(count).vlt_standby.load()
+#			fancontrol.getConfig(count).vlt_standby.load()
 			fancontrol.getConfig(count).pwm_standby.load()
 		self.close()
 
--- enigma2.org/lib/python/Screens/ChannelSelection.py
+++ enigma2/lib/python/Screens/ChannelSelection.py
@@ -7,6 +7,11 @@
 import Components.ParentalControl
 from Components.Button import Button
 from Components.ServiceList import ServiceList, refreshServiceList
+#+++>
+from Components.Sources.StaticText import StaticText
+from Components.Label import Label
+from os import path as os_path, system, unlink
+#+++<
 from Components.ActionMap import NumberActionMap, ActionMap, HelpableActionMap
 from Components.MenuList import MenuList
 from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
@@ -898,6 +903,9 @@
 		self.saved_title = None
 		self.saved_root = None
 		self.current_ref = None
+#+++>
+		self["title"] = StaticText()
+#+++<
 		self.editMode = False
 		self.confirmRemove = True
 
@@ -998,7 +1006,7 @@
 				if mutableAlternatives:
 					mutableAlternatives.setListName(name)
 					if mutableAlternatives.addService(cur_service.ref):
-						print "add", cur_service.ref.toString(), "to new alternatives failed"
+						print "Adding", cur_service.ref.toString(), "to new alternatives failed"
 					mutableAlternatives.flushChanges()
 					self.servicelist.addService(new_ref.ref, True)
 					self.servicelist.removeCurrent()
@@ -1009,7 +1017,7 @@
 					if self.startServiceRef and cur_service.ref == self.startServiceRef:
 						self.startServiceRef = new_ref.ref
 				else:
-					print "get mutable list for new created alternatives failed"
+					print "Get mutable list for new created alternatives failed"
 			else:
 				print "add", str, "to", cur_root.getServiceName(), "failed"
 		else:
@@ -1033,10 +1041,10 @@
 					if services is not None:
 						for service in services:
 							if mutableBouquet.addService(service):
-								print "add", service.toString(), "to new bouquet failed"
+								print "Adding", service.toString(), "to new bouquet failed"
 					mutableBouquet.flushChanges()
 				else:
-					print "get mutable list for new created bouquet failed"
+					print "Get mutable list for newly created bouquet failed"
 				# do some voodoo to check if current_root is equal to bouquet_root
 				cur_root = self.getRoot()
 				str1 = cur_root and cur_root.toString()
@@ -1046,9 +1054,9 @@
 					self.servicelist.addService(new_bouquet_ref)
 					self.servicelist.resetRoot()
 			else:
-				print "add", str, "to bouquets failed"
-		else:
-			print "bouquetlist is not editable"
+				print "Adding", str, "to bouquets failed"
+		else:
+			print "Bouquet list is not editable"
 
 	def copyCurrentToBouquetList(self):
 		provider = ServiceReference(self.getCurrentSelection())
@@ -1074,11 +1083,11 @@
 					if self.startServiceRef and cur_service.ref == self.startServiceRef:
 						self.startServiceRef = first_in_alternative
 				else:
-					print "couldn't add first alternative service to current root"
-			else:
-				print "couldn't edit current root!!"
-		else:
-			print "remove empty alternative list !!"
+					print "Could not add first alternative service to current root"
+			else:
+				print "Could not edit current root!!"
+		else:
+			print "Removing empty alternative list !!"
 		self.removeBouquet()
 		if not end:
 			self.servicelist.moveUp()
@@ -1160,6 +1168,9 @@
 			else:
 				new_title += ' ' + _("[favourite edit]")
 		self.setTitle(new_title)
+#+++>
+		self["title"].setText(new_title)
+#+++<
 		self.__marked = self.servicelist.getRootServices()
 		for x in self.__marked:
 			self.servicelist.addMarked(eServiceReference(x))
@@ -1187,6 +1198,9 @@
 		self.bouquet_mark_edit = OFF
 		self.mutableList = None
 		self.setTitle(self.saved_title)
+#+++>
+		self["title"].setText(self.saved_title)
+#+++<
 		self.saved_title = None
 		# self.servicePath is just a reference to servicePathTv or Radio...
 		# so we never ever do use the asignment operator in self.servicePath
@@ -1265,6 +1279,9 @@
 			self.mutableList.flushChanges() # FIXME add check if changes was made
 			self.mutableList = None
 			self.setTitle(self.saved_title)
+#+++>
+			self["title"].setText(self.saved_title)
+#+++<
 			self.saved_title = None
 			self.servicelist.resetRoot()
 			self.servicelist.l.setHideNumberMarker(config.usage.hide_number_markers.value)
@@ -1276,6 +1293,9 @@
 			self.saved_title = self.getTitle()
 			pos = self.saved_title.find(')')
 			self.setTitle(self.saved_title[:pos + 1] + ' ' + _("[move mode]") + self.saved_title[pos + 1:])
+#+++>
+			self["title"].setText(self.saved_title[:pos + 1] + ' ' + _("[move mode]") + self.saved_title[pos + 1:])
+#+++<
 			self.servicelist.l.setHideNumberMarker(False)
 			self.setCurrentSelection(self.servicelist.getCurrent())
 		self["Service"].editmode = True
@@ -1333,6 +1353,11 @@
 
 		self["list"] = ServiceList(self)
 		self.servicelist = self["list"]
+
+#+++>
+		self["boquet"] = Label(_("Channel Selection"))
+		self["title"] = StaticText()
+#+++<
 
 		self.numericalTextInput = NumericalTextInput(handleTimeout=False)
 		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
@@ -1427,6 +1452,9 @@
 			title = title[:pos]
 		title += _(" (TV)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRadioMode(self):
 		self.mode = MODE_RADIO
@@ -1438,6 +1466,9 @@
 			title = title[:pos]
 		title += _(" (Radio)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRoot(self, root, justSet=False):
 		if self.startRoot is None:
@@ -1492,6 +1523,9 @@
 					end_ref = None
 				nameStr = self.getServiceName(base_ref)
 				titleStr += ' - ' + nameStr
+#+++>
+				self["boquet"].setText("Channel Selection")
+#+++<
 				if end_ref is not None:
 					if Len > 2:
 						titleStr += '/../'
@@ -1499,7 +1533,13 @@
 						titleStr += '/'
 					nameStr = self.getServiceName(end_ref)
 					titleStr += nameStr
+#+++>
+					self["boquet"].setText(nameStr)
+#+++<
 				self.setTitle(titleStr)
+#+++>
+				self["title"].setText(titleStr)
+#+++<
 
 	def moveUp(self):
 		self.servicelist.moveUp()
--- enigma2.org/lib/python/Screens/InfoBarGenerics.py
+++ enigma2/lib/python/Screens/InfoBarGenerics.py
@@ -10,7 +10,7 @@
 from Components.ServiceEventTracker import ServiceEventTracker
 from Components.ServiceList import refreshServiceList
 from Components.Sources.Boolean import Boolean
-from Components.config import config, ConfigBoolean, ConfigClock
+from Components.config import config, ConfigBoolean, ConfigClock, ConfigSubsection, ConfigYesNo
 from Components.SystemInfo import SystemInfo
 from Components.UsageConfig import preferredInstantRecordPath, defaultMoviePath
 from Components.VolumeControl import VolumeControl
@@ -38,6 +38,7 @@
 
 from Tools import Notifications, ASCIItranslit
 from Tools.Directories import fileExists, getRecordingFilename, moveFiles
+from Tools.Command import command
 
 from enigma import eTimer, eServiceCenter, eDVBServicePMTHandler, iServiceInformation, iPlayableService, eServiceReference, eEPGCache, eActionMap, getDesktop, eDVBDB
 
@@ -257,6 +258,7 @@
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+	STATE_EPG = 4
 	FLAG_CENTER_DVB_SUBS = 2048
 
 	def __init__(self):
@@ -397,6 +399,12 @@
 		else:
 			self.toggleShow()
 
+	def epg(self):
+		self.__state = self.STATE_EPG
+		self.hide()
+		self.hideTimer.stop()
+		self.openEventView()
+
 	def toggleShow(self):
 		if self.__state == self.STATE_HIDDEN:
 			self.showFirstInfoBar()
@@ -411,7 +419,9 @@
 			self.show()
 			self.actualSecondInfoBarScreen.show()
 			self.startHideTimer()
-		else:
+		elif self.__state == self.STATE_SHOWN:
+			self.epg()
+		elif self.__state == self.STATE_EPG:
 			self.hide()
 			self.hideTimer.stop()
 
@@ -713,6 +723,19 @@
 				"historyNext": (self.historyNext, _("Switch to next channel in history")),
 				"keyChannelUp": (self.keyChannelUpCheck, self.getKeyChannelUpHelptext),
 				"keyChannelDown": (self.keyChannelDownCheck, self.getKeyChannelDownHelptext),
+#added
+				'sleepTimer': (self.sleepTimer, 'Sleeptimer'),
+				'timer': (self.timer, 'Timer'),
+				'showFavourites': (self.showFavourites, _('Bouquet list')),
+				"showSatellites": (self.showSatellites, _('Satellite list')),
+				"volumeUp": (self.volumeUp, _("Volume up")),
+				"volumeDown": (self.volumeDown, _("Volume Down")),
+#compatibility with older keymaps
+				"switchChannelUp": (self.keyUpCheck, self.getKeyUpHelptext),
+				"switchChannelDown": (self.keyDownCheck, self.getKeyDownHelpText),
+				"zapUp": (self.keyChannelDownCheck, self.getKeyChannelDownHelptext),
+				"zapDown": (self.keyChannelUpCheck, self.getKeyChannelUpHelptext),
+				"openServiceList": (self.openServiceList, _("Open service list"))
 			})
 
 	def showTvChannelList(self, zap=False):
@@ -878,6 +901,32 @@
 			self.servicelist.moveUp()
 		self.servicelist.zap(enable_pipzap=True)
 
+	def sleepTimer(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
+
+	def timer(self):
+		from Screens.TimerEdit import TimerEditList
+		self.session.open(TimerEditList)
+
+	def showFavourites(self):
+		self.servicelist.showFavourites()
+		self.session.execDialog(self.servicelist)
+
+	def showSatellites(self):
+		self.servicelist.showSatellites()
+		self.session.execDialog(self.servicelist)
+
+	def volumeUp(self):
+		from enigma import eDVBVolumecontrol
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def volumeDown(self):
+		from enigma import eDVBVolumecontrol
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+
 	def zapDown(self):
 		if self.servicelist.inBouquet():
 			prev = self.servicelist.getCurrentSelection()
@@ -924,7 +973,7 @@
 	def __init__(self):
 		self["MenuActions"] = HelpableActionMap(self, "InfobarMenuActions",
 			{
-				"mainMenu": (self.mainMenu, _("Enter main menu...")),
+				"mainMenu": (self.mainMenu, _("Enter main menu")),
 			})
 		self.session.infobar = None
 
@@ -1043,7 +1092,7 @@
 
 		self["EPGActions"] = HelpableActionMap(self, "InfobarEPGActions",
 			{
-				"showEventInfo": (self.showDefaultEPG, _("Show EPG...")),
+				"showEventInfo": (self.showDefaultEPG, _("Show EPG")),
 				"showEventInfoSingleEPG": (self.showSingleEPG, _("Show single service EPG")),
 				"showEventInfoMultiEPG": (self.showMultiEPG, _("Show multi channel EPG")),
 				"showInfobarOrEpgWhenInfobarAlreadyVisible": self.showEventInfoWhenNotVisible,
@@ -1054,7 +1103,7 @@
 				if 'selectedevent' not in p.__call__.func_code.co_varnames] or []
 		from Components.ServiceEventTracker import InfoBarCount
 		if getAll or InfoBarCount == 1:
-			pluginlist.append((_("Show EPG for current channel..."), self.openSingleServiceEPG, _("Display EPG list for current channel")))
+			pluginlist.append((_("Show EPG for current channel"), self.openSingleServiceEPG, _("Display EPG list for current channel")))
 		pluginlist.append((_("Multi EPG"), self.openMultiServiceEPG, _("Display EPG as MultiEPG")))
 		pluginlist.append((_("Current event EPG"), self.openEventView, _("Display EPG info for current event")))
 		return pluginlist
@@ -1208,7 +1257,7 @@
 	def showEventInfoPlugins(self):
 		pluginlist = self.getEPGPluginList()
 		if pluginlist:
-			self.session.openWithCallback(self.EventInfoPluginChosen, ChoiceBox, title=_("Please choose an extension..."), list=pluginlist, skin_name="EPGExtensionsList", reorderConfig="eventinfo_order", windowTitle=_("Events info menu"))
+			self.session.openWithCallback(self.EventInfoPluginChosen, ChoiceBox, title=_("Please select an extension"), list=pluginlist, skin_name="EPGExtensionsList", reorderConfig="eventinfo_order", windowTitle=_("Events info menu"))
 		else:
 			self.openSingleServiceEPG()
 
@@ -1281,7 +1330,7 @@
 				self.eventView = self.session.openWithCallback(self.closed, EventViewEPGSelect, epglist[0], ServiceReference(ref), self.eventViewCallback, self.openSingleServiceEPG, self.openMultiServiceEPG, self.openSimilarList)
 				self.dlg_stack.append(self.eventView)
 		if not epglist:
-			print "no epg for the service avail.. so we show multiepg instead of eventinfo"
+			print "No EPG for the service available; show multiEPG instead of eventinfo"
 			self.openMultiServiceEPG(False)
 
 	def eventViewCallback(self, setEvent, setService, val): #used for now/next displaying
@@ -2193,7 +2242,7 @@
 		self.addExtension((lambda: _("Manually import from fallback tuner"), self.importChannels, lambda: config.usage.remote_fallback_extension_menu.value and config.usage.remote_fallback_import.value))
 		self["InstantExtensionsActions"] = HelpableActionMap(self, "InfobarExtensions",
 			{
-				"extensions": (self.showExtensionSelection, _("Show extensions...")),
+				"extensions": (self.showExtensionSelection, _("Show extensions")),
 			}, 1) # lower priority
 
 	def openSoftcamSetup(self):
@@ -2223,7 +2272,7 @@
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue"]
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:
@@ -2250,7 +2299,7 @@
 				else:
 					extensionsList.remove(extension)
 		list.extend([(x[0](), x) for x in extensionsList])
-		list and self.session.openWithCallback(self.extensionCallback, ChoiceBox, title=_("Please choose an extension..."), list=list, keys=keys, skin_name="ExtensionsList", reorderConfig="extension_order", windowTitle=_("Extensions menu"))
+		list and self.session.openWithCallback(self.extensionCallback, ChoiceBox, title=_("Please select an extension"), list=list, keys=keys, skin_name="ExtensionsList", reorderConfig="extension_order", windowTitle=_("Extensions menu"))
 
 	def extensionCallback(self, answer):
 		if answer is not None:
@@ -2465,7 +2514,7 @@
 
 class InfoBarInstantRecord:
 	"""Instant Record - handles the instantRecord action in order to
-	start/stop instant records"""
+	start/stop instant recordings"""
 
 	def __init__(self):
 		self["InstantRecordActions"] = HelpableActionMap(self, "InfobarInstantRecord",
@@ -2552,7 +2601,7 @@
 	def startInstantRecording(self, limitEvent=False):
 		begin = int(time())
 		end = begin + 3600      # dummy
-		name = "instant record"
+		name = "Instant recording"
 		info = {}
 
 		self.getProgramInfoAndEvent(info, name)
@@ -2782,7 +2831,7 @@
 	def __init__(self):
 		self["AudioSelectionAction"] = HelpableActionMap(self, "InfobarAudioSelectionActions",
 			{
-				"audioSelection": (self.audioSelection, _("Audio options...")),
+				"audioSelection": (self.audioSelection, _("Audio options")),
 			})
 
 	def audioSelection(self):
@@ -2797,7 +2847,7 @@
 	def __init__(self):
 		self["SubserviceSelectionAction"] = HelpableActionMap(self, "InfobarSubserviceSelectionActions",
 			{
-				"subserviceSelection": (self.subserviceSelection, _("Subservice list...")),
+				"subserviceSelection": (self.subserviceSelection, _("Subservice list")),
 			})
 
 		self["SubserviceQuickzapAction"] = HelpableActionMap(self, "InfobarSubserviceQuickzapActions",
@@ -2874,7 +2923,7 @@
 					keys = ["red", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
 					selection += 2
 				if tlist:
-					self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a sub service..."), list=tlist, selection=selection, keys=keys, skin_name="SubserviceSelection")
+					self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a sub service"), list=tlist, selection=selection, keys=keys, skin_name="SubserviceSelection")
 				else:
 					self.session.open(MessageBox, _("No active subservices available."), MessageBox.TYPE_INFO, timeout=5, simple=True)
 
@@ -2924,7 +2973,7 @@
 	def __init__(self):
 		self["RedButtonActions"] = HelpableActionMap(self, "InfobarRedButtonActions",
 			{
-				"activateRedButton": (self.activateRedButton, _("Red button...")),
+				"activateRedButton": (self.activateRedButton, _("Red button")),
 			})
 		self.onHBBTVActivation = []
 		self.onRedButtonActivation = []
@@ -2944,7 +2993,7 @@
 	def __init__(self):
 		self["TimerButtonActions"] = HelpableActionMap(self, "InfobarTimerButtonActions",
 			{
-				"timerSelection": (self.timerSelection, _("Timer selection...")),
+				"timerSelection": (self.timerSelection, _("Timer selection")),
 			})
 
 	def timerSelection(self):
@@ -3361,7 +3410,7 @@
 		if self.teletext_plugin is not None:
 			self["TeletextActions"] = HelpableActionMap(self, "InfobarTeletextActions",
 				{
-					"startTeletext": (self.startTeletext, _("View teletext..."))
+					"startTeletext": (self.startTeletext, _("View teletext"))
 				})
 		else:
 			print "no teletext plugin found!"
@@ -3375,8 +3424,8 @@
 		object.__init__(self)
 		self["SubtitleSelectionAction"] = HelpableActionMap(self, "InfobarSubtitleSelectionActions",
 			{
-				"subtitleSelection": (self.subtitleSelection, _("Subtitle selection...")),
-				"subtitleShowHide": (self.toggleSubtitleShown, _("Subtitle show/hide...")),
+				"subtitleSelection": (self.subtitleSelection, _("Subtitle selection")),
+				"subtitleShowHide": (self.toggleSubtitleShown, _("Subtitle show/hide")),
 			})
 
 		self.selected_subtitle = None
--- enigma2.org/lib/python/Screens/InfoBar.py
+++ enigma2/lib/python/Screens/InfoBar.py
@@ -9,6 +9,9 @@
 
 profile("LOAD:enigma")
 import enigma
+#+++>
+from enigma import iServiceInformation, iPlayableService
+#+++<
 
 profile("LOAD:InfoBarGenerics")
 from Screens.InfoBarGenerics import InfoBarShowHide, \
@@ -51,6 +54,10 @@
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
 				"toggleTvRadio": (self.toggleTvRadio, _("Toggle the tv and the radio player...")),
+				"volumeUp": (self._volUp, _("Volume up")),
+				"volumeDown": (self._volDown, _("Volume Down")),
+				"resolution": (self.resolution, _("Select display resolution")),
+				"aspect": (self.aspect, _("Select aspect ratio")),
 			}, prio=2)
 
 		self.radioTV = 0
@@ -66,8 +73,8 @@
 				InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarHotkey:
 			x.__init__(self)
 
-		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings..."))]))
-		self.helpList.append((self["actions"], "InfobarActions", [("showRadio", _("Listen to the radio..."))]))
+		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings"))]))
+		self.helpList.append((self["actions"], "InfobarActions", [("showRadio", _("Listen to the radio"))]))
 
 		self.__event_tracker = ServiceEventTracker(screen=self, eventmap={
 				enigma.iPlayableService.evUpdatedEventInfo: self.__eventInfoChanged
@@ -77,6 +84,93 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+	def aspect(self):
+		selection = 0
+		tlist = []
+		try:
+			policy = open("/proc/stb/video/policy_choices").read()[:-1]
+		except IOError:
+			print "couldn't read available policymodes."
+			policy_available = [ ]
+			return
+		policy_available = policy.split(' ')
+		for x in policy_available:
+			tlist.append((x[0].upper() + x[1:], _(x)))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.aspectSelect, ChoiceBox, title=_("Please select an aspect ratio"), list = tlist, selection = selection, keys = keys)
+
+	def aspectSelect(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def resolution(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "Hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("NTSC", "ntsc"))
+		tlist.append(("480i", "480i"))
+		tlist.append(("480p", "480p"))
+		tlist.append(("PAL", "pal"))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@29.97hz", "1080p29"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59.94hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+		keys = ["green", "", "yellow", "blue", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.ResolutionSelect, ChoiceBox, title=_("Please select a resolution"), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelect(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				open("/proc/stb/video/videomode", "w").write(Resolution[1])
+				from enigma import gMainDC
+				gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+	def _volUp(self):
+		print "_volUp"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def _volDown(self):
+		print "_volDown"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+ 
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -95,6 +189,22 @@
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+	def toggleTvRadio(self): 
+		service = self.session.nav.getCurrentService()
+		info = service.info()
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID)
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID)
+
+		print "sAudioPID", AudioPID
+		print "sVideoPID", VideoPID
+
+		if VideoPID == -1:
+			print "Radio->TV"
+			self.showTv2()
+		else:
+			print "TV->Radio"
+			self.showRadio2()
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -118,6 +228,19 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+	def showTv2(self):
+		self.showTvChannelList(False)
+		self.openServiceList()
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+			self.openServiceList()
+		else:
+			self.rds_display.hide() # in InfoBarRdsDecoder
+			from Screens.ChannelSelection import ChannelSelectionRadio
+			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+
 	def toggleTvRadio(self):
 		if self.radioTV == 1:
 			self.radioTV = 0
@@ -152,6 +275,7 @@
 class MoviePlayer(InfoBarBase, InfoBarShowHide, InfoBarMenu, InfoBarSeek, InfoBarShowMovies, InfoBarInstantRecord, InfoBarVmodeButton,
 		InfoBarAudioSelection, HelpableScreen, InfoBarNotifications, InfoBarServiceNotifications, InfoBarPVRState,
 		InfoBarCueSheetSupport, InfoBarMoviePlayerSummarySupport, InfoBarSubtitleSupport, Screen, InfoBarTeletextPlugin,
+		InfoBarSubserviceSelection,
 		InfoBarServiceErrorPopupSupport, InfoBarExtensions, InfoBarPlugins, InfoBarPiP, InfoBarHDMI, InfoBarHotkey):
 
 	ENABLE_RESUME_SUPPORT = True
@@ -163,10 +287,10 @@
 
 		self["actions"] = HelpableActionMap(self, "MoviePlayerActions",
 			{
-				"leavePlayer": (self.leavePlayer, _("leave movie player...")),
-				"leavePlayerOnExit": (self.leavePlayerOnExit, _("leave movie player...")),
-				"channelUp": (self.channelUp, _("when PiPzap enabled zap channel up...")),
-				"channelDown": (self.channelDown, _("when PiPzap enabled zap channel down...")),
+				"leavePlayer": (self.leavePlayer, _("Leave movie player")),
+				"leavePlayerOnExit": (self.leavePlayerOnExit, _("Leave movie player")),
+				"channelUp": (self.channelUp, _("When PiPzap enabled zap channel up")),
+				"channelDown": (self.channelDown, _("When PiPzap enabled zap channel down")),
 			})
 
 		self["DirectionActions"] = HelpableActionMap(self, "DirectionActions",
@@ -544,3 +668,7 @@
 
 	def ref2HumanName(self, ref):
 		return enigma.eServiceCenter.getInstance().info(ref).getName(ref)
+
+	def sleepTimer(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
--- enigma2.org/lib/python/Screens/InstallWizard.py
+++ enigma2/lib/python/Screens/InstallWizard.py
@@ -36,7 +36,7 @@
 			self.adapters = [adapter for adapter in iNetwork.getAdapterList() if adapter in ('eth0', 'eth1')]
 			self.checkNetwork()
 		elif self.index == self.STATE_CHOISE_CHANNELLIST:
-			self.enabled = ConfigYesNo(default=True, graphic=False)
+			self.enabled = ConfigYesNo(default=False, graphic=False)
 			modes = {"19e-23e-basis": "Astra1 Astra3 basis", "19e-23e": "Astra 1 Astra 3", "19e-23e-28e": "Astra 1 Astra 2 Astra 3", "13e-19e-23e-28e": "Astra 1 Astra 2 Astra 3 Hotbird", "9e-13e-19e-23e-28e-rotating": "Rotating", "kabelnl": "Kabel-NL"}
 			self.channellist_type = ConfigSelection(choices=modes, default="19e-23e-basis")
 			self.createMenu()
--- enigma2.org/lib/python/Screens/ScanSetup.py
+++ enigma2/lib/python/Screens/ScanSetup.py
@@ -1263,7 +1263,7 @@
 		self.cable_toggle = {"single_transponder": "complete", "complete": "single_transponder"}
 		self.scan_typeterrestrial = ConfigSelection(default=defaultTerrSearchType, choices=[("single_transponder", _("User defined transponder")), ("predefined_transponder", _("Predefined transponder")), ("complete", _("Complete"))])
 		self.scan_type_atsc = ConfigSelection(default=defaultATSCSearchType, choices=[("single_transponder", _("User defined transponder")), ("predefined_transponder", _("Predefined transponder")), ("complete", _("Complete"))])
-		self.scan_input_as = ConfigSelection(default="channel", choices=[("frequency", _("Frequency")), ("channel", _("Channel"))])
+		self.scan_input_as = ConfigSelection(default = "frequency", choices = [("frequency", _("Frequency")), ("channel", _("Channel"))])
 		self.scan_ter_complete_type = ConfigSelection(default="all", choices=[("all", _("All frequency")), ("extended", _("Extended"))])
 		self.scan_clearallservices = ConfigSelection(default="no", choices=[("no", _("no")), ("yes", _("yes")), ("yes_hold_feeds", _("yes (keep feeds)"))])
 		self.scan_onlyfree = ConfigYesNo(default=False)
--- enigma2.org/lib/python/Screens/Standby.py
+++ enigma2/lib/python/Screens/Standby.py
@@ -18,6 +18,11 @@
 from GlobalActions import globalActionMap
 from enigma import eDVBVolumecontrol, eTimer, eDVBLocalTimeHandler, eServiceReference, eStreamServer, quitMainloop, iRecordableService
 
+from Tools.HardwareInfo import HardwareInfo
+ 
+pll0 = '/proc/cpu_frequ/pll0_ndiv_mdiv'
+stb = HardwareInfo().get_device_name()
+
 inStandby = None
 infoBarInstance = None
 
@@ -78,6 +83,40 @@
 		self.timeHandler = None
 
 		self.setMute()
+
+		if stb.lower() == 'spark' or stb.lower() == 'spark7162':
+			#apply standby CPU clock frequency
+#			if config.plugins.systemoptions.stbyfreq.value:
+#				if config.plugins.systemoptions.stbyfreq.value == "200":
+#					overclk=5123
+#				elif config.plugins.systemoptions.stbyfreq.value == "300":
+#					overclk=2561
+#				elif config.plugins.systemoptions.stbyfreq.value == "450":
+#					overclk=3841
+#				elif config.plugins.systemoptions.stbyfreq.value == "500":
+#					overclk=12803
+#				elif config.plugins.systemoptions.stbyfreq.value == "540":
+#					overclk=4609
+#				elif config.plugins.systemoptions.stbyfreq.value == "600":
+#					overclk=5121
+#				elif config.plugins.systemoptions.stbyfreq.value == "630":
+#					overclk=5377
+#				elif config.plugins.systemoptions.stbyfreq.value == "650":
+#					overclk=16643
+#				elif config.plugins.systemoptions.stbyfreq.value == "700":
+#					overclk=17923
+#				elif config.plugins.systemoptions.stbyfreq.value == "710":
+#					overclk=18179
+#				elif config.plugins.systemoptions.stbyfreq.value == "750":
+#					overclk=19203
+#				elif config.plugins.systemoptions.stbyfreq.value == "775":
+#					overclk=39686
+#				elif config.plugins.systemoptions.stbyfreq.value == "800":
+#					overclk=20483
+#			else:
+#			overclk=4609
+#			print "STBY Clockspeed =", config.plugins.systemoptions.stbyfreq.value, "PLL = ", str(overclk)
+			open(pll0, 'w').write(str(overclk))
 
 		self.paused_service = self.paused_action = False
 
@@ -111,6 +150,9 @@
 			self.avswitch.setInput("SCART")
 		else:
 			self.avswitch.setInput("AUX")
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("off")
+#+++<
 
 		gotoShutdownTime = int(config.usage.standby_to_shutdown_timer.value)
 		if gotoShutdownTime:
@@ -164,6 +206,42 @@
 
 	def Power(self):
 		print "[Standby] leave standby"
+		if stb.lower() == 'spark' or stb.lower() == 'spark7162':
+			#apply CPU clock frequency
+#			if config.plugins.systemoptions.freq.value:
+#				if config.plugins.systemoptions.freq.value == "200":
+#					overclk=5123
+#				elif config.plugins.systemoptions.freq.value == "300":
+#					overclk=2561
+#				elif config.plugins.systemoptions.freq.value == "450":
+#					overclk=3841
+#				elif config.plugins.systemoptions.freq.value == "500":
+#					overclk=12803
+#				elif config.plugins.systemoptions.freq.value == "540":
+#					overclk=4609
+#				elif config.plugins.systemoptions.freq.value == "600":
+#					overclk=5121
+#				elif config.plugins.systemoptions.freq.value == "630":
+#					overclk=5377
+#				elif config.plugins.systemoptions.freq.value == "650":
+#					overclk=16643
+#				elif config.plugins.systemoptions.freq.value == "700":
+#					overclk=17923
+#				elif config.plugins.systemoptions.freq.value == "710":
+#					overclk=18179
+#				elif config.plugins.systemoptions.freq.value == "750":
+#					overclk=19203
+#				elif config.plugins.systemoptions.freq.value == "775":
+#					overclk=39686
+#				elif config.plugins.systemoptions.freq.value == "800":
+#					overclk=20483
+#			else:
+			overclk=4609
+#			print "Clockspeed =", config.plugins.systemoptions.freq.value, "PLL = ", str(overclk)
+			open(pll0, 'w').write(str(overclk))
+#+++>
+		open("/proc/stb/hdmi/output", "w").write("on")
+#+++<
 		self.close(True)
 
 	def setMute(self):
@@ -257,6 +333,7 @@
 			QUIT_RESTART: _("The user interface of your receiver is restarting"),
 			QUIT_UPGRADE_FP: _("Your frontprocessor will be updated\nPlease wait until your receiver reboots\nThis may take a few minutes"),
 			QUIT_DEBUG_RESTART: _("The user interface of your receiver is restarting in debug mode"),
+			10: _('Your receiver is rebooting to Spark now\nThis may take a while'),
 			QUIT_UPGRADE_PROGRAM: _("Unattended update in progress\nPlease wait until your receiver reboots\nThis may take a few minutes"),
 			QUIT_MANUFACTURER_RESET: _("Manufacturer reset in progress\nPlease wait until enigma2 restarts")
 		}.get(retvalue)
@@ -302,6 +381,7 @@
 				QUIT_RESTART: _("Really restart now?"),
 				QUIT_UPGRADE_FP: _("Really update the frontprocessor and reboot now?"),
 				QUIT_DEBUG_RESTART: _("Really restart in debug mode now?"),
+				10: _('Really reboot to Spark now?'),
 				QUIT_UPGRADE_PROGRAM: _("Really update your settop box and reboot now?"),
 				QUIT_MANUFACTURER_RESET: _("Really perform a manufacturer reset now?")
 			}.get(retvalue, None)
--- enigma2.org/lib/python/Screens/Wizard.py
+++ enigma2/lib/python/Screens/Wizard.py
@@ -13,6 +13,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 
 class WizardSummary(Screen):
@@ -352,6 +355,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -449,6 +455,9 @@
 			if "onselect" in self.wizard[self.currStep]:
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string(self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 
 	def resetCounter(self):
--- enigma2.org/lib/python/Tools/Command.py
+++ enigma2/lib/python/Tools/Command.py
@@ -0,0 +1,22 @@
+from os import stat as os_stat, path as os_path, system
+import os
+
+def command(comandline, strip=1):
+	comandline = comandline + " >/tmp/command.txt"
+	os.system(comandline)
+	text = ""
+	if os.path.exists("/tmp/command.txt") is True:
+		file = open("/tmp/command.txt", "r")
+		if strip == 1:
+			for line in file:
+				text = text + line.strip() + '\n'
+		else:
+			for line in file:
+				text = text + line
+				if text[-1:] != '\n': text = text + "\n"
+		file.close
+	if text[-1:] == '\n': text = text[:-1]
+	comandline = text
+	os.system("rm /tmp/command.txt")
+	return comandline
+
--- enigma2.org/lib/python/Tools/HardwareInfo.py
+++ enigma2/lib/python/Tools/HardwareInfo.py
@@ -9,7 +9,7 @@
 	device_model = None
 	device_version = ""
 	device_revision = ""
-	device_hdmi = False
+	device_hdmi = True
 
 	def __init__(self):
 		global hw_info
@@ -43,48 +43,19 @@
 			pass
 
 		# Model
-		for line in open((resolveFilename(SCOPE_SKIN, 'hw_info/hw_info.cfg')), 'r'):
-			if not line.startswith('#') and not line.isspace():
-				l = line.strip().replace('\t', ' ')
-				if ' ' in l:
-					infoFname, prefix = l.split()
-				else:
-					infoFname = l
-					prefix = ""
-				try:
-					self.device_model = prefix + open("/proc/stb/info/" + infoFname).read().strip()
-					break
-				except:
-					pass
+		try:
+			self.device_model = open("/proc/stb/info/boxtype").read().strip()
+		except:
+			pass
 
 		# standard values
 		self.device_model = self.device_model or self.device_name
 		self.device_hw = self.device_model
 		self.machine_name = self.device_model
+		self.device_string = self.device_model
+		self.device_hdmi =  self.device_model
 
-		# custom overrides for specific receivers
-		if self.device_model.startswith(("et9", "et4", "et5", "et6", "et7")):
-			self.machine_name = "%sx00" % self.device_model[:3]
-		elif self.device_model == "et11000":
-			self.machine_name = "et1x000"
-		elif self.device_brandname == "Zgemma":
-			if self.device_model and self.device_name and "H9Twin" in self.device_model and "combo" in self.device_name:
-				self.device_model = self.device_model.lower().replace(" ", "")
-			else:
-				self.device_model = self.device_name
-			self.machine_name = self.device_name
-
-		if self.device_revision:
-			self.device_string = "%s (%s-%s)" % (self.device_hw, self.device_revision, self.device_version)
-		elif self.device_version:
-			self.device_string = "%s (%s)" % (self.device_hw, self.device_version)
-		else:
-			self.device_string = self.device_hw
-
-		# only some early DMM boxes do not have HDMI hardware
-		self.device_hdmi = self.device_model not in ("dm800", "dm8000")
-
-		print "Detected: " + self.get_device_string()
+		print "[HardwareInfo] Detected: " + self.get_device_string()
 
 	def get_device_name(self):
 		return hw_info.device_name
--- enigma2.org/lib/python/Tools/Makefile.am
+++ enigma2/lib/python/Tools/Makefile.am
@@ -5,6 +5,6 @@
 	KeyBindings.py BoundFunction.py ISO639.py Notifications.py __init__.py \
 	RedirectOutput.py StbHardware.py Import.py Event.py CList.py CIHelper.py \
 	LoadPixmap.py Profile.py HardwareInfo.py Transponder.py ASCIItranslit.py \
-	Downloader.py Trashcan.py GetEcmInfo.py Alternatives.py TextBoundary.py \
+	Downloader.py Trashcan.py GetEcmInfo.py Alternatives.py TextBoundary.py Command.py \
 	camcontrol.py CountryCodes.py Multiboot.py FallbackTimer.py Hex2strColor.py \
 	Geolocation.py
--- enigma2.org/lib/python/Tools/Profile.py
+++ enigma2/lib/python/Tools/Profile.py
@@ -1,6 +1,7 @@
 # the implementation here is a bit crappy.
-import time
+import os, time
 from Directories import resolveFilename, SCOPE_CONFIG
+from enigma import evfd
 
 PERCENTAGE_START = 0
 PERCENTAGE_END = 100
@@ -21,12 +22,12 @@
 		total_time = t
 		profile_data[id] = t
 except:
-	print "no profile data available"
+	print "[Profile.py] no profile data available"
 
 try:
 	profile_file = open(resolveFilename(SCOPE_CONFIG, "profile"), "w")
 except IOError:
-	print "WARNING: couldn't open profile file!"
+	print "[Profile.py] WARNING: could not open profile file!"
 
 
 def profile(id):
@@ -42,7 +43,25 @@
 				perc = PERCENTAGE_START
 			try:
 				open("/proc/progress", "w").write("%d \n" % perc)
-			except IOError:
+				if perc > 1 and perc < 98:
+					value = 1
+					open("/proc/stb/lcd/symbol_circle", "w").write("%1d \n" % value)
+					if perc > 20:
+						if os.path.isfile('/proc/stb/info/model'):
+							model = str(open("/proc/stb/info/model").read())
+							if model.startswith("spark7162") or model.startswith("tf7700hdpvr") or model.startswith("hs9510") or model.startswith("fs9000") or model.startswith("hs8200") or model.startswith("hs7420") or model.startswith("hs7429") or model.startswith("vitamin-hd5000") or model.startswith("hl101") or model.startswith("vip1-v1") or model.startswith("vip1-v2") or model.startswith("vip2"):
+								evfd.getInstance().vfd_write_string("START %02d" % perc)
+							elif model.startswith("cuberevo") or model.startswith("cuberevo_mini") or model.startswith("cuberevo_mini2") or model.startswith("cuberevo_2000hd") or model.startswith("cuberevo_3000hd") or model.startswith("cuberevo_9500hd") or model.startswith("hchs8100"):
+								evfd.getInstance().vfd_write_string("E2 Start %02d%%" % perc)
+							elif model.startswith("ufs912") or model.startswith("ufs913"):
+								evfd.getInstance().vfd_write_string("Enigma2 START %02d" % perc)
+							elif model.startswith("spark") or model.startswith("hs7119") or model.startswith("hs7810a") or model.startswith("hs7819") or model.startswith("cuberevo_250hd") or model.startswith("cuberevo_mini_fta"):
+								evfd.getInstance().vfd_write_string("St%02d" % perc)
+				elif perc > 98:
+					value = 0
+					open("/proc/stb/lcd/symbol_circle", "w").write("%1d \n" % value)
+					evfd.getInstance().vfd_write_string("        ")
+ 			except IOError:
 				pass
 
 
--- enigma2.org/lib/service/iservice.h
+++ enigma2/lib/service/iservice.h
@@ -699,6 +699,7 @@
 struct eDVBTeletextSubtitlePage;
 struct eDVBSubtitlePage;
 struct ePangoSubtitlePage;
+struct eVobSubtitlePage;  // added for servicemp3epl
 class eRect;
 class gRegion;
 class gPixmap;
@@ -710,6 +711,7 @@
 	virtual void setPage(const eDVBTeletextSubtitlePage &p) = 0;
 	virtual void setPage(const eDVBSubtitlePage &p) = 0;
 	virtual void setPage(const ePangoSubtitlePage &p) = 0;
+	virtual void setPage(const eVobSubtitlePage &p) = 0;  // added for servicemp3epl
 	virtual void setPixmap(ePtr<gPixmap> &pixmap, gRegion changed, eRect dest) = 0;
 	virtual void destroy() = 0;
 };
--- enigma2.org/lib/service/listboxservice.cpp
+++ enigma2/lib/service/listboxservice.cpp
@@ -204,14 +204,14 @@
 	{
 		--i;
 		--index;
-		if (!(i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible)))
+		if (! ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible)))
 			break;
 	}
 	while (index)
 	{
 		--i;
 		--index;
-		if (i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible))
+		if ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible))
 			break;
 	}
 	return cursorResolve(index);
@@ -227,7 +227,7 @@
 	{
 		++i;
 		++index;
-		if (i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible))
+		if ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible))
 			break;
 	}
 	return cursorResolve(index);
--- enigma2.org/lib/service/servicedvb.cpp
+++ enigma2/lib/service/servicedvb.cpp
@@ -649,6 +649,8 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+//Topfield original recording extension
+		extensions.push_back("rec");
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
@@ -1222,7 +1224,8 @@
 		break;
 	}
 	case eDVBServicePMTHandler::eventPreStart:
-		loadCuesheet();
+		if (!m_is_stream)
+			 loadCuesheet();
 		break;
 	case eDVBServicePMTHandler::eventEOF:
 		m_event((iPlayableService*)this, evEOF);
@@ -1375,6 +1378,8 @@
 			scrambled = true;
 
 		type = eDVBServicePMTHandler::streamclient;
+		//will skip on calling findPMT() for streams, as it is not needed
+		service.setServiceID(eServiceFactoryDVB::id);
 	}
 
 	m_first_program_info = 1;
@@ -1747,9 +1752,9 @@
 				return -2;
 			}
 
-			if (((off_t)fs.f_bavail) * ((off_t)fs.f_bsize) < 200*1024*1024LL)
-			{
-				eDebug("[eDVBServicePlay] timeshift not enough diskspace for timeshift! (less than 200MB)");
+			if (((off_t)fs.f_bavail) * ((off_t)fs.f_bsize) < 1024 * 1024 * 1024LL)
+			{
+				eDebug("[eDVBServicePlay] timeshift: not enough diskspace for timeshift! (less than 1 GB)");
 				return -3;
 			}
 		}
--- enigma2.org/lib/service/servicedvbrecord.cpp
+++ enigma2/lib/service/servicedvbrecord.cpp
@@ -10,6 +10,9 @@
 	/* for cutlist */
 #include <byteswap.h>
 #include <netinet/in.h>
+
+#include <sys/vfs.h>
+#include <linux/magic.h>
 
 DEFINE_REF(eDVBServiceRecord);
 
@@ -291,9 +294,40 @@
 
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE|O_CLOEXEC;
+		struct statfs sbuf;
+
 		eDebug("[eDVBServiceRecord] Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
-		int fd = ::open(m_filename.c_str(), O_WRONLY | O_CREAT | O_LARGEFILE | O_CLOEXEC, 0666);
+		//we must create a file for statfs
+		int fd = ::open(m_filename.c_str(), flags, 0666);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0)
+		{
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!");
+		}
+		else if (sbuf.f_type == EXT3_SUPER_MAGIC)
+		{
+			eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n");
+		}
+		else if (sbuf.f_type == NFS_SUPER_MAGIC)
+		{
+			eDebug("[eDVBServiceRecord] NFS Filesystem; add O_DIRECT to flags\n");
+			flags |= O_DIRECT;
+		}
+		else if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+		{
+			eDebug("[eDVBServiceRecord] USB Device\n");
+		}
+		else if (sbuf.f_type == SMB_SUPER_MAGIC)
+		{
+			eDebug("[eDVBServiceRecord] SMBs Device\n");
+		}
+		else if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+		{
+			eDebug("[eDVBServiceRecord] MSDOS Device\n");
+		}
+		fd = ::open(m_filename.c_str(), flags, 0666);
 		if (fd == -1)
 		{
 			eDebug("[eDVBServiceRecord] can't open recording file: %m");
--- enigma2.org/m4/ax_python_devel.m4
+++ enigma2/m4/ax_python_devel.m4
@@ -158,9 +158,9 @@
 			print (distutils.sysconfig.get_python_inc (plat_specific=1));"`
 		if test -n "${python_path}"; then
 			if test "${plat_python_path}" != "${python_path}"; then
-				python_path="-I$python_path -I$plat_python_path"
+				python_path="-I$PY_PATH/include/python$PYTHON_VER_MAJOR -I$plat_python_path"
 			else
-				python_path="-I$python_path"
+				python_path="-I$PY_PATH/include/python$PYTHON_VER_MAJOR"
 			fi
 		fi
 		PYTHON_CPPFLAGS=$python_path
@@ -234,7 +234,8 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LIBS="-L$ac_python_libdir -lpython$ac_python_version"
+#			PYTHON_LIBS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LIBS="-L$PY_PATH/lib/python$PYTHON_VER_MAJOR -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LIBS"; then
@@ -252,8 +253,9 @@
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH/lib/python$PYTHON_VER_MAJOR/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
--- enigma2.org/main/bsod.cpp
+++ enigma2/main/bsod.cpp
@@ -16,11 +16,13 @@
 
 /************************************************/
 
+#if 0
 static const char *crash_emailaddr =
 #ifndef CRASH_EMAILADDR
 	"the OpenPLi forum";
 #else
 	CRASH_EMAILADDR;
+#endif
 #endif
 
 /* Defined in bsod.cpp */
@@ -100,7 +102,14 @@
 {
 	/* show no more than one bsod while shutting down/crashing */
 	if (bsodhandled)
+	{
+		if (component)
+		{
+			sleep(1);
+			raise(SIGKILL);
+		}
 		return;
+	}
 	bsodhandled = true;
 
 	if (!component)
@@ -167,7 +176,6 @@
 			component);
 
 		stringFromFile(f, "stbmodel", "/proc/stb/info/boxtype");
-		stringFromFile(f, "stbmodel", "/proc/stb/info/vumodel");
 		stringFromFile(f, "stbmodel", "/proc/stb/info/model");
 		stringFromFile(f, "kernelcmdline", "/proc/cmdline");
 		stringFromFile(f, "nimsockets", "/proc/bus/nim_sockets");
@@ -193,7 +201,7 @@
 	gPainter p(my_dc);
 	p.resetOffset();
 	p.resetClip(eRect(ePoint(0, 0), my_dc->size()));
-	p.setBackgroundColor(gRGB(0x008000));
+	p.setBackgroundColor(gRGB(0x000080));
 	p.setForegroundColor(gRGB(0xFFFFFF));
 
 	int hd =  my_dc->size().width() == 1920;
@@ -207,14 +215,14 @@
 	os.clear();
 	os << "We are really sorry. Your STB encountered "
 		"a software problem, and needs to be restarted.\n"
-		"Please send the logfile " << crashlog_name << " to " << crash_emailaddr << ".\n"
-		"Your STB restarts in 10 seconds!\n"
+		"Details have been logged in the logfile " << crashlog_name << ".\n"
+		"Your STB will restart in 30 seconds...\n"
 		"Component: " << component;
 
 	p.renderText(usable_area, os.str().c_str(), gPainter::RT_WRAP|gPainter::RT_HALIGN_LEFT);
 
 	std::string logtail;
-	int lines = 20;
+	int lines = 35;
 	
 	if (logp2)
 	{
@@ -258,12 +266,12 @@
 
 	if (!logtail.empty())
 	{
-		font = new gFont("Regular", hd ? 21 : 14);
+		font = new gFont("Regular", hd ? 14 : 10);
 		p.setFont(font);
 		usable_area = eRect(hd ? 30 : 100, hd ? 180 : 170, my_dc->size().width() - (hd ? 60 : 180), my_dc->size().height() - (hd ? 30 : 20));
 		p.renderText(usable_area, logtail, gPainter::RT_HALIGN_LEFT);
 	}
-	sleep(10);
+	sleep(30);
 
 	/*
 	 * When 'component' is NULL, we are called because of a python exception.
--- enigma2.org/main/enigma.cpp
+++ enigma2/main/enigma.cpp
@@ -31,6 +31,7 @@
 #include <lib/python/python.h>
 #include <lib/python/pythonconfig.h>
 #include <lib/service/servicepeer.h>
+#include <lib/driver/vfd.h> // vfd class
 
 #include "bsod.h"
 #include "version_info.h"
@@ -204,7 +205,7 @@
 	printf("DVB_API_VERSION %d DVB_API_VERSION_MINOR %d\n", DVB_API_VERSION, DVB_API_VERSION_MINOR);
 
 	// get enigma2 debug level settings
-	debugLvl = getenv("ENIGMA_DEBUG_LVL") ? atoi(getenv("ENIGMA_DEBUG_LVL")) : 3;
+	debugLvl = getenv("ENIGMA_DEBUG_LVL") ? atoi(getenv("ENIGMA_DEBUG_LVL")) : 4;
 	if (debugLvl < 0)
 		debugLvl = 0;
 	printf("ENIGMA_DEBUG_LVL=%d\n", debugLvl);
@@ -235,6 +236,12 @@
 	eWidgetDesktop dsk_lcd(my_lcd_dc->size());
 
 	dsk.setStyleID(0);
+
+#ifdef HAVE_GRAPHLCD
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 320 ? 1 : 2);
+#else
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 96 ? 2 : 1);
+#endif
 	dsk_lcd.setStyleID(1);
 
 /*	if (double_buffer)
@@ -279,16 +286,20 @@
 				break;
 			}
 		}
-		eDebug("[MAIN] found %d spinner!", i);
+		eDebug("[MAIN] found %d spinners.", i);
 		if (i)
-			my_dc->setSpinner(eRect(ePoint(100, 100), wait[0]->size()), wait, i);
+			my_dc->setSpinner(eRect(ePoint(50, 50), wait[0]->size()), wait, i);
 		else
-			my_dc->setSpinner(eRect(100, 100, 0, 0), wait, 1);
+			my_dc->setSpinner(eRect(50, 50, 0, 0), wait, 1);
 	}
 
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
 	eRCInput::getInstance()->keyEvent.connect(sigc::ptr_fun(&keyEvent));
+// initialise the vfd class
+	evfd * vfd = new evfd;
+	vfd->init();
+	delete vfd;
 
 	printf("[MAIN] executing main\n");
 
--- enigma2.org/main/Makefile.am
+++ enigma2/main/Makefile.am
@@ -8,6 +8,8 @@
 	$(LIBSDL_CFLAGS)
 
 bin_PROGRAMS = enigma2
+
+installdir = $(targetprefix)/usr/local/bin
 
 enigma2_SOURCES = \
 	bsod.cpp \
@@ -45,7 +47,12 @@
 	@ALSA_LIBS@ \
 	@AVAHI_LIBS@ \
 	@LIBDL_LIBS@ \
-	-ltuxtxt32bpp
+	-ltuxtxt32bpp \
+	-lpthread -lresolv -lmmeimage
+
+if HAVE_GRAPHLCD
+enigma2_LDADD += -lglcddrivers -lglcdgraphics -lglcdskin
+endif
 
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
--- enigma2.org/tools/enigma2.sh.in
+++ enigma2/tools/enigma2.sh.in
@@ -3,6 +3,29 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 datarootdir=@datarootdir@
+
+if [ -e @libdir@/enigma2/python/Plugins/SystemPlugins/SH4BoosterControl/plugin.pyo ]; then
+	cpufreq=`cat /etc/enigma2/settings | grep config.plugins.booster.normalfrequenz | cut -d "=" -f2`
+	case $cpufreq in
+		200) overclk=5123;;
+		300) overclk=2561;;
+		450) overclk=3841;;
+		500) overclk=12803;;
+		540) overclk=4609;;
+		600) overclk=5121;;
+		630) overclk=5377;;
+		650) overclk=16643;;
+		700) overclk=17923;;
+		710) overclk=18179;;
+		750) overclk=19203;;
+		775) overclk=39686;;
+		800) overclk=20483;;
+		*) cpufreq=450
+		overclk=3841;;
+	esac
+	echo $overclk > /proc/cpu_frequ/pll0_ndiv_mdiv
+	echo "[enigma2] Setting CPU clock speed to $cpufreq MHz (overclk=$overclk)"
+fi
 
 if [ -d /home/root ]; then
 	export HOME=/home/root
--- enigma2.org/lib/python/Screens/About.py
+++ enigma2/lib/python/Screens/About.py
@@ -14,6 +14,8 @@
 from Components.ProgressBar import ProgressBar
 
 from Tools.StbHardware import getFPVersion
+from Tools.Directories import fileExists, pathExists
+from Tools.HardwareInfo import HardwareInfo
 from enigma import eTimer, eLabel, eConsoleAppContainer, getDesktop, eGetEnigmaDebugLvl
 
 from Components.GUIComponent import GUIComponent
@@ -30,6 +32,16 @@
 		hddsplit = parameters.get("AboutHddSplit", 1)
 
 		AboutText = _("Hardware: ") + about.getHardwareTypeString() + "\n"
+		if fileExists("/proc/stb/info/brand") and fileExists("/proc/stb/info/model_name"):
+			brandname = open("/proc/stb/info/brand", "r").read().strip()
+			modelname = open("/proc/stb/info/model_name", "r").read().strip()
+			AboutText += _("Model name: ") + brandname + _(" ") + modelname + "\n"
+		if fileExists("/proc/stb/fp/resellerID"):
+			resellerid = open("/proc/stb/fp/resellerID", "r").read().strip()
+			AboutText += _("Reseller ID: ") + resellerid + "\n"
+		if fileExists("/proc/stb/info/adb_variant"):
+			adbvariant = open("/proc/stb/info/adb_variant", "r").read().strip().upper()
+			AboutText += _("ADB variant: ") + adbvariant + "\n"
 		cpu = about.getCPUInfoString()
 		AboutText += _("CPU: ") + cpu + "\n"
 		AboutText += _("Image: ") + about.getImageTypeString() + "\n"
@@ -53,27 +65,17 @@
 
 		AboutText += _("DVB driver version: ") + about.getDriverInstalledDate() + "\n"
 
-		GStreamerVersion = about.getGStreamerVersionString().replace("GStreamer", "")
+		GStreamerVersion = about.getGStreamerVersionString()
 		self["GStreamerVersion"] = StaticText(GStreamerVersion)
 
 		ffmpegVersion = about.getffmpegVersionString()
 		self["ffmpegVersion"] = StaticText(ffmpegVersion)
 
-		player = None
-		if cpu.upper().startswith('HI') or os.path.isdir('/proc/hisi'):
-			if os.path.isdir("/usr/lib/hisilicon") and glob.glob("/usr/lib/hisilicon/libavcodec.so.*"):
-				player = _("Media player") + ": ffmpeg, " + _("Hardware Accelerated")
-			elif ffmpegVersion and ffmpegVersion[0].isdigit():
-				player = _("Media player") + ": ffmpeg, " + _("version") + " " + ffmpegVersion
-
-		if player is None:
-			if GStreamerVersion:
-				player = _("Media player") + ": Gstreamer, " + _("version") + " " + GStreamerVersion
-			else:
-				player = _("Media player") + ": " + _("Not Installed")
-
-		AboutText += player + "\n"
-
+		AboutText += _("Media framework: ") + GStreamerVersion + "\n"
+
+		if ffmpegVersion and ffmpegVersion[0].isdigit():
+			AboutText += _("FFmpeg version: ") + ffmpegVersion + "\n"
+	
 		AboutText += _("Python version: ") + about.getPythonVersionString() + "\n"
 
 		AboutText += _("Enigma (re)starts: %d\n") % config.misc.startCounter.value
@@ -84,7 +86,14 @@
 		if fp_version is None:
 			fp_version = ""
 		elif fp_version != 0:
-			fp_version = _("Frontprocessor version: %s") % fp_version
+			model = HardwareInfo().get_device_model()
+			if fileExists("/proc/stb/fp/resellerID") and (model != "atemio520"):
+				fp_version = _("Loader version: %d.%02d") % (fp_version / 100, fp_version % 100)
+			else:
+				if (model in ("cuberevo", "cuberevo_mini-fta", "cuberevo-250hd", "cuberevo-mini", "cuberevo-mini2", "cuberevo-2000hd", "cuberevo-3000hd", "cuberevo-9500hd")):
+					fp_version = _("Frontprocessor version: %s") % fp_version
+				else:
+					fp_version = _("Frontprocessor version: %d.%02d") % (fp_version / 100, fp_version % 100)
 			AboutText += fp_version + "\n"
 
 		self["FPVersion"] = StaticText(fp_version)
--- enigma2.org/lib/python/Tools/StbHardware.py
+++ enigma2/lib/python/Tools/StbHardware.py
@@ -2,12 +2,16 @@
 from fcntl import ioctl
 from struct import pack, unpack
 from time import time, localtime, gmtime
-
+from Tools.HardwareInfo import HardwareInfo
 
 def getFPVersion():
 	ret = None
+	model = HardwareInfo().get_device_model()
 	try:
-		ret = long(open("/proc/stb/fp/version", "r").read())
+		if (model in ("cuberevo", "cuberevo_mini-fta", "cuberevo-250hd", "cuberevo-mini", "cuberevo-mini2", "cuberevo-2000hd", "cuberevo-3000hd", "cuberevo-9500hd")):
+			ret = open("/proc/stb/fp/version", "r").read()
+		else:
+			ret = long(open("/proc/stb/fp/version", "r").read())
 	except IOError:
 		try:
 			fp = open("/dev/dbox/fp0")
--- enigma2.org/lib/python/Tools/KeyBindings.py
+++ enigma2/lib/python/Tools/KeyBindings.py
@@ -220,122 +220,570 @@
 	KEYIDS["KEY_POWER2"]: ("POWER2",),
 	KEYIDS["KEY_SUSPEND"]: ("SUSPEND",),
 	KEYIDS["KEY_WAKEUP"]: ("WAKEUP",)
-}, {  # id=3 - XP1000.
-	# The xp1000/rcpositions file defines PLAY and PAUSE
-	# at the same location where it should just define
-	# PLAYPAUSE there. It has similar overlayed incorrect
-	# definitions for play & pause rather than play/pause
-	# in remote.html.
-	KEYIDS["BTN_0"]: ("UP", "fp"),
-	KEYIDS["BTN_1"]: ("DOWN", "fp"),
-	KEYIDS["KEY_0"]: ("0",),
-	KEYIDS["KEY_1"]: ("1",),
-	KEYIDS["KEY_2"]: ("2",),
-	KEYIDS["KEY_3"]: ("3",),
-	KEYIDS["KEY_4"]: ("4",),
-	KEYIDS["KEY_5"]: ("5",),
-	KEYIDS["KEY_6"]: ("6",),
-	KEYIDS["KEY_7"]: ("7",),
-	KEYIDS["KEY_8"]: ("8",),
-	KEYIDS["KEY_9"]: ("9",),
-	KEYIDS["KEY_AUDIO"]: ("AUDIO",),
-	KEYIDS["KEY_BLUE"]: ("BLUE",),
-	KEYIDS["KEY_BOOKMARKS"]: ("PORTAL",),
-	KEYIDS["KEY_CHANNELDOWN"]: ("BOUQUET-",),
-	KEYIDS["KEY_CHANNELUP"]: ("BOUQUET+",),
-	KEYIDS["KEY_DOWN"]: ("DOWN",),
-	KEYIDS["KEY_EPG"]: ("EPG",),
-	KEYIDS["KEY_EXIT"]: ("EXIT",),
-	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
-	KEYIDS["KEY_GREEN"]: ("GREEN",),
-	KEYIDS["KEY_HELP"]: ("HELP",),
-	KEYIDS["KEY_INFO"]: ("INFO",),
-	KEYIDS["KEY_LEFT"]: ("LEFT",),
-	KEYIDS["KEY_MENU"]: ("MENU",),
-	KEYIDS["KEY_MUTE"]: ("MUTE",),
-	KEYIDS["KEY_NEXT"]: ("ARROWRIGHT",),
-	KEYIDS["KEY_NEXTSONG"]: ("NEXTSONG",),
-	KEYIDS["KEY_OK"]: ("OK",),
-	KEYIDS["KEY_PLAY"]: ("PLAY",),
-	KEYIDS["KEY_PLAYPAUSE"]: ("PLAYPAUSE",),
-	KEYIDS["KEY_POWER"]: ("POWER",),
-	KEYIDS["KEY_PREVIOUS"]: ("ARROWLEFT",),
-	KEYIDS["KEY_PREVIOUSSONG"]: ("PREVIOUSSONG",),
-	KEYIDS["KEY_PROGRAM"]: ("TIMER",),
-	KEYIDS["KEY_RADIO"]: ("RADIO",),
-	KEYIDS["KEY_RECORD"]: ("RECORD",),
-	KEYIDS["KEY_RED"]: ("RED",),
-	KEYIDS["KEY_REWIND"]: ("REWIND",),
-	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
-	KEYIDS["KEY_SLEEP"]: ("SLEEP",),
-	KEYIDS["KEY_STOP"]: ("STOP",),
-	KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
-	KEYIDS["KEY_SWITCHVIDEOMODE"]: ("VMODE",),
-	KEYIDS["KEY_TEXT"]: ("TEXT",),
-	KEYIDS["KEY_TV"]: ("TV",),
-	KEYIDS["KEY_UP"]: ("UP",),
-	KEYIDS["KEY_VIDEO"]: ("PVR",),
-	# KEYIDS["KEY_VMODE"]: ("VMODE",),  # This value is deprecated use KEY_SWITCHVIDEOMODE instead.
+}, {  # id=3 - Spark HOF-12D
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_SWITCHVIDEOMODE"]: ("V.FORMAT",),
+	KEYIDS["KEY_AUX"]: ("TV/SAT",),
+	KEYIDS["KEY_PROGRAM"]: ("TIME",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_CHANNELUP"]: ("PAGE+",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("PAGE-",),
+	KEYIDS["KEY_SUBTITLE"]: ("FIND",),
+	KEYIDS["KEY_FILE"]: ("FOLDER",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOL+",),
 	KEYIDS["KEY_VOLUMEDOWN"]: ("VOL-",),
-	KEYIDS["KEY_VOLUMEUP"]: ("VOL+",),
-	KEYIDS["KEY_YELLOW"]: ("YELLOW",)
-}, {  # id=4 - Formuler F1/F3.
-	# The formuler1 rcpositions file seems to define
-	# the FF and REW keys as FASTFORWARD and KEY_REWIND,
-	# but the remote.xml file issues KEY_PREVIOUSSONG
-	# and KEY_NEXTSONG.
-	KEYIDS["BTN_0"]: ("UP", "fp"),
-	KEYIDS["BTN_1"]: ("DOWN", "fp"),
-	KEYIDS["KEY_0"]: ("0",),
-	KEYIDS["KEY_1"]: ("1",),
-	KEYIDS["KEY_2"]: ("2",),
-	KEYIDS["KEY_3"]: ("3",),
-	KEYIDS["KEY_4"]: ("4",),
-	KEYIDS["KEY_5"]: ("5",),
-	KEYIDS["KEY_6"]: ("6",),
-	KEYIDS["KEY_7"]: ("7",),
-	KEYIDS["KEY_8"]: ("8",),
-	KEYIDS["KEY_9"]: ("9",),
-	KEYIDS["KEY_AUDIO"]: ("AUDIO",),
-	KEYIDS["KEY_BACK"]: ("RECALL",),
-	KEYIDS["KEY_BLUE"]: ("BLUE",),
-	KEYIDS["KEY_BOOKMARKS"]: ("PLAYLIST",),
-	KEYIDS["KEY_CHANNELDOWN"]: ("BOUQUET-",),
-	KEYIDS["KEY_CHANNELUP"]: ("BOUQUET+",),
-	KEYIDS["KEY_CONTEXT_MENU"]: ("CONTEXT",),
-	KEYIDS["KEY_DOWN"]: ("DOWN",),
-	KEYIDS["KEY_EPG"]: ("EPG",),
-	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_OK"]: ("OK", ""),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_SAT"]: ("SAT",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREV",),
+	KEYIDS["KEY_NEXT"]: ("NEXT",),
+	KEYIDS["KEY_F"]: ("FAST",),
+	KEYIDS["KEY_SLOW"]: ("SLOW",),
+	KEYIDS["KEY_P"]: ("PLAY_MODE",),
+	KEYIDS["KEY_MEDIA"]: ("USB",),
+	KEYIDS["KEY_TIME"]: ("Tms",),
 	KEYIDS["KEY_F1"]: ("F1",),
 	KEYIDS["KEY_F2"]: ("F2",),
 	KEYIDS["KEY_F3"]: ("F3",),
-	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_OPEN"]: ("PORTAL",)
+}, {  # id=4 - All Fortis
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_POWER"]: ("STANDBY",),
+	KEYIDS["KEY_ZOOM"]: ("V.FORMAT",),
+	KEYIDS["KEY_SWITCHVIDEOMODE"]: ("RESOLUTION",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHANNELUP",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHANNELDOWN",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_PAGEUP"]: ("PAGEUP",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_PAGEDOWN"]: ("PAGEDOWN",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREVIOUS",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_NEXT"]: ("NEXT",),
+	KEYIDS["KEY_FILE"]: ("PLAYLIST",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_HELP"]: ("CHECK",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_SCREEN"]: ("PIP",),
+	KEYIDS["KEY_GOTO"]: ("PIP_SWAP",),
+	KEYIDS["KEY_AUX"]: ("PIP_LIST",), # PIP list
+	KEYIDS["KEY_PROGRAM"]: ("SLEEP",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_TV2"]: ("TVRADIO",),
+	KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+}, {  # id=5 - Topfield TF77X0HDPVR
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_SWITCHVIDEOMODE"]: ("V.FORMAT",),
+	KEYIDS["KEY_ZOOM"]: ("A/R",),
+	KEYIDS["KEY_AUX"]: ("AUX",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_BACK"]: ("BACK",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_AUDIO"]: ("AUDIO",),
+	KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_EPG"]: ("GUIDE",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_SLOW"]: ("SLOW",),
+	KEYIDS["KEY_FILE"]: ("LIST" ,),
+	KEYIDS["KEY_SAT"]: ("SAT",),
+	KEYIDS["KEY_PREVIOUS"]: ("STEPBACK",),
+	KEYIDS["KEY_NEXT"]: ("STEPFORWARD",),
+	KEYIDS["KEY_SCREEN"]: ("MARK",),
+	KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+	KEYIDS["KEY_MEDIA"]: ("USB",),
+	KEYIDS["KEY_PROGRAM"]: ("TIMER",),
+}, {  # id=6 - Kathrein UFS912, UFS913
+	KEYIDS["KEY_HELP"]: ("HELP",),
+	KEYIDS["KEY_TV2"]: ("TVRADIO",),
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHANNELUP",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHANNELDOWN",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_FILE"]: ("ARCHIV",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_MEDIA"]: ("MEDIA",),
+	KEYIDS["KEY_WWW"]: ("PORTAL",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+}, {  # id=7 - Cuberevo standard & universal
+	KEYIDS["KEY_F1"]: ("KEY_F1",),
+	KEYIDS["KEY_F2"]: ("KEY_F2",),
+	KEYIDS["KEY_F3"]: ("KEY_F3",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_RADIO"]: ("RADIO",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREVIOUS",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
 	KEYIDS["KEY_FAVORITES"]: ("FAVORITES",),
-	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_MEDIA"]: ("MEDIA",),
+	KEYIDS["KEY_POWER"]: ("STANDBY",),
+	KEYIDS["KEY_F5"]: ("KEY_F5",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_ARCHIVE"]: ("ARCHIVE",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_SLOW"]: ("SLOW",),
+	KEYIDS["KEY_AGAIN"]: ("AGAIN",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_F7"]: ("KEY_F7",),
+	KEYIDS["KEY_BOOKMARKS"]: ("KEY_BOOMARKS",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_F8"]: ("KEY_F8",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_AUDIO"]: ("AUDIO",),
+	KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHANNELUP",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHANNELDOWN",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+	KEYIDS["KEY_WWW"]: ("WWW",)
+}, {  # id=8 - Vitamin HD5000
+	KEYIDS["KEY_AUX"]: ("TV/STB",),
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+	KEYIDS["KEY_SUBTITLE"]: ("SUBTITLE",),
+	KEYIDS["KEY_F3"]: ("SIGNAL",),
+	KEYIDS["KEY_PROGRAM"]: ("CAPTURE",),
+	KEYIDS["KEY_F5"]: ("BOOK/M",),
+	KEYIDS["KEY_SCREEN"]: ("BOOK/J",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREVIOUS",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_NEXT"]: ("NEXT",),
+	KEYIDS["KEY_AGAIN"]: ("REPEAT",),
+	KEYIDS["KEY_PLAY"]: ("PLAY/PAUSE",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHUP",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUP",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHDOWN",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLDOWN",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_SAT"]: ("SAT",),
+	KEYIDS["KEY_WWW"]: ("MOSAIC",),
+	KEYIDS["KEY_F11"]: ("FEED",),
+	KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+	KEYIDS["KEY_FILE"]: ("PLAYLIST",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_F1"]: ("F1",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_F2"]: ("F2",)
+}, {  # id=9 - ADB XMP
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_MEDIA"]: ("VOD",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_HOME"]: ("HOME",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_TIME"]: ("APP",),
+	KEYIDS["KEY_SUBTITLE"]: ("OPT",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHUP",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHDOWN",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_EXIT"]: ("BACK",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_TV2"]: ("ATSIGN",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+	KEYIDS["KEY_FILE"]: ("LIST",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_MENU"]: ("SETUP",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_HELP"]: ("STAR",)
+}, {  # id=10 - Pace HDS7241
+}, {  # id=11 - VIP2
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_SWITCHVIDEOMODE"]: ("V.FORMAT",),
+	KEYIDS["KEY_PROGRAM"]: ("TIME",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_TIME"]: ("Tms",),
+	KEYIDS["KEY_SCREEN"]: ("PIP",),
+	KEYIDS["KEY_F1"]: ("F1",),
+	KEYIDS["KEY_AUX"]: ("TV/SAT",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_SUBTITLE"]: ("FIND",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOL-",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("PAGEDOWN",),
+	KEYIDS["KEY_SAT"]: ("SAT",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOL+",),
+	KEYIDS["KEY_CHANNELUP"]: ("PAGEUP",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_HOME"]: ("EXIT",),
+	KEYIDS["KEY_EPG"]: ("EDIVISION",),
+	KEYIDS["KEY_FILE"]: ("FOLDER",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREVIOUS",),
+	KEYIDS["KEY_NEXT"]: ("NEXT",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_SLOW"]: ("STEP_BACK",),
+	KEYIDS["KEY_F"]: ("STEP_FWD",),
+	KEYIDS["KEY_W"]: ("PLAYMODE",),
+	KEYIDS["KEY_MEDIA"]: ("USB",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",)
+}, {  # id=12 - HL101
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_TIME"]: ("PROGRAM",),
+	KEYIDS["KEY_U"]: ("U",),
+	KEYIDS["KEY_ZOOM"]: ("V.FORMAT",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_AUX"]: ("TV/SAT",),
+	KEYIDS["KEY_TV2"]: ("TV/RADIO",),
+	KEYIDS["KEY_FIND"]: ("FIND",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_HOME"]: ("EXIT",),
+	KEYIDS["KEY_UP"]: ("UP/P+",),
+	KEYIDS["KEY_LEFT"]: ("LEFT/V-",),
+	KEYIDS["KEY_OK"]: ("OK/LIST",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT/V+",),
+	KEYIDS["KEY_DOWN"]: ("DOWN/P-",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_SLOW"]: ("SLOW",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREVIOUS",),
+	KEYIDS["KEY_NEXT"]: ("NEXT",),
+	KEYIDS["KEY_FILE"]: ("ARCHIVE",),
+	KEYIDS["KEY_OPTION"]: ("PIPSWAP",),
+	KEYIDS["KEY_W"]: ("PLAYMODE",),
+	KEYIDS["KEY_MEDIA"]: ("USB",),
+	KEYIDS["KEY_AUDIO"]: ("AUDIO",),
+	KEYIDS["KEY_SAT"]: ("SAT",),
+	KEYIDS["KEY_F1"]: ("F1",),
+	KEYIDS["KEY_F2"]: ("F2",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+}, {  # id=13 - Opticum HD 9600 series, Atemio AM 520 HD
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
 	KEYIDS["KEY_HELP"]: ("HELP",),
-	KEYIDS["KEY_INFO"]: ("INFO",),
-	KEYIDS["KEY_LEFT"]: ("LEFT",),
-	KEYIDS["KEY_MENU"]: ("MENU",),
-	KEYIDS["KEY_MUTE"]: ("MUTE",),
-	KEYIDS["KEY_NEXT"]: ("ARROWRIGHT",),
-	KEYIDS["KEY_OK"]: ("OK",),
-	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
-	KEYIDS["KEY_PLAY"]: ("PLAY",),
-	KEYIDS["KEY_POWER"]: ("POWER",),
-	KEYIDS["KEY_PREVIOUS"]: ("ARROWLEFT",),
-	KEYIDS["KEY_RADIO"]: ("RADIO",),
-	KEYIDS["KEY_RECORD"]: ("RECORD",),
-	KEYIDS["KEY_RED"]: ("RED",),
-	KEYIDS["KEY_REWIND"]: ("REWIND",),
-	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
-	KEYIDS["KEY_STOP"]: ("STOP",),
-	KEYIDS["KEY_TEXT"]: ("TEXT",),
-	KEYIDS["KEY_TV"]: ("TV",),
-	KEYIDS["KEY_UP"]: ("UP",),
-	KEYIDS["KEY_VIDEO"]: ("PVR",),
-	KEYIDS["KEY_VOLUMEDOWN"]: ("VOL-",),
-	KEYIDS["KEY_VOLUMEUP"]: ("VOL+",),
-	KEYIDS["KEY_YELLOW"]: ("YELLOW",)
+	KEYIDS["KEY_SWITCHVIDEOMODE"]: ("MODE",),
+	KEYIDS["KEY_TV2"]: ("TVRADIO",),
+#	KEYIDS["KEY_MODE"]: ("MODE",),
+	KEYIDS["KEY_1"]: ("1",),
+	KEYIDS["KEY_2"]: ("2",),
+	KEYIDS["KEY_3"]: ("3",),
+	KEYIDS["KEY_4"]: ("4",),
+	KEYIDS["KEY_5"]: ("5",),
+	KEYIDS["KEY_6"]: ("6",),
+	KEYIDS["KEY_7"]: ("7",),
+	KEYIDS["KEY_8"]: ("8",),
+	KEYIDS["KEY_9"]: ("9",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_0"]: ("0",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_PLAYPAUSE"]: ("PLAY_PAUSE",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_FILE"]: ("FILELIST",),
+	KEYIDS["KEY_SLOW"]: ("STEP_FWD",),
+	KEYIDS["KEY_PREVIOUS"]: ("PREVIOUS",),
+	KEYIDS["KEY_NEXT"]: ("NEXT",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_FAVORITES"]: ("FAV",),
+	KEYIDS["KEY_PROGRAM"]: ("STATUS",),
+	KEYIDS["KEY_OPTION"]: ("OPTION",),
+	KEYIDS["KEY_SUBTITLE"]: ("FIND",),
+# Additions for AM 520 HD
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHANNELUP",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHANNELDOWN",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_SCREEN"]: ("PIP",),
+	KEYIDS["KEY_AUDIO"]: ("AUDIO",),
+	KEYIDS["KEY_WWW"]: ("WWW",),
+	KEYIDS["KEY_PROGRAM"]: ("SLEEP",),
+# Additions or Sogno HD 800 V3
+	KEYIDS["KEY_ZOOM"]: ("V.FORMAT",),
+}, {  # id=14 - Homecast HS8100/9000
+	KEYIDS["KEY_POWER"]: ("POWER",),
+	KEYIDS["KEY_TV2"]: ("TV_RADIO",),
+	KEYIDS["KEY_TEXT"]: ("TEXT",),
+	KEYIDS["KEY_1"]: ("1BUTTON",),
+	KEYIDS["KEY_2"]: ("2BUTTON",),
+	KEYIDS["KEY_3"]: ("3BUTTON",),
+	KEYIDS["KEY_4"]: ("4BUTTON",),
+	KEYIDS["KEY_5"]: ("5BUTTON",),
+	KEYIDS["KEY_6"]: ("6BUTTON",),
+	KEYIDS["KEY_7"]: ("7BUTTON",),
+	KEYIDS["KEY_8"]: ("8BUTTON",),
+	KEYIDS["KEY_9"]: ("9BUTTON",),
+	KEYIDS["KEY_BACK"]: ("RECALL",),
+	KEYIDS["KEY_0"]: ("0BUTTON",),
+	KEYIDS["KEY_MUTE"]: ("MUTE",),
+	KEYIDS["KEY_RED"]: ("RED",),
+	KEYIDS["KEY_GREEN"]: ("GREEN",),
+	KEYIDS["KEY_YELLOW"]: ("YELLOW",),
+	KEYIDS["KEY_BLUE"]: ("BLUE",),
+	KEYIDS["KEY_MENU"]: ("MENU",),
+	KEYIDS["KEY_EPG"]: ("EPG",),
+	KEYIDS["KEY_INFO"]: ("INFO",),
+	KEYIDS["KEY_UP"]: ("UP",),
+	KEYIDS["KEY_LEFT"]: ("LEFT",),
+	KEYIDS["KEY_OK"]: ("OK",),
+	KEYIDS["KEY_RIGHT"]: ("RIGHT",),
+	KEYIDS["KEY_DOWN"]: ("DOWN",),
+	KEYIDS["KEY_VOLUMEUP"]: ("VOLUMEUP",),
+	KEYIDS["KEY_CHANNELUP"]: ("CHANNELUP",),
+	KEYIDS["KEY_EXIT"]: ("EXIT",),
+	KEYIDS["KEY_VOLUMEDOWN"]: ("VOLUMEDOWN",),
+	KEYIDS["KEY_CHANNELDOWN"]: ("CHANNELDOWN",),
+	KEYIDS["KEY_PAUSE"]: ("PAUSE",),
+	KEYIDS["KEY_PLAY"]: ("PLAY",),
+	KEYIDS["KEY_REWIND"]: ("REWIND",),
+	KEYIDS["KEY_STOP"]: ("STOP",),
+	KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",),
+	KEYIDS["KEY_RECORD"]: ("RECORD",),
+	KEYIDS["KEY_SLOW"]: ("SLOW",),
+	KEYIDS["KEY_FILE"]: ("LIST",),
+	KEYIDS["KEY_AGAIN"]: ("REPEAT",),
+	KEYIDS["KEY_HELP"]: ("MARK",),
+	KEYIDS["KEY_GOTO"]: ("JUMP",),
+	KEYIDS["KEY_SCREEN"]: ("PIP",),
+#	KEYIDS["KEY_GOTO"]: ("PIP_SWAP",),
+#	KEYIDS["KEY_GOTO]": ("PIP_MOVE",),
+	KEYIDS["KEY_PROGRAM"]: ("SLEEP",)
 }]
 
 
@@ -374,10 +822,47 @@
 	else:
 		rcType = config.plugins.remotecontroltype.rctype.value
 		# rcType = config.misc.inputdevices.rcType.value
-		if rcType == 14:  # XP1000
+		print "[Keybindings.py] RC type is:", rcType
+		if rcType == 10:	# Spark
 			idx = 3
-		elif rcType == 18:  # F1
+		elif rcType == 7:	# Fortis FS9000/FS9200/HS8200
 			idx = 4
+		elif rcType == 8:	# Fortis HS9510/HS7420/HS7429/HS7810A/HS7819
+			idx = 4
+		elif rcType == 9:	# Fortis HS7110/HS7119
+			idx = 4
+		elif rcType == 11:	# Topfield TF77X0HDPVR
+			idx = 5
+		elif rcType == 12:	# Kathrein UFS912
+			idx = 6
+		elif rcType == 13:	# Cuberevo Universal
+			idx = 7
+		elif rcType == 14:	# Vitamin HD5000
+			idx = 8
+		elif rcType == 15:	# ADB XMP
+			idx = 9
+		elif rcType == 16:	# Pace 7241
+			idx = 10
+		elif rcType == 17:	# Edision argus
+			idx = 11
+		elif rcType == 18:	# HL101
+			idx = 12
+		elif rcType == 19:	# Kathrein UFS910, UFS922
+			idx = 6
+		elif rcType == 20:	# Kathrein UFS913
+			idx = 6
+		elif rcType == 21:	# Opticum HD 9600 series
+			idx = 13
+		elif rcType == 22:	# Cuberevo Standard
+			idx = 7
+		elif rcType == 23:	# Atemio AM 520 HD (version 2)
+			idx = 13
+		elif rcType == 24:	# Homecast HS8100/9000 series
+			idx = 14
+#		elif rcType == 25:	# Fortis 4G
+#			idx = 15
+#		elif rcType == 26:	# ...
+#			idx = 16
 		else:
 			idx = 2
 	return keyDescriptions[idx].get(key)
--- enigma2.org/lib/python/Screens/InputDeviceSetup.py
+++ enigma2/lib/python/Screens/InputDeviceSetup.py
@@ -282,77 +282,67 @@
 	rcList = [
 			("0", _("Default")),
 			("4", _("DMM normal")),
-			("5", _("et9000/et9100")),
 			("6", _("DMM advanced")),
-			("7", _("et5000/et6000")),
-			("8", _("VU+")),
-			("9", _("et8000/et10000")),
-			("11", _("et9200/et9500/et6500")),
-			("13", _("et4000")),
-			("14", _("xp1000")),
-			("16", _("HDx1/HD1xxx/HD5x0C/VS1x00/et7x00/et8500/et7000mini")),
-			("18", _("F1/F3/F4/F4-TURBO")),
-			("19", _("HD2400")),
-			("20", _("Zgemma Star S/2S/H1/H2")),
-			("21", _("Zgemma H.S/H.2S/H.2H/H5/H7(old model)")),
-			("24", _("Axas E4HD Ultra")),
-			("25", _("Zgemma H9(old model)/I55Plus/H8")),
-			("27", _("HD60/HD66SE/Multibox/Multibox SE")),
-			("28", _("I55SE/H7(new model)/H9(new model)/H9COMBO/H9TWIN/H9SE/H9COMBOSE/H10/H11")),
-			("30", _("PULSe 4K(mini)"))
+			("7", _("Fortis universal")),
+			("8", _("Fortis standard")),
+			("9", _("Fortis mini")),
+			("10", _("Spark")),
+			("11", _("Topfield TF77X0HDPVR")),
+			("12", _("Kathrein RC671 (UFS912")),
+			("13", _("CubeRevo universal")),
+			("14", _("Vitamin 5000HD")),
+			("15", _("ADB XMP")),
+			("16", _("Pace HDS7241")),
+			("17", _("Edision argus")),
+			("18", _("HL-101")),
+			("19", _("Kathrein RC660 (UFS910/922")),
+			("20", _("Kathrein RC675 (UFS913)")),
+			("21", _("Opticum HD 9600 series")),
+			("22", _("CubeRevo standard")),
+			("23", _("Atemio AM 520 HD V2")),
+			("24", _("Homecast HS8100/9000")),
+#			("25", _("fortis_4g")),
 		]
 
 	defaultRcList = [
-			("et4000", 13),
-			("et5000", 7),
-			("et6000", 7),
-			("et6500", 11),
-			("et8000", 9),
-			("et9000", 5),
-			("et9100", 5),
-			("et9200", 11),
-			("et9500", 11),
-			("et10000", 9),
-			("formuler1", 18),
-			("formuler3", 18),
-			("formuler4", 18),
-			("formuler4turbo", 18),
-			("xp1000", 14),
-			("vs1000", 16),
-			("vs1500", 16),
-			("hd500c", 16),
-			("hd530c", 16),
-			("hd11", 16),
-			("hd51", 16),
-			("hd1200", 16),
-			("hd1265", 16),
-			("hd1100", 16),
-			("hd2400", 19),
-			("hd60", 27),
-			("hd66se", 27),
-			("multibox", 27),
-			("multiboxse", 27),
-			("et7000mini", 16),
-			("et7000", 16),
-			("et7500", 16),
-			("et8500", 16),
-			("sh1", 20),
-			("h3", 21),
-			("h5", 21),
-			("e4hd", 24),
-			("h8", 25),
-			("h9se", 28),
-			("h9combo", 28),
-			("h9combose", 28),
-			("i55se", 28),
-			("h7", 28), # new model /old 21
-			("h9", 28), # new model /old 25
-			("h9twin", 28),
-			("h9twinse", 28),
-			("h10", 28),
-			("h11", 28),
-			("pulse4k", 30),
-			("pulse4kmini", 30)
+			("fs9000", 7),
+			("hs8200", 7),
+			("hs9510", 8),
+			("hs7420", 8),
+			("hs7429", 8),
+			("hs7810a", 8),
+			("hs7819", 8),
+			("hs7110", 9),
+			("hs7119", 9),
+			("spark", 10),
+			("spark7162", 10),
+			("tf7700", 11),
+			("ufs910", 19),
+			("ufs912", 12),
+			("ufs913", 20),
+			("ufs922", 12),
+			("cuberevo", 13),
+			("cuberevo-mini", 13),
+			("cuberevo-mini2", 13),
+			("cuberevo-250hd", 22),
+			("cuberevo-9500hd", 13),
+			("cuberevo-2000hd", 13),
+			("cuberevo-3000hd", 13),
+			("cuberevo-mini-fta", 22),
+			("vitamin-hd5000", 14),
+			("adb-box", 15),
+			("adb-2850", 15),
+			("pace7241", 16),
+			("hl101", 18),
+			("vip1-v1", 17),
+			("vip1-v2", 17),
+			("vip2", 17),
+			("opt9600", 21),
+			("opt9600mini", 21),
+			("opt9600prima", 21),
+			("atemio520", 23),
+			("hchs8100", 24),
+#			("fortis_4g", 25),
 		]
 
 	def __init__(self, session):
--- enigma2.org/data/rc_models/rc_models.cfg
+++ enigma2/data/rc_models/rc_models.cfg
@@ -19,163 +19,40 @@
 #
 # When no entry matches at all, 'default' will be used as remoteName
 #
-# Amiko
-vipercombo      amiko
-vipert2c        amiko
-vipercombohdd   amiko1
-viperslim       viperslim
-#
-#Axas
-e4hd            e4hd
-#
-# Edision
-osmega          osmini
-osmini4k        edision4
-osmini          osmini
-osminiplus      osmini
-osmio4k         edision4
-osmio4kplus     edision4
-osnino          edision1
-osninoplus      edision2
-osninopro       edision3
-#
-# Formuler
-formuler1       formuler1
-formuler3       formuler1
-formuler4       formuler1
-formuler4turbo  formuler1
-#
-# Galaxy innovations
-et7000mini      et7000mini
-et11000         et7000mini
-#
-# Gigablue
-gbquad4k        gb7252
-gbue4k          gb7252
-gbtrio4k        gb7252
-#
-# Max Digital
-xp1000          xp1000
-#
-# MaXitec
-multibox        multibox
-multiboxse	multibox
-#
-# Miraclebox
-mbtwinplus      miraclebox
-7000S           miraclebox2
-7005S           miraclebox2
-#
-# Mutant
-hd11            hd-gen
-hd51            hd-gen
-hd60            hd60
-hd66se          hd66se
-hd500c          hd-gen
-hd530c          hd-gen
-hd1100          hd-gen
-hd1200          hd-gen
-hd1265          hd-gen
-hd1500          hd-gen
-hd2400          hd2400
-#
-# Vimastec
-vs1000          vs1x00
-vs1500          vs1x00
-#
-# SAB
-alphatriplehd   sab
-#
-# Qviart
-lunix           qviart
-lunix3-4k       qviart
-lunix4k         lunix4k
-dual            dual
-#
-# Spycat
-spycat          spycat
-spycatmini      spycat
-spycatminiplus  spycat
-#
-#Golden Interstar
-xpeedlx         xpeedlx
-#
-# Vu+
-vuduo           vu
-vuduo2          vuduo2
-vuduo4k         vu2
-vuduo4kse       vu2
-vusolo          vu
-vusolo2         vu
-vusolose        vu
-vusolo4k        vu
-vuultimo        vuultimo
-vuultimo4k      vu
-vuuno           vu
-vuuno4k         vu
-vuuno4kse       vu2
-vuzero4k        vu2
-vuzero          vu
-#
-# Xsarius
-fusionhd        xsarius
-fusionhdse      xsarius
-galaxy4k        revo4k
-purehd          xsarius
-purehdse        xsarius
-revo4k          revo4k
-#
-# Xtrend
-et4000          et4x00
-et5000          et6x00
-et6000          et6x00
-et6500          et6x00
-et6500.4        dmm
-et6500.6        dmmadv
-et7000          et7x00
-et7500          et7x00
-et8000          et8000
-et8000.4        dmm
-et8000.6        dmmadv
-et8500          et8000
-et9000          et9x00
-et9000.4        dmm
-et9000.6        dmmadv
-et9000.9        et9500
-et9200          et9x00
-et9500          et9500
-et10000         et8000
-et10000.4       dmm
-et10000.6       dmmadv
-#
-# Zgemma
-i55             i55
-i55plus         zgemma
-i55se           zgemma
-h3              zgemma
-h4              zgemma
-h5              zgemma
-h6              zgemma
-h7              zgemma
-h8              zgemma
-h9              zgemma
-h9se            zgemma
-h9combo         zgemma
-h9twin          zgemma
-h9combose       zgemma
-h9twinse        zgemma
-h10             zgemma
-h11             zgemma
-lc              sh1
-sh1             sh1
-#
-# Octagon
-sf8008         octagon
-sf8008m        octagon
-#
-# uClan
-ustym4kpro     uclan
-#
-# AB-COM
-pulse4k        pulse
-pulse4kmini    pulse
+fs9000            fs9000
+hs9510            hs9510
+hs8200            fs9000
+hs7110            hs7110
+hs7119            hs7110
+hs7420            hs9510
+hs7429            hs9510
+hs7810a           hs9510
+hs7819            hs9510
+spark             spark
+spark7162         spark
+tf7700hdpvr       tf7700
+ufs910            ufs910
+ufs912            ufs912
+ufs913            ufs913
+ufs922            ufs912
+cuberevo          cuberevo_uni
+cuberevo-mini-fta cuberevo
+cuberevo-250hd    cuberevo
+cuberevo-mini     cuberevo_uni
+cuberevo-mini2    cuberevo_uni
+cuberevo-2000hd   cuberevo_uni
+cuberevo-3000hd   cuberevo_uni
+cuberevo-9500hd   cuberevo_uni
+vitamin_hd5000    vitamin
+adb_box           adb_xmp
+adb-2850          adb_xmp
+pace7241          pace7241
+hl101             hl101_1
+vip1-v1           vip_1
+vip1-v2           vip_1
+vip2              vip_1
+opt9600           opt9600
+opt9600mini       opt9600
+opt9600prima      opt9600
+atemio520         atemio520
+hchs8100          hchs8100
--- enigma2.org/data/rc_models/Makefile.am
+++ enigma2/data/rc_models/Makefile.am
@@ -2,15 +2,10 @@
 
 dist_install_DATA = \
 	rc_models.cfg \
-	dmmadv.png amiko.png amiko1.png edision1.png et4x00.png et8000.png et9x00.png vu.png xp1000.png \
-	dmm.png et6x00.png et9500.png vuduo2.png vuultimo.png vu2.png et7x00.png formuler1.png \
-	hd2400.png hd-gen.png vs1x00.png osmini.png zgemma.png miraclebox.png miraclebox2.png \
-	spycat.png xpeedlx.png revo4k.png sab.png sh1.png i55.png qviart.png gb7252.png e4hd.png \
-	edision2.png edision3.png edision4.png hd60.png lunix4k.png multibox.png viperslim.png octagon.png \
-	uclan.png pulse.png dual.png hd66se.png \
-	dmmadv.xml edision1.xml et4x00.xml et8000.xml et9x00.xml vuultimo.xml xp1000.xml dmm.xml amiko.xml \
-	amiko1.xml et6x00.xml et9500.xml et7x00.xml vuduo2.xml vu.xml vu2.xml formuler1.xml hd2400.xml hd-gen.xml \
-	vs1x00.xml xsarius.xml xsarius.png osmini.xml zgemma.xml miraclebox.xml miraclebox2.xml \
-	spycat.xml xpeedlx.xml et7000mini.png et7000mini.xml revo4k.xml sab.xml sh1.xml i55.xml qviart.xml \
-	gb7252.xml e4hd.xml edision2.xml edision3.xml edision4.xml hd60.xml lunix4k.xml multibox.xml viperslim.xml \
-	octagon.xml uclan.xml pulse.xml dual.xml hd66se.xml
+	dmmadv.png \
+	adb_xmp.png cuberevo_uni.png fs9000.png hs7110.png hs9510.png spark.png tf7700.png ufs912.png vitamin.png \
+	pace7241.png hl101_1.png vip_1.png ufs910.png ufs913.png opt9600.png cuberevo.png atemio520.png hchs8100.png dmm.png \
+	dmmadv.xml  \
+	adb_xmp.xml cuberevo_uni.xml fs9000.xml hs7110.xml hs9510.xml spark.xml tf7700.xml ufs912.xml vitamin.xml \
+	pace7241.xml hl101_1.xml vip_1.xml ufs910.xml ufs913.xml opt9600.xml cuberevo.xml atemio520.xml hchs8100.xml dmm.xml
+

